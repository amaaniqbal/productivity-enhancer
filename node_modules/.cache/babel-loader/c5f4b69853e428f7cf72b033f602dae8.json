{"ast":null,"code":"/**\n * Bundle of @devexpress/dx-chart-core\n * Generated: 2020-11-03\n * Version: 2.7.3\n * License: https://js.devexpress.com/Licensing\n */\nimport { extent } from 'd3-array';\nimport { scaleLinear as scaleLinear$1, scaleBand as scaleBand$1 } from 'd3-scale';\nimport { area, line, curveMonotoneX, curveMonotoneY, pie, symbol, symbolCircle, arc, stack } from 'd3-shape';\nimport { hasWindow } from '@devexpress/dx-core';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n}\n/** @internal */\n\n\nvar HORIZONTAL = 'horizontal';\n/** @internal */\n\nvar VERTICAL = 'vertical';\n/** @internal */\n\nvar TOP = 'top';\n/** @internal */\n\nvar BOTTOM = 'bottom';\n/** @internal */\n\nvar LEFT = 'left';\n/** @internal */\n\nvar RIGHT = 'right';\n/** @internal */\n\nvar MIDDLE = 'middle';\n/** @internal */\n\nvar END = 'end';\n/** @internal */\n\nvar START = 'start';\n/** @internal */\n\nvar LINEAR = 'linear';\n/** @internal */\n\nvar BAND = 'band';\n/** @internal */\n\nvar ARGUMENT_DOMAIN = 'argument-domain';\n/** @internal */\n\nvar VALUE_DOMAIN = 'value-domain';\n/** @internal */\n\nvar HOVERED = 'hovered';\n/** @internal */\n\nvar SELECTED = 'selected';\n/** @internal */\n\nvar DIFFERENCE = 0.9;\n/** @internal */\n\nvar scaleLinear = scaleLinear$1;\n\nvar scaleBand = function () {\n  return scaleBand$1().paddingInner(0.3).paddingOuter(0.15);\n};\n/** @internal */\n\n\nvar isHorizontal = function (name, rotated) {\n  return name === ARGUMENT_DOMAIN === !rotated;\n}; // tslint:disable-next-line: ban-types\n\n\nvar makeScaleHelper = function (linear, band) {\n  var func = function (scale) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var choosen = 'bandwidth' in scale ? band : linear;\n    return choosen.apply(void 0, __spread([scale], args));\n  };\n\n  return func;\n};\n\nvar getLinearScaleWidth = function (_) {\n  return 0;\n};\n\nvar getBandScaleWidth = function (scale) {\n  return scale.bandwidth();\n};\n/** @internal */\n\n\nvar getWidth = makeScaleHelper(getLinearScaleWidth, getBandScaleWidth);\n/** @internal */\n\nvar getValueDomainName = function (name) {\n  return name || VALUE_DOMAIN;\n};\n\nvar floatsEqual = function (a, b) {\n  return Math.abs(a - b) < Number.EPSILON;\n};\n/** @internal */\n\n\nvar rangesEqual = function (r1, r2) {\n  return floatsEqual(r1[0], r2[0]) && floatsEqual(r1[1], r2[1]);\n};\n\nvar wrapLinearScale = function (scale) {\n  return scale;\n};\n\nvar wrapBandScale = function (scale) {\n  var ret = function (value) {\n    return scale(value) + scale.bandwidth() / 2;\n  };\n\n  Object.assign(ret, scale);\n  return ret;\n};\n\nvar wrapScale = makeScaleHelper(wrapLinearScale, wrapBandScale);\n/** @internal */\n\nvar makeScale = function (_a, range) {\n  var factory = _a.factory,\n      domain = _a.domain;\n  var scale = (factory || scaleLinear)().domain(domain).range(range);\n  return wrapScale(scale);\n}; // It is implicitly supposed that Chart can accept any d3 scale. It is wrong.\n// The followings notes show that. d3 scales are not seamlessly interchangeable themselves\n// (i.e. band scale has no \"invert\", continuous scale has no \"bandwidth\").\n// We have to use \"adapters\" to mitigate the differences.\n// Hence Chart can actually accept any object that matches \"adapter\" interface.\n// TODO: We should update reference accordingly. There might be breaking changes though.\n\n\nvar scaleLinearBounds = function (scale, bounds) {\n  return bounds.map(scale);\n}; // There is an issue - when range is \"inverted\" values are scaled incorrectly.\n//   scaleBand().domain(['a', 'b', 'c']).range([0, 60])('b') === 20\n//   scaleBand().domain(['a', 'b', 'c']).range([60, 0])('b') === 20 (should be 40)\n\n\nvar scaleBandBounds = function (scale, bounds) {\n  var cleanScale = scale.copy().paddingInner(0).paddingOuter(0);\n  var fullRange = scale.range();\n  var sign = Math.sign(fullRange[1] - fullRange[0]);\n  return sign >= 0 ? [cleanScale(bounds[0]), cleanScale(bounds[1]) + cleanScale.bandwidth()] : [cleanScale(bounds[0]) + cleanScale.bandwidth(), cleanScale(bounds[1])];\n};\n\nvar moveLinearScaleBounds = function (scale, bounds, delta) {\n  var fullRange = scale.range();\n  var sign = Math.sign(fullRange[1] - fullRange[0]);\n  var range = scaleLinearBounds(scale, bounds);\n  var r0 = range[0] + delta;\n  var r1 = range[1] + delta; // Check if new range is outside of the left border.\n\n  if (Math.sign(r0 - fullRange[0]) !== sign) {\n    r0 = fullRange[0];\n    r1 = r0 + range[1] - range[0];\n  } // Check if new range is outside of the right border.\n\n\n  if (Math.sign(fullRange[1] - r1) !== sign) {\n    r1 = fullRange[1];\n    r0 = r1 - range[1] + range[0];\n  }\n\n  var newBounds = [scale.invert(r0), scale.invert(r1)];\n  return rangesEqual(bounds, newBounds) ? bounds : newBounds;\n}; // This is pointer \"delta\" processing specific for \"band\" scale.\n// If pointer delta is significantly smaller than band size (0.3) then movement should be skipped\n// and current delta should be added to a next one (from a new \"move\" event).\n// Now there is no code that accumulates deltas.\n// In order to allow band scrolling at least somehow the following is applied - if pointer delta\n// is at least greater than 30 pixel then minimal movement is performed.\n// TODO: Make proper delta accumulation!\n\n\nvar adjustBandScaleMoveStep = function (delta, step) {\n  var ratio = Math.abs(delta / step);\n  var sign = Math.sign(delta / step);\n\n  if (ratio >= 0.5) {\n    return sign * Math.round(ratio);\n  }\n\n  if (ratio >= 0.3) {\n    return sign;\n  }\n\n  if (Math.abs(delta) > 30) {\n    return sign;\n  }\n\n  return 0;\n}; // Band case is processed separately to preserve categories count in the bounds range.\n// If common inversion mechanism is used start and end bounds cannot be inverted independently\n// because of rounding issues which may add or remove categories to the new bounds.\n\n\nvar moveBandScaleBounds = function (scale, bounds, delta) {\n  var domain = scale.domain();\n  var fullRange = scale.range();\n  var step = (fullRange[1] - fullRange[0]) / domain.length;\n  var rangeStep = adjustBandScaleMoveStep(delta, step);\n\n  if (rangeStep === 0) {\n    return bounds;\n  }\n\n  var range = scaleBounds(scale, bounds);\n  var range0 = Math.round((range[0] - fullRange[0]) / step);\n  var range1 = range0 + Math.round((range[1] - range[0]) / step) - 1;\n  var new0 = range0 + rangeStep;\n  var new1 = range1 + rangeStep;\n\n  if (new0 < 0) {\n    new0 = 0;\n    new1 = new0 + range1 - range0;\n  }\n\n  if (new1 > domain.length - 1) {\n    new1 = domain.length - 1;\n    new0 = new1 - range1 + range0;\n  }\n\n  if (new0 === range0 || new1 === range1) {\n    return bounds;\n  }\n\n  return [domain[new0], domain[new1]];\n}; // Defines how much linear scale can be zoomed it.\n// I.e. if original scale domain has size of 1, then fully zoomed scale domain has size\n// of 1 / LINEAR_SCALE_ZOOMING_THRESHOLD.\n\n\nvar LINEAR_SCALE_ZOOMING_THRESHOLD = 1000;\n\nvar growLinearScaleBounds = function (scale, bounds, delta, anchor) {\n  var fullRange = scale.range();\n  var minRangeThreshold = (fullRange[1] - fullRange[0]) / LINEAR_SCALE_ZOOMING_THRESHOLD;\n  var sign = Math.sign(fullRange[1] - fullRange[0]);\n  var range = scaleBounds(scale, bounds); // If zooming in and initial range is already too small then do nothing.\n\n  if (delta > 0 && Math.abs(range[1] - range[0]) <= Math.abs(minRangeThreshold)) {\n    return bounds;\n  } // If zooming out and initial range is already too large then do nothing.\n\n\n  if (delta < 0 && Math.abs(range[1] - range[0]) >= Math.abs(fullRange[1] - fullRange[0])) {\n    return bounds;\n  }\n\n  var t = Math.abs((anchor - range[0]) / (range[1] - range[0]));\n  var r0 = range[0] + sign * delta * 2 * t;\n  var r1 = range[1] - sign * delta * 2 * (1 - t); // If new range is outside of the left border then clamp it.\n\n  if (Math.sign(r0 - fullRange[0]) !== sign) {\n    r0 = fullRange[0];\n  } // If new range is outside of the right border then clamp it.\n\n\n  if (Math.sign(fullRange[1] - r1) !== sign) {\n    r1 = fullRange[1];\n  } // If new range is too small then make it no less than minimal available.\n\n\n  if (Math.sign(r1 - r0) !== sign || Math.abs(r1 - r0) < Math.abs(minRangeThreshold)) {\n    if (Math.abs(r0 - range[0]) < Math.abs(minRangeThreshold / 2)) {\n      // Dock it to the start.\n      r0 = range[0];\n      r1 = r0 + minRangeThreshold;\n    } else if (Math.abs(r1 - range[1]) < Math.abs(minRangeThreshold / 2)) {\n      // Dock it to the end.\n      r1 = range[1];\n      r0 = r1 - minRangeThreshold;\n    } else {\n      // Dock it to the anchor.\n      r0 = anchor - minRangeThreshold / 2;\n      r1 = anchor + minRangeThreshold / 2;\n    }\n  }\n\n  var newBounds = [scale.invert(r0), scale.invert(r1)];\n  return rangesEqual(bounds, newBounds) ? bounds : newBounds;\n};\n\nvar growBandScaleBounds = function (scale, bounds, delta, anchor) {\n  var domain = scale.domain();\n  var fullRange = scale.range();\n  var step = (fullRange[1] - fullRange[0]) / domain.length;\n  var range = scaleBounds(scale, bounds);\n  var range0 = Math.round((range[0] - fullRange[0]) / step);\n  var range1 = range0 + Math.round((range[1] - range[0]) / step) - 1; // Let it be always 1 for now.\n\n  var rangeStep = Math.sign(delta);\n\n  if (rangeStep === 0 || rangeStep > 0 && range0 === range1 || rangeStep < 0 && range0 === 0 && range1 === domain.length - 1) {\n    return bounds;\n  }\n\n  var t = Math.abs((anchor - range[0]) / (range[1] - range[0]));\n  var new0 = range0 + Math.round(rangeStep * 2 * t);\n  var new1 = range1 - Math.round(rangeStep * 2 * (1 - t));\n\n  if (new0 < 0) {\n    new0 = 0;\n  }\n\n  if (new1 > domain.length - 1) {\n    new1 = domain.length - 1;\n  }\n\n  if (new0 > new1) {\n    if (t <= 0.5) {\n      new1 = new0;\n    } else {\n      new0 = new1;\n    }\n  }\n\n  if (new0 === range0 && new1 === range1) {\n    return bounds;\n  }\n\n  return [domain[new0], domain[new1]];\n};\n\nvar invertLinearScaleBounds = function (scale, range) {\n  var fullRange = scale.range();\n  var match = Math.sign(fullRange[1] - fullRange[0]) === Math.sign(range[1] - range[0]);\n  return [scale.invert(range[match ? 0 : 1]), scale.invert(range[match ? 1 : 0])];\n};\n\nvar matchPointToBand = function (domain, range, p) {\n  var i = Math.floor(domain.length * (p - range[0]) / (range[1] - range[0]));\n  return domain[Math.min(i, domain.length - 1)];\n};\n\nvar invertBandScaleBounds = function (scale, range) {\n  var domain = scale.domain();\n  var fullRange = scale.range();\n  return [matchPointToBand(domain, fullRange, range[0]), matchPointToBand(domain, fullRange, range[1])];\n}; // Though these functions are used only in *Viewport* plugin (and so should be placed right there),\n// they reside here so that internal scale specifics (*getWidth*)\n// are encapsulated in this utility file.\n\n/** @internal */\n\n\nvar scaleBounds = makeScaleHelper(scaleLinearBounds, scaleBandBounds);\n/** @internal */\n\nvar moveBounds = makeScaleHelper(moveLinearScaleBounds, moveBandScaleBounds); // \"scaleBounds\" would be a better name but \"scale\" is already occupied.\n\n/** @internal */\n\nvar growBounds = makeScaleHelper(growLinearScaleBounds, growBandScaleBounds);\n/** @internal */\n\nvar invertBoundsRange = makeScaleHelper(invertLinearScaleBounds, invertBandScaleBounds);\n\nvar _a;\n\nvar makeDomain = function (_a) {\n  var factory = _a.factory,\n      modifyDomain = _a.modifyDomain;\n  return {\n    domain: [],\n    factory: factory,\n    isDiscrete: !!(factory && isDiscrete(factory)),\n    modifyDomain: modifyDomain\n  };\n};\n/** @internal */\n\n\nvar defaultDomains = (_a = {}, _a[ARGUMENT_DOMAIN] = makeDomain({}), _a[VALUE_DOMAIN] = makeDomain({}), _a);\n/** @internal */\n\nvar addDomain = function (domains, name, options) {\n  var _a;\n\n  return __assign(__assign({}, domains), (_a = {}, _a[name] = makeDomain(options), _a));\n};\n\nvar mergeContinuousDomains = function (domain, items) {\n  var newDomain = extent(__spread(domain, items));\n  return rangesEqual(newDomain, domain) ? domain : newDomain;\n};\n\nvar mergeDiscreteDomains = function (domain, items) {\n  var newDomain = Array.from(new Set(__spread(domain, items)));\n  return newDomain.length === domain.length ? domain : newDomain;\n};\n\nvar getArgument = function (point) {\n  return point.argument;\n};\n\nvar getValue = function (point) {\n  return point.value;\n};\n\nvar guessFactory = function (points, getItem) {\n  return points.length && typeof getItem(points[0]) === 'string' ? scaleBand : scaleLinear;\n};\n\nvar isDiscrete = function (factory) {\n  return 'bandwidth' in factory();\n};\n\nvar updateDomainFactory = function (domain, series, getItem) {\n  if (domain.factory) {\n    return domain;\n  }\n\n  var factory = guessFactory(series.points, getItem);\n  return __assign(__assign({}, domain), {\n    factory: factory,\n    isDiscrete: isDiscrete(factory)\n  });\n};\n/** @internal */\n\n\nvar updateDomainItems = function (domain, items) {\n  var merge = domain.isDiscrete ? mergeDiscreteDomains : mergeContinuousDomains;\n  var merged = merge(domain.domain, items);\n  return merged === domain.domain ? domain : __assign(__assign({}, domain), {\n    domain: domain.modifyDomain ? domain.modifyDomain(merged) : merged\n  });\n};\n\nvar getArgumentDomainItems = function (series) {\n  return series.points.map(getArgument);\n};\n\nvar getValueDomainItems = function (series) {\n  var items = series.points.map(getValue);\n  return series.getPointTransformer.isStartedFromZero ? __spread([0], items) : items;\n};\n\nvar updateDomain = function (domain, series, getItem, getDomainItems) {\n  return updateDomainItems(updateDomainFactory(domain, series, getItem), getDomainItems(series));\n};\n/** @internal */\n\n\nvar extendDomains = function (domains, series) {\n  var argumentDomain = updateDomain(domains[ARGUMENT_DOMAIN], series, getArgument, getArgumentDomainItems);\n  var valueDomainName = getValueDomainName(series.scaleName);\n  var valueDomain = updateDomain(domains[valueDomainName], series, getValue, getValueDomainItems);\n  var changes = {};\n\n  if (argumentDomain !== domains[ARGUMENT_DOMAIN]) {\n    changes[ARGUMENT_DOMAIN] = argumentDomain;\n  }\n\n  if (valueDomain !== domains[valueDomainName]) {\n    changes[valueDomainName] = valueDomain;\n  }\n\n  return Object.keys(changes).length ? __assign(__assign({}, domains), changes) : domains;\n};\n/** @internal */\n\n\nvar buildScales = function (domains, ranges) {\n  var scales = {};\n  Object.keys(domains).forEach(function (name) {\n    scales[name] = makeScale(domains[name], ranges[name === ARGUMENT_DOMAIN ? ARGUMENT_DOMAIN : VALUE_DOMAIN]);\n  });\n  return scales;\n};\n\nvar isEqual = function (_a, _b) {\n  var firstWidth = _a.width,\n      firstHeight = _a.height;\n  var secondWidth = _b.width,\n      secondHeight = _b.height;\n  return firstWidth === secondWidth && firstHeight === secondHeight;\n};\n/** @internal */\n\n\nvar bBoxes = function (prevBBoxes, _a) {\n  var _b;\n\n  var bBox = _a.bBox,\n      placeholder = _a.placeholder;\n  if (isEqual(prevBBoxes[placeholder] || {}, bBox)) return prevBBoxes;\n  return __assign(__assign({}, prevBBoxes), (_b = {}, _b[placeholder] = bBox, _b));\n};\n/** @internal */\n\n\nvar getRanges = function (paneSize, rotated) {\n  var _a;\n\n  var horRange = [0, paneSize.width];\n  var verRange = [paneSize.height, 0];\n  return _a = {}, _a[ARGUMENT_DOMAIN] = rotated ? verRange : horRange, _a[VALUE_DOMAIN] = rotated ? horRange : verRange, _a;\n};\n\nvar _a$1, _b;\n\nvar getTicks = function (scale, count) {\n  return scale.ticks ? scale.ticks(count) : scale.domain();\n};\n\nvar createTicks = function (scale, count, callback) {\n  return getTicks(scale, count).map(function (tick, index) {\n    return callback(scale(tick), String(index), tick);\n  });\n};\n\nvar getFormat = function (scale, count, tickFormat) {\n  if (scale.tickFormat) {\n    return tickFormat ? tickFormat(scale, count) : scale.tickFormat(count);\n  }\n\n  return function (tick) {\n    return tick;\n  };\n};\n\nvar rotatedPositions = (_a$1 = {}, _a$1[LEFT] = BOTTOM, _a$1[RIGHT] = TOP, _a$1[BOTTOM] = LEFT, _a$1[TOP] = RIGHT, _a$1);\nvar positionFlags = (_b = {}, _b[LEFT] = false, _b[RIGHT] = false, _b[BOTTOM] = true, _b[TOP] = true, _b);\n/** @internal */\n\nvar getRotatedPosition = function (position) {\n  return rotatedPositions[position];\n};\n/** @internal */\n\n\nvar isValidPosition = function (position, scaleName, rotated) {\n  return positionFlags[position] === isHorizontal(scaleName, rotated);\n};\n\nvar createHorizontalOptions = function (position, tickSize, indentFromAxis) {\n  // Make *position* orientation agnostic - should be START or END.\n  var isStart = position === BOTTOM;\n  return {\n    y1: 0,\n    y2: isStart ? +tickSize : -tickSize,\n    yText: isStart ? +indentFromAxis : -indentFromAxis,\n    dy: isStart ? '1em' : '0em',\n    textAnchor: MIDDLE\n  };\n};\n\nvar createVerticalOptions = function (position, tickSize, indentFromAxis) {\n  // Make *position* orientation agnostic - should be START or END.\n  var isStart = position === LEFT;\n  return {\n    x1: 0,\n    x2: isStart ? -tickSize : +tickSize,\n    xText: isStart ? -indentFromAxis : +indentFromAxis,\n    dy: '0.3em',\n    textAnchor: isStart ? END : START\n  };\n}; // Constant is selected to preserve original behavior described in\n// https://github.com/d3/d3-scale#continuous_ticks.\n\n\nvar DEFAULT_TICK_COUNT = 10;\n\nvar getTickCount = function (scaleRange, paneSize) {\n  var rangeToPaneRatio = Math.abs(scaleRange[0] - scaleRange[1]) / paneSize;\n  return Math.round(DEFAULT_TICK_COUNT * (isFinite(rangeToPaneRatio) ? rangeToPaneRatio : 1));\n};\n\nvar createTickFilter = function (isHor, size) {\n  return isHor ? function (tick) {\n    return tick.x1 >= 0 && tick.x1 <= size;\n  } : function (tick) {\n    return tick.y1 >= 0 && tick.y1 <= size;\n  };\n};\n/** @internal */\n\n\nvar tickCoordinatesGetter = function (_a) {\n  var isHor = _a.isHor,\n      scale = _a.scale,\n      tickCount = _a.tickCount,\n      tickFormat = _a.tickFormat,\n      position = _a.position,\n      tickSize = _a.tickSize,\n      indentFromAxis = _a.indentFromAxis;\n  var formatTick = getFormat(scale, tickCount, tickFormat);\n  var options = (isHor ? createHorizontalOptions : createVerticalOptions)(position, tickSize, indentFromAxis);\n  return function (coordinates, key, tick) {\n    return __assign({\n      key: key,\n      x1: coordinates,\n      x2: coordinates,\n      y1: coordinates,\n      y2: coordinates,\n      xText: coordinates,\n      yText: coordinates,\n      text: formatTick(tick)\n    }, options);\n  };\n};\n/** @internal */\n\n\nvar gridCoordinatesGetter = function (_a) {\n  var isHor = _a.isHor;\n  var options = isHor ? {\n    y1: 0\n  } : {\n    x1: 0\n  };\n  return function (coordinates, key) {\n    return __assign({\n      key: key,\n      x1: coordinates,\n      y1: coordinates\n    }, options);\n  };\n};\n/** @internal */\n\n\nvar getTickCoordinates = function (_a) {\n  var scaleName = _a.scaleName,\n      scale = _a.scale,\n      paneSize = _a.paneSize,\n      rotated = _a.rotated,\n      callback = _a.callback,\n      restProps = __rest(_a, [\"scaleName\", \"scale\", \"paneSize\", \"rotated\", \"callback\"]);\n\n  var isHor = isHorizontal(scaleName, rotated);\n  var tickCount = getTickCount(scale.range(), paneSize[1 - Number(isHor)]);\n  var ticks = createTicks(scale, tickCount, callback(__assign({\n    isHor: isHor,\n    scale: scale,\n    tickCount: tickCount\n  }, restProps)));\n  var visibleTicks = ticks.filter(createTickFilter(isHor, paneSize[1 - Number(isHor)]));\n  return {\n    ticks: visibleTicks,\n    sides: [Number(isHor), Number(!isHor)]\n  };\n};\n\nvar getArg = function (_a) {\n  var arg = _a.arg;\n  return arg;\n};\n\nvar getVal = function (_a) {\n  var val = _a.val;\n  return val;\n};\n\nvar getStartVal = function (_a) {\n  var startVal = _a.startVal;\n  return startVal;\n};\n/** @internal */\n\n\nvar dArea = area().x(getArg).y1(getVal).y0(getStartVal);\n/** @internal */\n\nvar dRotateArea = area().x1(getStartVal).x0(getVal).y(getArg);\n/** @internal */\n\nvar dLine = line().x(getArg).y(getVal);\n/** @internal */\n\nvar dRotateLine = line().x(getVal).y(getArg);\n/** @internal */\n\nvar dSpline = line().x(getArg).y(getVal).curve(curveMonotoneX);\n/** @internal */\n\nvar dRotateSpline = line().x(getVal).y(getArg).curve(curveMonotoneY);\n/** @internal */\n\nvar dBar = function (arg, val, startVal, width, rotated) {\n  var height = Math.abs(val - startVal);\n  var minVal = Math.min(val, startVal);\n  return {\n    x: rotated ? minVal : arg - width / 2,\n    y: rotated ? arg - width / 2 : minVal,\n    width: rotated ? height : width || 2,\n    height: rotated ? width || 2 : height\n  };\n};\n/** @internal */\n\n\nvar getPiePointTransformer = function (_a) {\n  var argumentScale = _a.argumentScale,\n      valueScale = _a.valueScale,\n      points = _a.points;\n  var x = Math.max.apply(Math, __spread(argumentScale.range())) / 2;\n  var y = Math.max.apply(Math, __spread(valueScale.range())) / 2;\n  var maxRadius = Math.min(x, y);\n  var pieData = pie().sort(null).value(function (d) {\n    return d.value;\n  })(points);\n  return function (point) {\n    var _a = pieData[point.index],\n        startAngle = _a.startAngle,\n        endAngle = _a.endAngle;\n    return __assign(__assign({}, point), {\n      arg: x,\n      val: y,\n      startAngle: startAngle,\n      endAngle: endAngle,\n      maxRadius: maxRadius\n    });\n  };\n};\n/** @internal */\n\n\nvar getLinePointTransformer = function (_a) {\n  var argumentScale = _a.argumentScale,\n      valueScale = _a.valueScale;\n  return function (point) {\n    return __assign(__assign({}, point), {\n      arg: argumentScale(point.argument),\n      val: valueScale(point.value)\n    });\n  };\n}; // Though transformations for line and scatter are the same,\n// separate function instance is required as it contains additional static fields.\n\n/** @internal */\n\n\nvar getScatterPointTransformer = function () {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  return getLinePointTransformer.apply(void 0, __spread(args));\n};\n/** @internal */\n\n\nvar getAreaPointTransformer = function (series) {\n  var transform = getLinePointTransformer(series);\n  var startVal = series.valueScale(0);\n  return function (point) {\n    var ret = transform(point);\n    return __assign(__assign({}, ret), {\n      startVal: startVal\n    });\n  };\n}; // Used for domain calculation and stacking.\n\n\ngetAreaPointTransformer.isStartedFromZero = true;\n/** @internal */\n\nvar getBarPointTransformer = function (_a) {\n  var argumentScale = _a.argumentScale,\n      valueScale = _a.valueScale;\n  var startVal = valueScale(0);\n  return function (point) {\n    return __assign(__assign({}, point), {\n      arg: argumentScale(point.argument),\n      val: valueScale(point.value),\n      startVal: startVal,\n      maxBarWidth: getWidth(argumentScale)\n    });\n  };\n}; // Used for domain calculation and stacking.\n\n\ngetBarPointTransformer.isStartedFromZero = true; // Used for Bar grouping.\n\ngetBarPointTransformer.isBroad = true;\n\ngetPiePointTransformer.getPointColor = function (palette, index) {\n  return palette[index % palette.length];\n};\n/** @internal */\n\n\nvar findSeriesByName = function (name, series) {\n  return series.find(function (seriesItem) {\n    return seriesItem.symbolName === name;\n  });\n};\n/** @internal */\n\n\nvar dSymbol = function (_a) {\n  var size = _a.size;\n  return symbol().size(Math.pow(size, 2)).type(symbolCircle)();\n};\n/** @internal */\n\n\nvar dPie = function (maxRadius, innerRadius, outerRadius, startAngle, endAngle) {\n  return arc()({\n    startAngle: startAngle,\n    endAngle: endAngle,\n    innerRadius: innerRadius * maxRadius,\n    outerRadius: outerRadius * maxRadius\n  });\n};\n\nvar getRect = function (cArg, cVal, dArg, dVal, rotated) {\n  var minArg = cArg - dArg;\n  var minVal = cVal - dVal;\n  var maxArg = cArg + dArg;\n  var maxVal = cVal + dVal;\n  return rotated ? [minVal, minArg, maxVal, maxArg] : [minArg, minVal, maxArg, maxVal];\n};\n\ngetBarPointTransformer.getTargetElement = function (point) {\n  var _a = point,\n      arg = _a.arg,\n      val = _a.val,\n      startVal = _a.startVal,\n      barWidth = _a.barWidth,\n      maxBarWidth = _a.maxBarWidth,\n      rotated = _a.rotated;\n  var halfWidth = barWidth * maxBarWidth / 2;\n  var halfHeight = Math.abs(startVal - val) / 2;\n  var centerVal = (val + startVal) / 2;\n  return getRect(arg, centerVal, halfWidth, halfHeight, rotated);\n};\n\ngetPiePointTransformer.getTargetElement = function (point) {\n  var _a = point,\n      x = _a.arg,\n      y = _a.val,\n      innerRadius = _a.innerRadius,\n      outerRadius = _a.outerRadius,\n      maxRadius = _a.maxRadius,\n      startAngle = _a.startAngle,\n      endAngle = _a.endAngle;\n  var center = arc().centroid({\n    startAngle: startAngle,\n    endAngle: endAngle,\n    innerRadius: innerRadius * maxRadius,\n    outerRadius: outerRadius * maxRadius\n  });\n  var cx = center[0] + x;\n  var cy = center[1] + y;\n  return getRect(cx, cy, 0.5, 0.5, false);\n};\n\ngetAreaPointTransformer.getTargetElement = function (_a) {\n  var arg = _a.arg,\n      val = _a.val,\n      rotated = _a.rotated;\n  return getRect(arg, val, 1, 1, rotated);\n};\n\ngetLinePointTransformer.getTargetElement = getAreaPointTransformer.getTargetElement;\n\ngetScatterPointTransformer.getTargetElement = function (obj) {\n  var _a = obj,\n      arg = _a.arg,\n      val = _a.val,\n      point = _a.point,\n      rotated = _a.rotated;\n  var t = point.size / 2;\n  return getRect(arg, val, t, t, rotated);\n};\n\nvar getUniqueName = function (list, name) {\n  var names = new Set(list.map(function (item) {\n    return item.name;\n  }));\n  var ret = name;\n\n  while (names.has(ret)) {\n    // @ts-ignore\n    ret = ret.replace(/\\d*$/, function (str) {\n      return str ? +str + 1 : 0;\n    });\n  }\n\n  return ret;\n}; // TODO: Memoization is much needed here.\n// Though \"series\" list never persists, single \"series\" item most often does.\n\n\nvar createPoints = function (_a, data, props, palette) {\n  var argumentField = _a.argumentField,\n      valueField = _a.valueField,\n      getPointTransformer = _a.getPointTransformer;\n  var points = [];\n  data.forEach(function (dataItem, index) {\n    var argument = dataItem[argumentField];\n    var value = dataItem[valueField];\n\n    if (argument !== undefined && value !== undefined) {\n      points.push(__assign(__assign({\n        argument: argument,\n        value: value,\n        index: index\n      }, props), {\n        color: getPointTransformer.getPointColor ? getPointTransformer.getPointColor(palette, index) : props.color\n      }));\n    }\n  });\n  return points;\n};\n/** @internal */\n\n\nvar addSeries = function (series, data, palette, props, restProps) {\n  // It is used to generate unique series dependent attribute names for patterns.\n  // *symbolName* cannot be used as it cannot be part of DOM attribute name.\n  var index = series.length;\n  var seriesColor = props.color || palette[index % palette.length];\n  return __spread(series, [__assign(__assign({}, props), {\n    index: index,\n    name: getUniqueName(series, props.name),\n    points: createPoints(props, data, __assign(__assign({}, restProps), {\n      color: seriesColor\n    }), palette),\n    color: seriesColor\n  })]);\n}; // TODO: Memoization is much needed here by the same reason as in \"createPoints\".\n// Make \"scales\" persistent first.\n\n\nvar scalePoints = function (series, scales, rotated) {\n  var transform = series.getPointTransformer(__assign(__assign({}, series), {\n    argumentScale: scales[ARGUMENT_DOMAIN],\n    valueScale: scales[getValueDomainName(series.scaleName)]\n  }));\n\n  var ret = __assign(__assign({}, series), {\n    rotated: rotated,\n    points: series.points.map(function (point) {\n      return __assign(__assign({}, transform(point)), {\n        rotated: rotated\n      });\n    })\n  });\n\n  return ret;\n};\n/** @internal */\n\n\nvar scaleSeriesPoints = function (series, scales, rotated) {\n  return series.map(function (seriesItem) {\n    return scalePoints(seriesItem, scales, rotated);\n  });\n};\n/** @internal */\n\n\nvar getVisibility = function (pane, centerX, centerY, width, height) {\n  return centerX - width / 2 < 0 && centerX + width / 2 < 0 || centerX - width / 2 > pane.width && centerX + width / 2 > pane.width || centerY - height / 2 < 0 && centerY + height / 2 < 0 || centerY - height / 2 > pane.height && centerY + height / 2 > pane.height ? 'hidden' : 'visible';\n};\n/** @internal */\n\n\nvar adjustBarSize = function (bar, _a) {\n  var width = _a.width,\n      height = _a.height;\n  var x = Math.max(0, bar.x);\n  var y = Math.max(0, bar.y);\n  return {\n    x: x,\n    y: y,\n    width: Math.min(width, bar.x + bar.width) - x,\n    height: Math.min(height, bar.y + bar.height) - y\n  };\n};\n/** @internal */\n\n\nvar isValuesChanged = function (previous, current) {\n  return Object.entries(previous).some(function (el) {\n    return el[1] !== current[el[0]];\n  });\n};\n/** @internal */\n\n\nvar isCoordinatesChanged = function (_a, _b) {\n  var prevCoordinates = _a.coordinates;\n  var coordinates = _b.coordinates;\n\n  if (prevCoordinates.length !== coordinates.length) {\n    return true;\n  }\n\n  return prevCoordinates.some(function (el, index) {\n    return el.arg !== coordinates[index].arg || el.val !== coordinates[index].val;\n  });\n};\n/** @internal */\n\n\nvar isScalesChanged = function (previous, current) {\n  return !rangesEqual(previous.argScale.range(), current.argScale.range()) || !rangesEqual(previous.valScale.range(), current.valScale.range());\n}; // \"Stack\" plugin relies on \"data\" and \"series\" getters and\n// knowledge about \"getPointTransformer\" and \"path\" functions behavior.\n\n\nvar buildSeriesToStackMap = function (stacks) {\n  var result = {};\n  stacks.forEach(function (_a, i) {\n    var series = _a.series;\n    series.forEach(function (name) {\n      result[name] = i;\n    });\n  });\n  return result;\n};\n\nvar getStackedPointTransformer = function (getPointTransformer) {\n  var wrapper = function (series) {\n    var transform = getPointTransformer(series);\n    var valueScale = series.valueScale;\n    return function (point) {\n      var ret = transform(point);\n      return __assign(__assign({}, ret), {\n        startVal: valueScale(point.value0)\n      });\n    };\n  }; // Preserve static fields of original transformer.\n\n\n  Object.assign(wrapper, getPointTransformer);\n  return wrapper;\n};\n\nvar collectStacks = function (seriesList, seriesToStackMap, stacksKeys, seriesPositions) {\n  seriesList.forEach(function (_a) {\n    var name = _a.name,\n        valueField = _a.valueField;\n    var stackId = seriesToStackMap[name];\n\n    if (stackId === undefined) {\n      return;\n    }\n\n    if (!stacksKeys[stackId]) {\n      stacksKeys[stackId] = [];\n    }\n\n    seriesPositions[name] = stacksKeys[stackId].length;\n    stacksKeys[stackId].push(valueField);\n  }); // Stack cannot consist of single series.\n\n  Object.keys(stacksKeys).forEach(function (stackId) {\n    if (stacksKeys[stackId].length === 1) {\n      delete stacksKeys[stackId];\n    }\n  });\n};\n\nvar getStackedData = function (stacksKeys, dataItems, offset, order) {\n  var result = {};\n  Object.keys(stacksKeys).forEach(function (stackId) {\n    result[stackId] = stack().keys(stacksKeys[stackId]).order(order).offset(offset)(dataItems);\n  });\n  return result;\n};\n\nvar buildStackedSeries = function (series, dataItems) {\n  var points = series.points.map(function (point) {\n    var _a = __read(dataItems[point.index], 2),\n        value0 = _a[0],\n        value = _a[1];\n\n    return __assign(__assign({}, point), {\n      value: value,\n      value0: value0\n    });\n  });\n\n  var stackedSeries = __assign(__assign({}, series), {\n    points: points,\n    isStacked: true\n  });\n\n  if (series.getPointTransformer.isStartedFromZero) {\n    stackedSeries.getPointTransformer = getStackedPointTransformer(series.getPointTransformer);\n  }\n\n  return stackedSeries;\n};\n\nvar applyStacking = function (seriesList, dataItems, seriesToStackMap, offset, order) {\n  var stacksKeys = {};\n  var seriesPositions = {};\n  collectStacks(seriesList, seriesToStackMap, stacksKeys, seriesPositions);\n\n  if (Object.keys(stacksKeys).length === 0) {\n    return seriesList;\n  }\n\n  var stackedData = getStackedData(stacksKeys, dataItems, offset, order);\n  return seriesList.map(function (seriesItem) {\n    var stackId = seriesToStackMap[seriesItem.name];\n    var stackData = stackedData[stackId];\n\n    if (!stackData) {\n      return seriesItem;\n    }\n\n    var position = seriesPositions[seriesItem.name];\n    return buildStackedSeries(seriesItem, stackData[position]);\n  });\n};\n\nvar getGroupName = function (series, i, seriesToStackMap) {\n  var stackId = seriesToStackMap[series.name];\n  return stackId >= 0 ? String(stackId) : \"group-\" + i;\n};\n\nvar getGroupedPointTransformer = function (getPointTransformer, groupCount, groupOffset) {\n  var wrapper = function (series) {\n    var transform = getPointTransformer(series);\n    var widthCoeff = 1 / groupCount;\n    return function (point) {\n      var original = transform(point);\n      var arg = original.arg - original.maxBarWidth * (0.5 - 0.5 * widthCoeff - groupOffset * widthCoeff);\n\n      var result = __assign(__assign({}, original), {\n        arg: arg,\n        maxBarWidth: original.maxBarWidth / groupCount\n      });\n\n      return result;\n    };\n  }; // Preserve static fields of original transformer.\n\n\n  Object.assign(wrapper, getPointTransformer);\n  return wrapper;\n};\n\nvar applyGrouping = function (seriesList, seriesToStackMap) {\n  var groups = new Set();\n  seriesList.forEach(function (seriesItem, i) {\n    if (seriesItem.getPointTransformer.isBroad) {\n      groups.add(getGroupName(seriesItem, i, seriesToStackMap));\n    }\n  }); // There cannot be single group.\n\n  if (groups.size < 2) {\n    return seriesList;\n  }\n\n  var scale = scaleBand$1().domain(Array.from(groups)).range([0, groups.size]);\n  return seriesList.map(function (seriesItem, i) {\n    if (!seriesItem.getPointTransformer.isBroad) {\n      return seriesItem;\n    }\n\n    var getPointTransformer = getGroupedPointTransformer(seriesItem.getPointTransformer, groups.size, scale(getGroupName(seriesItem, i, seriesToStackMap)));\n    return __assign(__assign({}, seriesItem), {\n      getPointTransformer: getPointTransformer\n    });\n  });\n};\n/** @internal */\n\n\nvar getStackedSeries = function (seriesList, dataItems, _a) {\n  var stacks = _a.stacks,\n      offset = _a.offset,\n      order = _a.order;\n  var map = buildSeriesToStackMap(stacks);\n  var stackedSeriesList = applyStacking(seriesList, dataItems, map, offset, order);\n  var groupedSeriesList = applyGrouping(stackedSeriesList, map);\n  return groupedSeriesList;\n};\n\nvar resetDomainItems = function (domains) {\n  var result = {};\n  Object.keys(domains).forEach(function (key) {\n    result[key] = __assign(__assign({}, domains[key]), {\n      domain: []\n    });\n  });\n  return result;\n};\n\nvar extendDomainsWithAdditionalItems = function (domains, series) {\n  var _a;\n\n  var items = series.points.map(function (point) {\n    return point.value0;\n  });\n  var key = getValueDomainName(series.scaleName);\n  var domain = updateDomainItems(domains[key], items);\n  return domain !== domains[key] ? __assign(__assign({}, domains), (_a = {}, _a[key] = domain, _a)) : domains;\n}; // Stacking changes data - so computed domains have to be discarded\n// and recalculated from the new stacked data.\n\n/** @internal */\n\n\nvar getStackedDomains = function (domains, seriesList) {\n  var stackedSeries = seriesList.filter(function (series) {\n    return series.isStacked;\n  });\n\n  if (!stackedSeries.length) {\n    return domains;\n  } // Recalculate domains in a common way.\n\n\n  var rebuiltDomains = seriesList.reduce(extendDomains, resetDomainItems(domains)); // Take additional \"value0\" fields into account.\n\n  return stackedSeries.reduce(extendDomainsWithAdditionalItems, rebuiltDomains);\n};\n/** @internal */\n\n\nvar easeOutCubic = function (t) {\n  return (t - 1) * (t - 1) * (t - 1) + 1;\n};\n/** @internal */\n\n\nvar getDelay = function (index, isStart) {\n  return isStart ? index * 30 : 0;\n};\n/** @internal */\n\n\nvar getStartVal$1 = function (scales) {\n  return scales.valScale.copy().clamp(true)(0);\n};\n/** @internal */\n\n\nvar getPathStart = function (scales, _a) {\n  var coordinates = _a.coordinates;\n  var start = getStartVal$1(scales);\n  return {\n    coordinates: coordinates.map(function (coord) {\n      return {\n        arg: coord.arg,\n        val: start,\n        startVal: start\n      };\n    })\n  };\n};\n/** @internal */\n\n\nvar getPointStart = function (scales, _a) {\n  var arg = _a.arg;\n  var start = getStartVal$1(scales);\n  return {\n    arg: arg,\n    val: start,\n    startVal: start\n  };\n};\n/** @internal */\n\n\nvar getPieStart = function (scales, _a) {\n  var startAngle = _a.startAngle,\n      endAngle = _a.endAngle;\n  return {\n    innerRadius: 0,\n    outerRadius: 0,\n    startAngle: startAngle,\n    endAngle: endAngle\n  };\n}; // Comparing by reference is not an option as Tracker always sends new objects.\n// Tracker cannot persist references as it actually operates with simple scalars\n// and constructs objects to provide info in a slightly more suitable way.\n\n\nvar compareTargets = function (target1, target2) {\n  return target1.series === target2.series && target1.point === target2.point;\n}; // If *currentTarget* is among *targets* then it has priority but only while its distance\n// is not significantly greater (DISTANCE_PRIORITY_RATIO) than that of the best candidate.\n\n\nvar selectTarget = function (targets, currentTarget) {\n  var candidate = targets[0];\n\n  if (!currentTarget) {\n    return candidate;\n  }\n\n  if (!candidate) {\n    return null;\n  }\n\n  return compareTargets(candidate, currentTarget) ? undefined : candidate;\n};\n/** @internal */\n\n\nvar processPointerMove = function (targets, currentTarget, notify) {\n  var nextTarget = selectTarget(targets, currentTarget);\n\n  if (nextTarget === undefined) {\n    return undefined;\n  }\n\n  if (notify) {\n    notify(nextTarget);\n  }\n\n  return nextTarget;\n}; // This function is to be called from context where DOM is available -\n// so *window* can be accessed safely.\n\n/** @internal */\n\n\nvar getOffset = function (element) {\n  var _a = element.getBoundingClientRect(),\n      left = _a.left,\n      top = _a.top; // Safer way to get window.\n\n\n  var defaultView = element.ownerDocument.defaultView;\n  var _b = defaultView,\n      pageXOffset = _b.pageXOffset,\n      pageYOffset = _b.pageYOffset;\n  return [left + pageXOffset, top + pageYOffset];\n};\n/** @internal */\n\n\nvar getEventCoords = function (e, offset) {\n  var _a = e.touches ? e.touches[0] : e,\n      pageX = _a.pageX,\n      pageY = _a.pageY;\n\n  return [pageX - offset[0], pageY - offset[1]];\n};\n/** @internal */\n\n\nvar getParameters = function (series, target) {\n  var currentSeries = series.find(function (_a) {\n    var name = _a.name;\n    return target.series === name;\n  });\n  var item = currentSeries.points.find(function (point) {\n    return point.index === target.point;\n  });\n  return {\n    element: currentSeries.getPointTransformer.getTargetElement(item),\n    text: \"\" + item.value\n  };\n};\n/** @internal */\n\n\nvar createReference = function (rect, rootRef) {\n  return {\n    // These two fields together with *width* and *height* are left with stub data for\n    // simplicity reasons - they seem to be unused by *Popper*.\n    clientWidth: 0,\n    clientHeight: 0,\n    getBoundingClientRect: function () {\n      // This function is expected to be called (by the *Popper*) when DOM is ready -\n      // so *rootRef.current* can be accessed.\n      var offset = getOffset(rootRef.current); // *getBoundingClientRect* of a real html element is affected by window scrolling.\n      // *popper.js* subscribes \"html -> getBoundingClientRect -> (left, top)\" from\n      // \"reference -> getBoundingClientRect\" - so here it is added.\n\n      var htmlRect = rootRef.current.ownerDocument.documentElement.getBoundingClientRect();\n      return {\n        left: rect[0] + offset[0] + htmlRect.left,\n        top: rect[1] + offset[1] + htmlRect.top,\n        right: rect[2] + offset[0] + htmlRect.left,\n        bottom: rect[3] + offset[1] + htmlRect.top,\n        width: 0,\n        height: 0\n      };\n    }\n  };\n};\n/** @internal */\n\n\nvar processHandleTooltip = function (targets, currentTarget, onTargetItemChange) {\n  var filterTargets = targets.filter(function (target) {\n    return target.point !== undefined;\n  });\n  return processPointerMove(filterTargets, currentTarget, onTargetItemChange);\n};\n\nvar getArgumentBounds = function (viewport) {\n  return viewport && viewport.argumentStart !== undefined && viewport.argumentEnd !== undefined ? [viewport.argumentStart, viewport.argumentEnd] : null;\n};\n\nvar getValueBounds = function (viewport) {\n  return viewport && viewport.valueStart !== undefined && viewport.valueEnd !== undefined ? [viewport.valueStart, viewport.valueEnd] : null;\n};\n\nvar getValueScaleName = function (viewport) {\n  return getValueDomainName(viewport && viewport.scaleName);\n};\n\nvar getDefaultBounds = function (scale) {\n  var domain = scale.domain();\n  return [domain[0], domain[domain.length - 1]];\n};\n\nvar proportionallyExtendRange = function (range, subRange) {\n  var p = (subRange[0] - subRange[1]) / (range[0] - range[1]);\n  var q = subRange[0] - p * range[0];\n  return [(range[0] - q) / p, (range[1] - q) / p];\n};\n\nvar adjustRange = function (domain, bounds, range) {\n  var scale = makeScale(domain, range);\n  var subRange = scaleBounds(scale, bounds);\n  return rangesEqual(subRange, range) ? range : proportionallyExtendRange(range, subRange);\n};\n\nvar update = function (ranges, changes, key, domain, bounds) {\n  var newRange = adjustRange(domain, bounds, ranges[key]);\n\n  if (newRange !== ranges[key]) {\n    changes[key] = newRange;\n  }\n};\n/** @internal */\n\n\nvar adjustLayout = function (domains, ranges, viewport) {\n  var changes = {};\n  var argumentBounds = getArgumentBounds(viewport);\n\n  if (argumentBounds) {\n    update(ranges, changes, ARGUMENT_DOMAIN, domains[ARGUMENT_DOMAIN], argumentBounds);\n  }\n\n  var valueBounds = getValueBounds(viewport);\n\n  if (valueBounds) {\n    update(ranges, changes, VALUE_DOMAIN, domains[getValueScaleName(viewport)], valueBounds);\n  }\n\n  return Object.keys(changes).length ? __assign(__assign({}, ranges), changes) : ranges;\n};\n\nvar boundsForScale = function (name, scales, currentBounds, interaction, type, delta, anchor, range) {\n  if (!checkInteraction(interaction, type)) {\n    return null;\n  }\n\n  var scale = scales[name];\n  var bounds = currentBounds || getDefaultBounds(scale);\n  var newBounds;\n\n  if (type === 'pan') {\n    newBounds = moveBounds(scale, bounds, delta);\n  } else if (type === 'zoom') {\n    newBounds = range ? invertBoundsRange(scale, range) : growBounds(scale, bounds, delta, anchor);\n  }\n\n  return newBounds !== bounds ? newBounds : null;\n};\n/** @internal */\n\n\nvar getViewport = function (scales, rotated, _a, type, deltas, anchors, ranges, viewport, onViewportChange) {\n  var _b = __read(_a, 2),\n      argInteraction = _b[0],\n      valInteraction = _b[1];\n\n  var argIndex = Number(rotated);\n  var valIndex = 1 - argIndex;\n  var changes = {};\n  var argumentBounds = boundsForScale(ARGUMENT_DOMAIN, scales, getArgumentBounds(viewport), argInteraction, type, deltas ? deltas[argIndex] : 0, anchors ? anchors[argIndex] : 0, ranges ? ranges[argIndex] : undefined);\n  var valueBounds = boundsForScale(getValueScaleName(viewport), scales, getValueBounds(viewport), valInteraction, type, deltas ? deltas[valIndex] : 0, anchors ? anchors[valIndex] : 0, ranges ? ranges[valIndex] : undefined);\n\n  if (argumentBounds) {\n    changes.argumentStart = argumentBounds[0];\n    changes.argumentEnd = argumentBounds[1];\n  }\n\n  if (valueBounds) {\n    changes.valueStart = valueBounds[0];\n    changes.valueEnd = valueBounds[1];\n  }\n\n  if (Object.keys(changes).length) {\n    var newViewport = __assign(__assign({}, viewport), changes);\n\n    if (onViewportChange) {\n      onViewportChange(newViewport);\n    }\n\n    return {\n      viewport: newViewport\n    };\n  }\n\n  return null;\n};\n/** @internal */\n\n\nvar getDeltaForTouches = function (touches) {\n  var deltaX = touches[0].pageX - touches[1].pageX;\n  var deltaY = touches[0].pageY - touches[1].pageY;\n  var delta = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n  var center = [(touches[0].pageX + touches[1].pageX) / 2, (touches[0].pageY + touches[1].pageY) / 2];\n  return {\n    delta: delta,\n    center: center\n  };\n};\n/** @internal */\n\n\nvar isKeyPressed = function (event, key) {\n  return event[key + \"Key\"];\n};\n/** @internal */\n\n\nvar getWheelDelta = function (_a) {\n  var wheelDelta = _a.wheelDelta,\n      deltaY = _a.deltaY;\n  return wheelDelta !== undefined ? wheelDelta : deltaY * -30; // deltaY for FF\n};\n/** @internal */\n\n\nvar isMultiTouch = function (e) {\n  return e.touches && e.touches.length === 2;\n};\n/** @internal */\n\n\nvar attachEvents = function (node, handlers) {\n  Object.keys(handlers).forEach(function (el) {\n    node.addEventListener(el, handlers[el], {\n      passive: false\n    });\n  });\n};\n/** @internal */\n\n\nvar detachEvents = function (node, handlers) {\n  Object.keys(handlers).forEach(function (el) {\n    node.removeEventListener(el, handlers[el]);\n  });\n};\n/** @internal */\n\n\nvar getRect$1 = function (rotated, interactionWithArguments, interactionWithValues, initial, current, pane) {\n  var isZoomArgument = checkInteraction(interactionWithArguments, 'zoom');\n  var isZoomValue = checkInteraction(interactionWithValues, 'zoom');\n  var isXFixed = rotated ? isZoomValue : isZoomArgument;\n  var isYFixed = rotated ? isZoomArgument : isZoomValue;\n  var x = isXFixed ? Math.min(initial[0], current[0]) : 0;\n  var width = isXFixed ? Math.abs(initial[0] - current[0]) : pane.width;\n  var y = isYFixed ? Math.min(initial[1], current[1]) : 0;\n  var height = isYFixed ? Math.abs(initial[1] - current[1]) : pane.height;\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height\n  };\n};\n\nvar checkInteraction = function (interaction, type) {\n  return interaction === 'both' || interaction === type;\n};\n/** @internal */\n\n\nvar setCursorType = function (node, type) {\n  var defaultType = 'pointer';\n  node.style.cursor = type ? type : defaultType;\n};\n/** @internal */\n\n\nvar isReadyToRenderSeries = function (_a, _b, isPreviousDataEmpty, axesExist) {\n  var current = _b.current;\n\n  var pane = _a.pane,\n      restLayouts = __rest(_a, [\"pane\"]);\n\n  if (!pane.width && !pane.height) {\n    return false;\n  }\n\n  var bbox = current.getBoundingClientRect();\n  var width = pane.width;\n  var height = pane.height;\n  Object.entries(restLayouts).forEach(function (el) {\n    if (el[0].includes('top') || el[0].includes('bottom')) {\n      height += el[1].height;\n    } else {\n      width += el[1].width;\n    }\n  });\n  return Math.abs(bbox.width - width) < DIFFERENCE && Math.abs(bbox.height - height) < DIFFERENCE && isPreviousDataEmptyOrNoAxes(isPreviousDataEmpty, axesExist);\n};\n\nvar isPreviousDataEmptyOrNoAxes = function (isPreviousDataEmpty, axesExist) {\n  return !isPreviousDataEmpty || !axesExist;\n};\n\nvar getSegmentLength = function (dx, dy) {\n  return Math.sqrt(dx * dx + dy * dy);\n}; // *distance* is a normalized distance to point.\n// It belongs to [0, Infinity):\n//  = 0 - at point center\n//  = 1 - at point border\n//  > 1 - outside point\n// This function is called from event handlers (when DOM is available) -\n// *window.document* can be accessed safely.\n\n\nvar createContext = function () {\n  return document.createElement('canvas').getContext('2d');\n}; // For a start using browser canvas will suffice.\n// However a better and more clean solution should be found.\n// Can't d3 perform hit testing?\n\n\nvar createCanvasAbusingHitTester = function (makePath, points, rotated) {\n  var ctx = createContext();\n  var path = makePath(rotated);\n  path.context(ctx);\n  path(points);\n  return function (_a) {\n    var _b = __read(_a, 2),\n        x = _b[0],\n        y = _b[1];\n\n    return ctx.isPointInPath(x, y);\n  };\n};\n\nvar LINE_POINT_SIZE = 20;\nvar LINE_TOLERANCE = 10;\n\nvar getDistance = function (_a, _b, rotated) {\n  var _c = __read(_a, 2),\n      px = _c[0],\n      py = _c[1];\n\n  var arg = _b.arg,\n      val = _b.val;\n  var x = rotated ? val : arg;\n  var y = rotated ? arg : val;\n  return getSegmentLength(px - x, py - y);\n};\n\nvar createContinuousSeriesHitTesterCreator = function (makePath) {\n  return function (points, rotated) {\n    var fallbackHitTest = createCanvasAbusingHitTester(makePath, points, rotated);\n    return function (target) {\n      var minDistance = Number.MAX_VALUE;\n      var minIndex = 0;\n      var list = [];\n      points.forEach(function (point, i) {\n        var distance = getDistance(target, point, rotated);\n\n        if (distance <= LINE_POINT_SIZE) {\n          list.push({\n            distance: distance,\n            index: point.index\n          });\n        }\n\n        if (distance < minDistance) {\n          minDistance = distance;\n          minIndex = i;\n        }\n      }); // This is special case for continuous series - if no point is actually hit\n      // then the closest point to the pointer position is picked.\n\n      if (!list.length && fallbackHitTest(target)) {\n        list.push({\n          index: points[minIndex].index,\n          distance: minDistance\n        });\n      }\n\n      return list.length ? {\n        points: list\n      } : null;\n    };\n  };\n};\n\nvar createPointsEnumeratingHitTesterCreator = function (hitTestPoint) {\n  return function (points, rotated) {\n    return function (target) {\n      var list = [];\n      points.forEach(function (point) {\n        var status = hitTestPoint(target, point, rotated);\n\n        if (status) {\n          list.push({\n            index: point.index,\n            distance: status.distance\n          });\n        }\n      });\n      return list.length ? {\n        points: list\n      } : null;\n    };\n  };\n};\n/** @internal */\n\n\nvar createAreaHitTester = createContinuousSeriesHitTesterCreator(function (rotated) {\n  var path = area();\n  var hitArea = rotated ? dRotateArea : dArea;\n\n  if (rotated) {\n    path.x1(hitArea.x1());\n    path.x0(hitArea.x0());\n    path.y(hitArea.y());\n  } else {\n    path.x(hitArea.x());\n    path.y1(hitArea.y1());\n    path.y0(hitArea.y0());\n  }\n\n  return path;\n});\n/** @internal */\n\nvar createLineHitTester = createContinuousSeriesHitTesterCreator(function (rotated) {\n  var path = area();\n  var hitLine = rotated ? dRotateLine : dLine;\n\n  if (rotated) {\n    var getX_1 = hitLine.x();\n    path.y(hitLine.y());\n    path.x0(function (point) {\n      return getX_1(point) + LINE_TOLERANCE;\n    });\n    path.x1(function (point) {\n      return getX_1(point) - LINE_TOLERANCE;\n    });\n  } else {\n    var getY_1 = hitLine.y();\n    path.x(hitLine.x());\n    path.y1(function (point) {\n      return getY_1(point) - LINE_TOLERANCE;\n    });\n    path.y0(function (point) {\n      return getY_1(point) + LINE_TOLERANCE;\n    });\n  }\n\n  return path;\n});\n/** @internal */\n\nvar createSplineHitTester = createContinuousSeriesHitTesterCreator(function (rotated) {\n  var path = area();\n  var hitSpline = rotated ? dRotateSpline : dSpline;\n\n  if (rotated) {\n    var getX_2 = hitSpline.x();\n    path.y(hitSpline.y());\n    path.x1(function (point) {\n      return getX_2(point) - LINE_TOLERANCE;\n    });\n    path.x0(function (point) {\n      return getX_2(point) + LINE_TOLERANCE;\n    });\n  } else {\n    var getY_2 = hitSpline.y();\n    path.x(hitSpline.x());\n    path.y1(function (point) {\n      return getY_2(point) - LINE_TOLERANCE;\n    });\n    path.y0(function (point) {\n      return getY_2(point) + LINE_TOLERANCE;\n    });\n  }\n\n  path.curve(hitSpline.curve());\n  return path;\n});\n\nvar hitTestRect = function (dx, dy, halfX, halfY) {\n  return Math.abs(dx) <= halfX && Math.abs(dy) <= halfY ? {\n    distance: getSegmentLength(dx, dy)\n  } : null;\n}; // Some kind of binary search can be used here as bars can be ordered along argument axis.\n\n/** @internal */\n\n\nvar createBarHitTester = createPointsEnumeratingHitTesterCreator(function (_a, point, rotated) {\n  var _b = __read(_a, 2),\n      px = _b[0],\n      py = _b[1];\n\n  var _c = point,\n      arg = _c.arg,\n      val = _c.val,\n      startVal = _c.startVal,\n      barWidth = _c.barWidth,\n      maxBarWidth = _c.maxBarWidth;\n  var halfWidth = maxBarWidth * barWidth / 2;\n  var halfHeight = Math.abs(val - startVal) / 2;\n  var centerVal = (val + startVal) / 2;\n  var xCenter = rotated ? centerVal : arg;\n  var yCenter = rotated ? arg : centerVal;\n  return hitTestRect(px - xCenter, py - yCenter, rotated ? halfHeight : halfWidth, rotated ? halfWidth : halfHeight);\n});\n/** @internal */\n\nvar createScatterHitTester = createPointsEnumeratingHitTesterCreator(function (_a, obj, rotated) {\n  var _b = __read(_a, 2),\n      px = _b[0],\n      py = _b[1];\n\n  var point = obj.point;\n  var distance = getDistance([px, py], obj, rotated);\n  return distance <= point.size / 2 ? {\n    distance: distance\n  } : null;\n});\n\nvar mapAngleTod3 = function (angle) {\n  var ret = angle + Math.PI / 2;\n  return ret >= 0 ? ret : ret + Math.PI * 2;\n}; // Some kind of binary search can be used here as pies can be ordered along angle axis.\n\n/** @internal */\n\n\nvar createPieHitTester = createPointsEnumeratingHitTesterCreator(function (_a, point) {\n  var _b = __read(_a, 2),\n      px = _b[0],\n      py = _b[1];\n\n  var _c = point,\n      x = _c.arg,\n      y = _c.val,\n      innerRadius = _c.innerRadius,\n      outerRadius = _c.outerRadius,\n      startAngle = _c.startAngle,\n      maxRadius = _c.maxRadius,\n      endAngle = _c.endAngle;\n  var inner = innerRadius * maxRadius;\n  var outer = outerRadius * maxRadius;\n  var rCenter = (inner + outer) / 2;\n  var angleCenter = (startAngle + endAngle) / 2;\n  var halfRadius = (outer - inner) / 2;\n  var halfAngle = Math.abs(startAngle - endAngle) / 2;\n  var dx = px - x;\n  var dy = py - y;\n  var r = getSegmentLength(dx, dy);\n  var angle = mapAngleTod3(Math.atan2(dy, dx)); // This is not a correct distance calculation but for now it will suffice.\n  // For Pie series it would not be actually used.\n\n  return hitTestRect(r - rCenter, angle - angleCenter, halfRadius, halfAngle);\n});\n\nvar buildFilter = function (targets) {\n  var result = {};\n  targets.forEach(function (_a) {\n    var series = _a.series,\n        point = _a.point;\n    (result[series] = result[series] || new Set()).add(point);\n  });\n  return result;\n};\n/** @internal */\n\n\nvar changeSeriesState = function (seriesList, targets, state) {\n  if (targets.length === 0) {\n    return seriesList;\n  }\n\n  var filter = buildFilter(targets);\n  var matches = 0;\n  var result = seriesList.map(function (seriesItem) {\n    var set = filter[seriesItem.name];\n\n    if (!set) {\n      return seriesItem;\n    }\n\n    matches += 1;\n    var props = {\n      state: state\n    };\n\n    if (set.size) {\n      props.points = seriesItem.points.map(function (point) {\n        return set.has(point.index) ? __assign(__assign({}, point), {\n          state: state\n        }) : point;\n      });\n    }\n\n    return __assign(__assign({}, seriesItem), props);\n  }); // This is to prevent false rerenders.\n\n  return matches > 0 ? result : seriesList;\n};\n\nvar getDefaultLegendItems = function (series) {\n  return series.map(function (_a) {\n    var text = _a.name,\n        color = _a.color;\n    return {\n      text: text,\n      color: color\n    };\n  });\n};\n\nvar getPieLegendItems = function (series) {\n  return series[0].points.map(function (_a) {\n    var text = _a.argument,\n        color = _a.color;\n    return {\n      text: text,\n      color: color\n    };\n  });\n}; // The function supports special case when there is single Pie series.\n// There is no common way to tell if series is PieSeries -\n// checking `radius` props will suffice for now.\n\n\nvar isSinglePieSeriesCase = function (series) {\n  return series.length === 1 && 'innerRadius' in series[0] && 'outerRadius' in series[0];\n};\n/** @internal */\n\n\nvar getLegendItems = function (series) {\n  return (isSinglePieSeriesCase(series) ? getPieLegendItems : getDefaultLegendItems)(series);\n};\n\nvar DISTANCE_THRESHOLD = 20;\n\nvar compareHitTargets = function (t1, t2) {\n  var distanceDelta = t1.distance - t2.distance;\n\n  if (Math.abs(distanceDelta) <= DISTANCE_THRESHOLD) {\n    var orderDelta = t2.order - t1.order;\n    return orderDelta !== 0 ? orderDelta : distanceDelta;\n  }\n\n  return distanceDelta;\n};\n\nvar buildEventHandler = function (seriesList, handlers) {\n  var hitTesters = null;\n\n  var createHitTesters = function () {\n    var obj = {};\n    seriesList.forEach(function (seriesItem) {\n      obj[seriesItem.symbolName] = seriesItem.createHitTester(seriesItem.points, seriesItem.rotated);\n    });\n    return obj;\n  };\n\n  return function (e) {\n    var location = getEventCoords(e, getOffset(e.currentTarget));\n    hitTesters = hitTesters || createHitTesters();\n    var targets = [];\n    seriesList.forEach(function (_a) {\n      var series = _a.name,\n          order = _a.index,\n          symbolName = _a.symbolName;\n      var status = hitTesters[symbolName](location);\n\n      if (status) {\n        targets.push.apply(targets, __spread(status.points.map(function (point) {\n          return {\n            series: series,\n            order: order,\n            point: point.index,\n            distance: point.distance\n          };\n        })));\n      }\n    });\n    targets.sort(compareHitTargets);\n    var arg = {\n      location: location,\n      targets: targets,\n      event: e.nativeEvent\n    };\n    handlers.forEach(function (handler) {\n      return handler(arg);\n    });\n  };\n};\n\nvar buildLeaveEventHandler = function (handlers) {\n  return function (e) {\n    var location = getEventCoords(e, getOffset(e.currentTarget));\n    var arg = {\n      location: location,\n      targets: []\n    };\n    handlers.forEach(function (handler) {\n      return handler(arg);\n    });\n  };\n}; // The result is of Map<string, Function> type.\n// Keys are DOM event names (https://developer.mozilla.org/en-US/docs/Web/Events).\n\n/** @internal */\n\n\nvar buildEventHandlers = function (seriesList, _a) {\n  var clickHandlers = _a.clickHandlers,\n      pointerMoveHandlers = _a.pointerMoveHandlers;\n  var handlers = {};\n  if (!hasWindow()) return handlers;\n\n  if (clickHandlers.length) {\n    handlers.click = buildEventHandler(seriesList, clickHandlers);\n  }\n\n  if (pointerMoveHandlers.length) {\n    var moveHandler = buildEventHandler(seriesList, pointerMoveHandlers);\n    var leaveHandler = buildLeaveEventHandler(pointerMoveHandlers);\n\n    if ('ontouchstart' in window) {\n      handlers.touchstart = moveHandler;\n    } else {\n      handlers.mousemove = moveHandler;\n      handlers.mouseleave = leaveHandler;\n    }\n  }\n\n  return handlers;\n};\n/** @internal */\n\n\nvar getProgress = function (_a) {\n  var elapsed = _a.elapsed,\n      total = _a.total;\n  return Math.min(elapsed / total, 1);\n};\n/** @internal */\n\n\nvar runAnimation = function (setAttributes, getNewPositions, easing, duration, delay) {\n  return new Promise(function (resolve) {\n    setTimeout(function () {\n      var time = {\n        start: Date.now(),\n        total: duration,\n        elapsed: 0\n      };\n\n      var step = function () {\n        time.elapsed = Date.now() - time.start;\n        var progress = getProgress(time);\n        setAttributes(getNewPositions(easing(progress)));\n        if (progress < 1) requestAnimationFrame(step);\n      };\n\n      resolve(requestAnimationFrame(step));\n    }, delay);\n  });\n};\n/** @internal */\n\n\nvar buildAnimation = function (easing, duration) {\n  return function (startCoords, endCoords, processAnimation, setAttributes, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    var animationID;\n\n    var stop = function () {\n      if (animationID) {\n        cancelAnimationFrame(animationID);\n        animationID = undefined;\n      }\n    };\n\n    var run = function (start, end, delayValue) {\n      animationID = runAnimation(setAttributes, processAnimation(start, end), easing, duration, delayValue).then(function (res) {\n        animationID = res;\n      });\n    };\n\n    run(startCoords, endCoords, delay);\n    return {\n      update: function (updatedStartCoords, updatedEndCoords, updatedDelay) {\n        if (updatedDelay === void 0) {\n          updatedDelay = 0;\n        }\n\n        stop();\n        run(updatedStartCoords, updatedEndCoords, updatedDelay);\n      },\n      stop: stop\n    };\n  };\n};\n\nvar lerp = function (a, b, t) {\n  return a + t * (b - a);\n};\n/** @internal */\n\n\nvar processPointAnimation = function (startCoords, endCoords) {\n  return function (progress) {\n    return {\n      arg: lerp(startCoords.arg, endCoords.arg, progress),\n      val: lerp(startCoords.val, endCoords.val, progress)\n    };\n  };\n};\n/** @internal */\n\n\nvar processBarAnimation = function (startCoords, endCoords) {\n  return function (progress) {\n    return {\n      arg: lerp(startCoords.arg, endCoords.arg, progress),\n      val: lerp(startCoords.val, endCoords.val, progress),\n      startVal: lerp(startCoords.startVal, endCoords.startVal, progress)\n    };\n  };\n};\n/** @internal */\n\n\nvar processLineAnimation = function (_a, _b) {\n  var coordinates = _a.coordinates;\n  var endCoordinates = _b.coordinates;\n  return function (progress) {\n    return {\n      coordinates: endCoordinates.map(function (coord, index) {\n        var startCurCoord = coordinates[index];\n        return __assign(__assign({}, coord), {\n          arg: lerp(startCurCoord.arg, coord.arg, progress),\n          val: lerp(startCurCoord.val, coord.val, progress)\n        });\n      })\n    };\n  };\n};\n/** @internal */\n\n\nvar processAreaAnimation = function (_a, _b) {\n  var coordinates = _a.coordinates;\n  var endCoordinates = _b.coordinates;\n  return function (progress) {\n    return {\n      coordinates: endCoordinates.map(function (coord, index) {\n        var startCurCoord = coordinates[index];\n        return __assign(__assign({}, coord), {\n          arg: lerp(startCurCoord.arg, coord.arg, progress),\n          val: lerp(startCurCoord.val, coord.val, progress),\n          startVal: lerp(startCurCoord.startVal, coord.startVal, progress)\n        });\n      })\n    };\n  };\n};\n/** @internal */\n\n\nvar processPieAnimation = function (start, end) {\n  return function (progress) {\n    return {\n      innerRadius: lerp(start.innerRadius, end.innerRadius, progress),\n      outerRadius: lerp(start.outerRadius, end.outerRadius, progress),\n      startAngle: lerp(start.startAngle, end.startAngle, progress),\n      endAngle: lerp(start.endAngle, end.endAngle, progress)\n    };\n  };\n};\n\nexport { ARGUMENT_DOMAIN, BAND, BOTTOM, DIFFERENCE, END, HORIZONTAL, HOVERED, LEFT, LINEAR, MIDDLE, RIGHT, SELECTED, START, TOP, VALUE_DOMAIN, VERTICAL, addDomain, addSeries, adjustBarSize, adjustLayout, attachEvents, bBoxes, buildAnimation, buildEventHandlers, buildScales, changeSeriesState, createAreaHitTester, createBarHitTester, createLineHitTester, createPieHitTester, createReference, createScatterHitTester, createSplineHitTester, dArea, dBar, dLine, dPie, dRotateArea, dRotateLine, dRotateSpline, dSpline, dSymbol, defaultDomains, detachEvents, easeOutCubic, extendDomains, findSeriesByName, getAreaPointTransformer, getBarPointTransformer, getDelay, getDeltaForTouches, getEventCoords, getLegendItems, getLinePointTransformer, getOffset, getParameters, getPathStart, getPiePointTransformer, getPieStart, getPointStart, getRanges, getRect$1 as getRect, getRotatedPosition, getScatterPointTransformer, getStackedDomains, getStackedSeries, getStartVal$1 as getStartVal, getTickCoordinates, getValueDomainName, getViewport, getVisibility, getWheelDelta, getWidth, gridCoordinatesGetter, growBounds, invertBoundsRange, isCoordinatesChanged, isHorizontal, isKeyPressed, isMultiTouch, isReadyToRenderSeries, isScalesChanged, isValidPosition, isValuesChanged, makeScale, moveBounds, processAreaAnimation, processBarAnimation, processHandleTooltip, processLineAnimation, processPieAnimation, processPointAnimation, processPointerMove, rangesEqual, scaleBand, scaleBounds, scaleLinear, scaleSeriesPoints, setCursorType, tickCoordinatesGetter, updateDomainItems };","map":{"version":3,"sources":["../src/constants.ts","../src/utils/scale.ts","../src/plugins/scale/computeds.ts","../src/plugins/layout-manager/computeds.ts","../src/plugins/axis/computeds.ts","../src/plugins/series/computeds.ts","../src/plugins/stack/computeds.ts","../src/plugins/animation/computeds.ts","../src/utils/hover-state.ts","../src/utils/common.ts","../src/plugins/tooltip/computeds.ts","../src/plugins/zoom-and-pan/computeds.ts","../src/plugins/controller-component/computeds.ts","../src/utils/series.ts","../src/utils/legend.ts","../src/utils/event-tracker.ts","../src/utils/animation.ts"],"names":["d3ScaleLinear","d3ScaleBand","_a","scaleBand","getStartVal","getRect"],"mappings":"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","sourcesContent":["/** @internal */\nexport const HORIZONTAL = 'horizontal';\n/** @internal */\nexport const VERTICAL = 'vertical';\n/** @internal */\nexport const TOP = 'top';\n/** @internal */\nexport const BOTTOM = 'bottom';\n/** @internal */\nexport const LEFT = 'left';\n/** @internal */\nexport const RIGHT = 'right';\n/** @internal */\nexport const MIDDLE = 'middle';\n/** @internal */\nexport const END = 'end';\n/** @internal */\nexport const START = 'start';\n/** @internal */\nexport const LINEAR = 'linear';\n/** @internal */\nexport const BAND = 'band';\n/** @internal */\nexport const ARGUMENT_DOMAIN = 'argument-domain';\n/** @internal */\nexport const VALUE_DOMAIN = 'value-domain';\n/** @internal */\nexport const HOVERED = 'hovered';\n/** @internal */\nexport const SELECTED = 'selected';\n/** @internal */\nexport const DIFFERENCE = 0.9;\n","import {\n  scaleLinear as d3ScaleLinear, scaleBand as d3ScaleBand,\n} from 'd3-scale';\nimport {\n  ARGUMENT_DOMAIN, VALUE_DOMAIN,\n} from '../constants';\nimport {\n  ScaleObject, FactoryFn, DomainInfo, NumberArray, DomainBounds, DomainItems,\n} from '../types';\n\n/** @internal */\nexport const scaleLinear: FactoryFn = d3ScaleLinear as any;\n\nexport const scaleBand: FactoryFn = () => (\n  d3ScaleBand().paddingInner(0.3).paddingOuter(0.15) as any\n);\n\n/** @internal */\nexport const isHorizontal = (name: string, rotated: boolean) => (\n  name === ARGUMENT_DOMAIN === !rotated\n);\n\n// tslint:disable-next-line: ban-types\nconst makeScaleHelper = <T extends Function>(linear: T, band: T) => {\n  const func: any = (scale: ScaleObject, ...args: any[]) => {\n    const choosen = 'bandwidth' in scale ? band : linear;\n    return choosen(scale, ...args);\n  };\n  return func as T;\n};\n\nconst getLinearScaleWidth = (_: ScaleObject) => 0;\n\nconst getBandScaleWidth = (scale: ScaleObject) => scale.bandwidth!();\n\n/** @internal */\nexport const getWidth = makeScaleHelper(getLinearScaleWidth, getBandScaleWidth);\n\n/** @internal */\nexport const getValueDomainName = (name?: string) => name || VALUE_DOMAIN;\n\nconst floatsEqual = (a: number, b: number) => Math.abs(a - b) < Number.EPSILON;\n\n/** @internal */\nexport const rangesEqual = (r1: Readonly<NumberArray>, r2: Readonly<NumberArray>) =>\n  floatsEqual(r1[0], r2[0]) && floatsEqual(r1[1], r2[1]);\n\nconst wrapLinearScale = (scale: ScaleObject) => scale;\n\nconst wrapBandScale = (scale: ScaleObject): ScaleObject => {\n  const ret: any = (value: any) => scale(value) + scale.bandwidth!() / 2;\n  Object.assign(ret, scale);\n  return ret;\n};\n\nconst wrapScale = makeScaleHelper(wrapLinearScale, wrapBandScale);\n\n/** @internal */\nexport const makeScale = ({ factory, domain }: DomainInfo, range: NumberArray) => {\n  const scale = (factory || scaleLinear)().domain(domain).range(range);\n  return wrapScale(scale);\n};\n\n// It is implicitly supposed that Chart can accept any d3 scale. It is wrong.\n// The followings notes show that. d3 scales are not seamlessly interchangeable themselves\n// (i.e. band scale has no \"invert\", continuous scale has no \"bandwidth\").\n// We have to use \"adapters\" to mitigate the differences.\n// Hence Chart can actually accept any object that matches \"adapter\" interface.\n// TODO: We should update reference accordingly. There might be breaking changes though.\n\nconst scaleLinearBounds = (scale: ScaleObject, bounds: DomainBounds): NumberArray => (\n  bounds.map(scale) as NumberArray\n);\n\n// There is an issue - when range is \"inverted\" values are scaled incorrectly.\n//   scaleBand().domain(['a', 'b', 'c']).range([0, 60])('b') === 20\n//   scaleBand().domain(['a', 'b', 'c']).range([60, 0])('b') === 20 (should be 40)\nconst scaleBandBounds = (scale: ScaleObject, bounds: DomainBounds): NumberArray => {\n  const cleanScale = scale.copy().paddingInner!(0).paddingOuter!(0);\n  const fullRange = scale.range();\n  const sign = Math.sign(fullRange[1] - fullRange[0]);\n  return sign >= 0\n    ? [cleanScale(bounds[0]), cleanScale(bounds[1]) + cleanScale.bandwidth!()]\n    : [cleanScale(bounds[0]) + cleanScale.bandwidth!(), cleanScale(bounds[1])];\n};\n\nconst moveLinearScaleBounds = (\n  scale: ScaleObject, bounds: DomainBounds, delta: number,\n): DomainBounds => {\n  const fullRange = scale.range();\n  const sign = Math.sign(fullRange[1] - fullRange[0]);\n  const range = scaleLinearBounds(scale, bounds);\n  let r0 = range[0] + delta;\n  let r1 = range[1] + delta;\n  // Check if new range is outside of the left border.\n  if (Math.sign(r0 - fullRange[0]) !== sign) {\n    r0 = fullRange[0];\n    r1 = r0 + range[1] - range[0];\n  }\n  // Check if new range is outside of the right border.\n  if (Math.sign(fullRange[1] - r1) !== sign) {\n    r1 = fullRange[1];\n    r0 = r1 - range[1] + range[0];\n  }\n  const newBounds: DomainBounds = [scale.invert!(r0), scale.invert!(r1)];\n  return rangesEqual(bounds, newBounds) ? bounds : newBounds;\n};\n\n// This is pointer \"delta\" processing specific for \"band\" scale.\n// If pointer delta is significantly smaller than band size (0.3) then movement should be skipped\n// and current delta should be added to a next one (from a new \"move\" event).\n// Now there is no code that accumulates deltas.\n// In order to allow band scrolling at least somehow the following is applied - if pointer delta\n// is at least greater than 30 pixel then minimal movement is performed.\n// TODO: Make proper delta accumulation!\nconst adjustBandScaleMoveStep = (delta: number, step: number) => {\n  const ratio = Math.abs(delta / step);\n  const sign = Math.sign(delta / step);\n  if (ratio >= 0.5) {\n    return sign * Math.round(ratio);\n  }\n  if (ratio >= 0.3) {\n    return sign;\n  }\n  if (Math.abs(delta) > 30) {\n    return sign;\n  }\n  return 0;\n};\n\n// Band case is processed separately to preserve categories count in the bounds range.\n// If common inversion mechanism is used start and end bounds cannot be inverted independently\n// because of rounding issues which may add or remove categories to the new bounds.\nconst moveBandScaleBounds = (\n  scale: ScaleObject, bounds: DomainBounds, delta: number,\n): DomainBounds => {\n  const domain = scale.domain();\n  const fullRange = scale.range();\n  const step = (fullRange[1] - fullRange[0]) / domain.length;\n  const rangeStep = adjustBandScaleMoveStep(delta, step);\n  if (rangeStep === 0) {\n    return bounds;\n  }\n  const range = scaleBounds(scale, bounds);\n  const range0 = Math.round((range[0] - fullRange[0]) / step);\n  const range1 = range0 + Math.round((range[1] - range[0]) / step) - 1;\n  let new0 = range0 + rangeStep;\n  let new1 = range1 + rangeStep;\n  if (new0 < 0) {\n    new0 = 0;\n    new1 = new0 + range1 - range0;\n  }\n  if (new1 > domain.length - 1) {\n    new1 = domain.length - 1;\n    new0 = new1 - range1 + range0;\n  }\n  if (new0 === range0 || new1 === range1) {\n    return bounds;\n  }\n  return [domain[new0], domain[new1]];\n};\n\n// Defines how much linear scale can be zoomed it.\n// I.e. if original scale domain has size of 1, then fully zoomed scale domain has size\n// of 1 / LINEAR_SCALE_ZOOMING_THRESHOLD.\nconst LINEAR_SCALE_ZOOMING_THRESHOLD = 1000;\n\nconst growLinearScaleBounds = (\n  scale: ScaleObject, bounds: DomainBounds, delta: number, anchor: number,\n): DomainBounds => {\n  const fullRange = scale.range();\n  const minRangeThreshold = (fullRange[1] - fullRange[0]) / LINEAR_SCALE_ZOOMING_THRESHOLD;\n  const sign = Math.sign(fullRange[1] - fullRange[0]);\n  const range = scaleBounds(scale, bounds);\n  // If zooming in and initial range is already too small then do nothing.\n  if (delta > 0 && Math.abs(range[1] - range[0]) <= Math.abs(minRangeThreshold)) {\n    return bounds;\n  }\n  // If zooming out and initial range is already too large then do nothing.\n  if (delta < 0 && Math.abs(range[1] - range[0]) >= Math.abs(fullRange[1] - fullRange[0])) {\n    return bounds;\n  }\n  const t = Math.abs((anchor - range[0]) / (range[1] - range[0]));\n  let r0 = range[0] + sign * delta * 2 * t;\n  let r1 = range[1] - sign * delta * 2 * (1 - t);\n  // If new range is outside of the left border then clamp it.\n  if (Math.sign(r0 - fullRange[0]) !== sign) {\n    r0 = fullRange[0];\n  }\n  // If new range is outside of the right border then clamp it.\n  if (Math.sign(fullRange[1] - r1) !== sign) {\n    r1 = fullRange[1];\n  }\n  // If new range is too small then make it no less than minimal available.\n  if (Math.sign(r1 - r0) !== sign || Math.abs(r1 - r0) < Math.abs(minRangeThreshold)) {\n    if (Math.abs(r0 - range[0]) < Math.abs(minRangeThreshold / 2)) {\n      // Dock it to the start.\n      r0 = range[0];\n      r1 = r0 + minRangeThreshold;\n    } else if (Math.abs(r1 - range[1]) < Math.abs(minRangeThreshold / 2)) {\n      // Dock it to the end.\n      r1 = range[1];\n      r0 = r1 - minRangeThreshold;\n    } else {\n      // Dock it to the anchor.\n      r0 = anchor - minRangeThreshold / 2;\n      r1 = anchor + minRangeThreshold / 2;\n    }\n  }\n  const newBounds: DomainBounds = [scale.invert!(r0), scale.invert!(r1)];\n  return rangesEqual(bounds, newBounds) ? bounds : newBounds;\n};\n\nconst growBandScaleBounds = (\n  scale: ScaleObject, bounds: DomainBounds, delta: number, anchor: number,\n): DomainBounds => {\n  const domain = scale.domain();\n  const fullRange = scale.range();\n  const step = (fullRange[1] - fullRange[0]) / domain.length;\n  const range = scaleBounds(scale, bounds);\n  const range0 = Math.round((range[0] - fullRange[0]) / step);\n  const range1 = range0 + Math.round((range[1] - range[0]) / step) - 1;\n  // Let it be always 1 for now.\n  const rangeStep = Math.sign(delta);\n  if (\n    (rangeStep === 0) ||\n    (rangeStep > 0 && range0 === range1) ||\n    (rangeStep < 0 && range0 === 0 && range1 === domain.length - 1)\n  ) {\n    return bounds;\n  }\n  const t = Math.abs((anchor - range[0]) / (range[1] - range[0]));\n  let new0 = range0 + Math.round(rangeStep * 2 * t);\n  let new1 = range1 - Math.round(rangeStep * 2 * (1 - t));\n  if (new0 < 0) {\n    new0 = 0;\n  }\n  if (new1 > domain.length - 1) {\n    new1 = domain.length - 1;\n  }\n  if (new0 > new1) {\n    if (t <= 0.5) {\n      new1 = new0;\n    } else {\n      new0 = new1;\n    }\n  }\n  if (new0 === range0 && new1 === range1) {\n    return bounds;\n  }\n  return [domain[new0], domain[new1]];\n};\n\nconst invertLinearScaleBounds = (scale: ScaleObject, range: NumberArray): DomainBounds => {\n  const fullRange = scale.range();\n  const match = Math.sign(fullRange[1] - fullRange[0]) === Math.sign(range[1] - range[0]);\n  return [\n    scale.invert!(range[match ? 0 : 1]),\n    scale.invert!(range[match ? 1 : 0]),\n  ];\n};\n\nconst matchPointToBand = (domain: DomainItems, range: NumberArray, p: number) => {\n  const i = Math.floor(domain.length * (p - range[0]) / (range[1] - range[0]));\n  return domain[Math.min(i, domain.length - 1)];\n};\n\nconst invertBandScaleBounds = (scale: ScaleObject, range: NumberArray): DomainBounds => {\n  const domain = scale.domain();\n  const fullRange = scale.range();\n  return [\n    matchPointToBand(domain, fullRange, range[0]),\n    matchPointToBand(domain, fullRange, range[1]),\n  ];\n};\n\n// Though these functions are used only in *Viewport* plugin (and so should be placed right there),\n// they reside here so that internal scale specifics (*getWidth*)\n// are encapsulated in this utility file.\n/** @internal */\nexport const scaleBounds = makeScaleHelper(scaleLinearBounds, scaleBandBounds);\n/** @internal */\nexport const moveBounds = makeScaleHelper(moveLinearScaleBounds, moveBandScaleBounds);\n// \"scaleBounds\" would be a better name but \"scale\" is already occupied.\n/** @internal */\nexport const growBounds = makeScaleHelper(growLinearScaleBounds, growBandScaleBounds);\n/** @internal */\nexport const invertBoundsRange = makeScaleHelper(invertLinearScaleBounds, invertBandScaleBounds);\n","import { extent } from 'd3-array';\nimport {\n  getValueDomainName, scaleLinear, scaleBand, rangesEqual, makeScale,\n} from '../../utils/scale';\nimport { ARGUMENT_DOMAIN, VALUE_DOMAIN } from '../../constants';\nimport {\n  Series, PointList, DomainItems, DomainInfoCache, BuildScalesFn, DomainInfo, DomainOptions,\n  AddDomainFn, MergeDomainsFn, GetItemFn, GetDomainItemsFn,\n  FactoryFn, ExtendDomainsFn, NumberArray,\n} from '../../types';\n\nconst makeDomain = ({ factory, modifyDomain }: DomainOptions): DomainInfo => ({\n  domain: [],\n  factory,\n  isDiscrete: !!(factory && isDiscrete(factory)),\n  modifyDomain,\n});\n\n/** @internal */\nexport const defaultDomains: DomainInfoCache = {\n  [ARGUMENT_DOMAIN]: makeDomain({}),\n  [VALUE_DOMAIN]: makeDomain({}),\n};\n/** @internal */\nexport const addDomain: AddDomainFn = (domains, name, options) => ({\n  ...domains,\n  [name]: makeDomain(options),\n});\n\nconst mergeContinuousDomains: MergeDomainsFn = (domain, items) => {\n  const newDomain = extent([...domain, ...items]);\n  return rangesEqual(newDomain as any, domain as any) ? domain : newDomain;\n};\n\nconst mergeDiscreteDomains: MergeDomainsFn = (domain, items) => {\n  const newDomain = Array.from(new Set([...domain, ...items]));\n  return newDomain.length === domain.length ? domain : newDomain;\n};\n\nconst getArgument: GetItemFn = point => point.argument;\nconst getValue: GetItemFn = point => point.value;\n\nconst guessFactory = (points: PointList, getItem: GetItemFn) => (\n  points.length && typeof getItem(points[0]) === 'string' ? scaleBand : scaleLinear\n);\n\nconst isDiscrete = (factory: FactoryFn) => 'bandwidth' in factory();\n\nconst updateDomainFactory = (domain: DomainInfo, series: Series, getItem: GetItemFn) => {\n  if (domain.factory) {\n    return domain;\n  }\n  const factory = guessFactory(series.points, getItem);\n  return {\n    ...domain,\n    factory,\n    isDiscrete: isDiscrete(factory),\n  };\n};\n\n/** @internal */\nexport const updateDomainItems = (domain: DomainInfo, items: DomainItems): DomainInfo => {\n  const merge = domain.isDiscrete ? mergeDiscreteDomains : mergeContinuousDomains;\n  const merged = merge(domain.domain, items);\n  return merged === domain.domain ? domain : {\n    ...domain,\n    domain: domain.modifyDomain ? domain.modifyDomain(merged) : merged,\n  };\n};\n\nconst getArgumentDomainItems: GetDomainItemsFn = series => series.points.map(getArgument);\n\nconst getValueDomainItems: GetDomainItemsFn = (series) => {\n  const items = series.points.map(getValue);\n  return series.getPointTransformer.isStartedFromZero ? [0, ...items] : items;\n};\n\nconst updateDomain = (\n  domain: DomainInfo, series: Series, getItem: GetItemFn, getDomainItems: GetDomainItemsFn,\n) => updateDomainItems(updateDomainFactory(domain, series, getItem), getDomainItems(series));\n\n/** @internal */\nexport const extendDomains: ExtendDomainsFn = (domains, series) => {\n  const argumentDomain = updateDomain(\n    domains[ARGUMENT_DOMAIN], series, getArgument, getArgumentDomainItems);\n  const valueDomainName = getValueDomainName(series.scaleName);\n  const valueDomain = updateDomain(\n    domains[valueDomainName], series, getValue, getValueDomainItems);\n  const changes = {};\n  if (argumentDomain !== domains[ARGUMENT_DOMAIN]) {\n    changes[ARGUMENT_DOMAIN] = argumentDomain;\n  }\n  if (valueDomain !== domains[valueDomainName]) {\n    changes[valueDomainName] = valueDomain;\n  }\n  return Object.keys(changes).length ? { ...domains, ...changes } : domains;\n};\n\n/** @internal */\nexport const buildScales: BuildScalesFn = (domains, ranges) => {\n  const scales = {};\n  Object.keys(domains).forEach((name) => {\n    scales[name] = makeScale(\n      domains[name],\n      ranges[name === ARGUMENT_DOMAIN ? ARGUMENT_DOMAIN : VALUE_DOMAIN] as NumberArray,\n    );\n  });\n  return scales;\n};\n","import { Size } from '@devexpress/dx-react-core';\nimport {\n  ARGUMENT_DOMAIN, VALUE_DOMAIN,\n} from '../../constants';\nimport {\n  BBoxes, BBoxesChange, RangesCache, NumberArray,\n} from '../../types';\n\nconst isEqual = (\n  { width: firstWidth, height: firstHeight }: Size,\n  { width: secondWidth, height: secondHeight }: Size,\n) => firstWidth === secondWidth && firstHeight === secondHeight;\n\n/** @internal */\nexport const bBoxes = (prevBBoxes: BBoxes, { bBox, placeholder }: BBoxesChange) => {\n  if (isEqual(prevBBoxes[placeholder] || {}, bBox)) return prevBBoxes;\n  return { ...prevBBoxes, [placeholder]: bBox };\n};\n\n/** @internal */\nexport const getRanges = (paneSize: Size, rotated: boolean): RangesCache => {\n  const horRange: NumberArray = [0, paneSize.width];\n  const verRange: NumberArray = [paneSize.height, 0];\n  return {\n    [ARGUMENT_DOMAIN]: rotated ? verRange : horRange,\n    [VALUE_DOMAIN]: rotated ? horRange : verRange,\n  };\n};\n","import { isHorizontal } from '../../utils/scale';\nimport {\n  LEFT, RIGHT, TOP, BOTTOM, MIDDLE, END, START,\n} from '../../constants';\nimport {\n  ScaleObject, GetFormatFn, ProcessTickFn, TickFormatFn, NumberArray, GetTickCoordinatesFn,\n  TickCoordinatesGetterFn, Tick, Grid,\n} from '../../types';\n\nconst getTicks = (scale: ScaleObject, count: number) => (\n  scale.ticks ? scale.ticks(count) : scale.domain()\n);\n\nconst createTicks = <T>(\n  scale: ScaleObject, count: number, callback: ProcessTickFn<T>,\n): ReadonlyArray<T> => (\n  getTicks(scale, count)\n    .map((tick, index) => callback(scale(tick), String(index), tick))\n);\n\nconst getFormat = (scale: ScaleObject, count: number, tickFormat?: TickFormatFn): GetFormatFn => {\n  if (scale.tickFormat) {\n    return tickFormat ? tickFormat(scale, count) : scale.tickFormat(count);\n  }\n  return tick => tick;\n};\n\nconst rotatedPositions = {\n  [LEFT]: BOTTOM,\n  [RIGHT]: TOP,\n  [BOTTOM]: LEFT,\n  [TOP]: RIGHT,\n};\n\nconst positionFlags = {\n  [LEFT]: false,\n  [RIGHT]: false,\n  [BOTTOM]: true,\n  [TOP]: true,\n};\n\n/** @internal */\nexport const getRotatedPosition = (position: string) => rotatedPositions[position];\n\n/** @internal */\nexport const isValidPosition = (position: string, scaleName: string, rotated: boolean) =>\n  positionFlags[position] === isHorizontal(scaleName, rotated);\n\nconst createHorizontalOptions = (position: string, tickSize: number, indentFromAxis: number) => {\n  // Make *position* orientation agnostic - should be START or END.\n  const isStart = position === BOTTOM;\n  return {\n    y1: 0,\n    y2: isStart ? +tickSize : -tickSize,\n    yText: isStart ? +indentFromAxis : -indentFromAxis,\n    dy: isStart ? '1em' : '0em',\n    textAnchor: MIDDLE,\n  };\n};\n\nconst createVerticalOptions = (position: string, tickSize: number, indentFromAxis: number) => {\n  // Make *position* orientation agnostic - should be START or END.\n  const isStart = position === LEFT;\n  return {\n    x1: 0,\n    x2: isStart ? -tickSize : +tickSize,\n    xText: isStart ? -indentFromAxis : +indentFromAxis,\n    dy: '0.3em',\n    textAnchor: isStart ? END : START,\n  };\n};\n\n// Constant is selected to preserve original behavior described in\n// https://github.com/d3/d3-scale#continuous_ticks.\nconst DEFAULT_TICK_COUNT = 10;\nconst getTickCount = (scaleRange: NumberArray, paneSize: number) => {\n  const rangeToPaneRatio = Math.abs(scaleRange[0] - scaleRange[1]) / paneSize;\n  return Math.round(DEFAULT_TICK_COUNT * (isFinite(rangeToPaneRatio) ? rangeToPaneRatio : 1));\n};\n\nconst createTickFilter = (isHor: boolean, size: number) => (\n  isHor\n    ? (tick: any) => tick.x1 >= 0 && tick.x1 <= size\n    : (tick: any) => tick.y1 >= 0 && tick.y1 <= size\n);\n\n/** @internal */\nexport const tickCoordinatesGetter: TickCoordinatesGetterFn<Tick> = ({\n  isHor, scale, tickCount, tickFormat, position, tickSize, indentFromAxis,\n}) => {\n  const formatTick = getFormat(scale!, tickCount!, tickFormat);\n  const options = (isHor ? createHorizontalOptions : createVerticalOptions)(\n    position!, tickSize!, indentFromAxis!,\n  );\n  return (coordinates, key, tick) => ({\n    key,\n    x1: coordinates,\n    x2: coordinates,\n    y1: coordinates,\n    y2: coordinates,\n    xText: coordinates,\n    yText: coordinates,\n    text: formatTick(tick),\n    ...options,\n  });\n};\n\n/** @internal */\nexport const gridCoordinatesGetter: TickCoordinatesGetterFn<Grid> = ({ isHor }) => {\n  const options = isHor ? { y1: 0 } : { x1: 0 };\n  return (coordinates, key) => ({\n    key,\n    x1: coordinates,\n    y1: coordinates,\n    ...options,\n  });\n};\n\n/** @internal */\nexport const getTickCoordinates: GetTickCoordinatesFn<Tick | Grid> = ({\n  scaleName, scale, paneSize, rotated, callback, ...restProps\n}) => {\n  const isHor = isHorizontal(scaleName, rotated);\n  const tickCount = getTickCount(scale.range(), paneSize[1 - Number(isHor)]);\n  const ticks = createTicks(scale, tickCount, callback({ isHor, scale, tickCount, ...restProps }));\n  const visibleTicks = ticks.filter(createTickFilter(isHor, paneSize[1 - Number(isHor)]));\n  return {\n    ticks: visibleTicks,\n    sides: [Number(isHor), Number(!isHor)],\n  };\n};\n","import {\n  symbol,\n  symbolCircle,\n  line,\n  curveMonotoneX,\n  curveMonotoneY,\n  area,\n  arc,\n  pie,\n} from 'd3-shape';\nimport {\n  SeriesList, Series, PointList, Point, DataItems, AddSeriesFn, ScalesCache, ScaleSeriesPointsFn,\n  GetPointTransformerFn, Colors, Rect,\n  BarSeries, ScatterSeries, PieSeries,\n  PointComponentProps, PathFn, PathStartCoordinates, PathEndCoordinates, Scales,\n} from '../../types';\nimport { Size } from '@devexpress/dx-react-core';\nimport { ARGUMENT_DOMAIN } from '../../constants';\nimport { getValueDomainName, getWidth, rangesEqual } from '../../utils/scale';\n\nconst getArg = ({ arg }: PointComponentProps) => arg;\nconst getVal = ({ val }: PointComponentProps) => val;\nconst getStartVal = ({ startVal }: PointComponentProps) => startVal!;\n\n/** @internal */\nexport const dArea: PathFn = area<PointComponentProps>()\n  .x(getArg)\n  .y1(getVal)\n  .y0(getStartVal) as any;\n\n/** @internal */\nexport const dRotateArea: PathFn = area<PointComponentProps>()\n  .x1(getStartVal)\n  .x0(getVal)\n  .y(getArg) as any;\n\n/** @internal */\nexport const dLine: PathFn = line<PointComponentProps>()\n  .x(getArg)\n  .y(getVal) as any;\n\n/** @internal */\nexport const dRotateLine = line<PointComponentProps>()\n  .x(getVal)\n  .y(getArg) as any;\n\n/** @internal */\nexport const dSpline: PathFn = line<PointComponentProps>()\n  .x(getArg)\n  .y(getVal)\n  .curve(curveMonotoneX) as any;\n\n/** @internal */\nexport const dRotateSpline: PathFn = line<PointComponentProps>()\n  .x(getVal)\n  .y(getArg)\n  .curve(curveMonotoneY) as any;\n\n/** @internal */\nexport const dBar = (\n  arg: number, val: number, startVal: number, width: number, rotated: boolean,\n) => {\n  const height = Math.abs(val - startVal!);\n  const minVal = Math.min(val, startVal!);\n  return {\n    x: rotated ? minVal : arg - width / 2,\n    y: rotated ? arg - width / 2 : minVal,\n    width: rotated ? height : width || 2,\n    height: rotated ? width || 2 : height,\n  };\n};\n\n/** @internal */\nexport const getPiePointTransformer: GetPointTransformerFn = ({\n  argumentScale, valueScale, points,\n}) => {\n  const x = Math.max(...argumentScale.range()) / 2;\n  const y = Math.max(...valueScale.range()) / 2;\n  const maxRadius = Math.min(x, y);\n  const pieData = pie<Point>().sort(null).value(d => d.value)(points as Point[]);\n  return (point) => {\n    const { startAngle, endAngle } = pieData[point.index];\n    return {\n      ...point,\n      arg: x,\n      val: y,\n      startAngle,\n      endAngle,\n      maxRadius,\n    };\n  };\n};\n\n/** @internal */\nexport const getLinePointTransformer: GetPointTransformerFn = ({\n  argumentScale, valueScale,\n}) => point => ({\n  ...point,\n  arg: argumentScale(point.argument),\n  val: valueScale(point.value),\n} as any);\n\n// Though transformations for line and scatter are the same,\n// separate function instance is required as it contains additional static fields.\n/** @internal */\nexport const getScatterPointTransformer: GetPointTransformerFn = (\n  ...args\n) => getLinePointTransformer(...args);\n\n/** @internal */\nexport const getAreaPointTransformer: GetPointTransformerFn = (series) => {\n  const transform = getLinePointTransformer(series);\n  const startVal = series.valueScale(0);\n  return (point) => {\n    const ret = transform(point);\n    return {\n      ...ret,\n      startVal,\n    };\n  };\n};\n// Used for domain calculation and stacking.\ngetAreaPointTransformer.isStartedFromZero = true;\n\n/** @internal */\nexport const getBarPointTransformer: GetPointTransformerFn = ({\n  argumentScale, valueScale,\n}) => {\n  const startVal = valueScale(0);\n  return point => ({\n    ...point,\n    arg: argumentScale(point.argument),\n    val: valueScale(point.value),\n    startVal,\n    maxBarWidth: getWidth(argumentScale),\n  } as any);\n};\n// Used for domain calculation and stacking.\ngetBarPointTransformer.isStartedFromZero = true;\n// Used for Bar grouping.\ngetBarPointTransformer.isBroad = true;\n\ngetPiePointTransformer.getPointColor = (palette, index) => palette[index % palette.length];\n\n/** @internal */\nexport const findSeriesByName = (\n  name: symbol, series: SeriesList,\n): Series => series.find(seriesItem => seriesItem.symbolName === name) as Series;\n\n/** @internal */\nexport const dSymbol = (\n  { size }: ScatterSeries.PointOptions,\n) => symbol().size(size ** 2).type(symbolCircle)()!;\n\n/** @internal */\nexport const dPie = (\n  maxRadius: number, innerRadius: number, outerRadius: number, startAngle: number, endAngle: number,\n) => arc()({\n  startAngle,\n  endAngle,\n  innerRadius: innerRadius * maxRadius,\n  outerRadius: outerRadius * maxRadius,\n})!;\n\nconst getRect = (\n  cArg: number, cVal: number, dArg: number, dVal: number, rotated: boolean,\n): Rect => {\n  const minArg = cArg - dArg;\n  const minVal = cVal - dVal;\n  const maxArg = cArg + dArg;\n  const maxVal = cVal + dVal;\n  return rotated ? [minVal, minArg, maxVal, maxArg] : [minArg, minVal, maxArg, maxVal];\n};\n\ngetBarPointTransformer.getTargetElement = (point) => {\n  const {\n    arg, val, startVal, barWidth, maxBarWidth, rotated,\n  } = point as BarSeries.PointProps;\n  const halfWidth = barWidth * maxBarWidth / 2;\n  const halfHeight = Math.abs(startVal! - val) / 2;\n  const centerVal = (val + startVal!) / 2;\n  return getRect(arg, centerVal, halfWidth, halfHeight, rotated);\n};\n\ngetPiePointTransformer.getTargetElement = (point) => {\n  const {\n    arg: x, val: y, innerRadius, outerRadius, maxRadius, startAngle, endAngle,\n  } = point as PieSeries.PointProps;\n  const center = arc().centroid({\n    startAngle,\n    endAngle,\n    innerRadius: innerRadius * maxRadius,\n    outerRadius: outerRadius * maxRadius,\n  });\n  const cx = center[0] + x;\n  const cy = center[1] + y;\n  return getRect(cx, cy, 0.5, 0.5, false);\n};\n\ngetAreaPointTransformer.getTargetElement = ({ arg, val, rotated }) => (\n  getRect(arg, val, 1, 1, rotated)\n);\n\ngetLinePointTransformer.getTargetElement = getAreaPointTransformer.getTargetElement;\n\ngetScatterPointTransformer.getTargetElement = (obj) => {\n  const { arg, val, point, rotated } = obj as ScatterSeries.PointProps;\n  const t = point.size / 2;\n  return getRect(arg, val, t, t, rotated);\n};\n\nconst getUniqueName = (list: SeriesList, name: string) => {\n  const names = new Set(list.map(item => item.name));\n  let ret = name;\n  while (names.has(ret)) {\n    // @ts-ignore\n    ret = ret.replace(/\\d*$/, str => (str ? +str + 1 : 0));\n  }\n  return ret;\n};\n\n// TODO: Memoization is much needed here.\n// Though \"series\" list never persists, single \"series\" item most often does.\nconst createPoints = (\n  {\n    argumentField, valueField, getPointTransformer,\n  }: Series,\n  data: DataItems, props: any, palette: Colors,\n): PointList => {\n  const points: Point[] = [];\n  data.forEach((dataItem, index) => {\n    const argument = dataItem[argumentField];\n    const value = dataItem[valueField];\n    if (argument !== undefined && value !== undefined) {\n      points.push({\n        argument,\n        value,\n        index,\n        ...props,\n        color: getPointTransformer.getPointColor\n          ? getPointTransformer.getPointColor(palette, index) : props.color,\n      });\n    }\n  });\n  return points;\n};\n\n/** @internal */\nexport const addSeries: AddSeriesFn = (\n  series, data, palette, props, restProps,\n) => {\n  // It is used to generate unique series dependent attribute names for patterns.\n  // *symbolName* cannot be used as it cannot be part of DOM attribute name.\n  const index = series.length;\n  const seriesColor = props.color || palette[index % palette.length];\n  return [...series, {\n    ...props,\n    index,\n    name: getUniqueName(series, props.name),\n    points: createPoints(props, data, { ...restProps, color: seriesColor }, palette),\n    color: seriesColor,\n  }];\n};\n\n// TODO: Memoization is much needed here by the same reason as in \"createPoints\".\n// Make \"scales\" persistent first.\nconst scalePoints = (series: Series, scales: ScalesCache, rotated: boolean) => {\n  const transform = series.getPointTransformer({\n    ...series,\n    argumentScale: scales[ARGUMENT_DOMAIN],\n    valueScale: scales[getValueDomainName(series.scaleName)],\n  });\n  const ret: Series = {\n    ...series,\n    rotated,\n    points: series.points.map(point => ({\n      ...transform(point),\n      rotated,\n    })),\n  };\n  return ret;\n};\n\n/** @internal */\nexport const scaleSeriesPoints: ScaleSeriesPointsFn = (\n  series, scales, rotated,\n) => series.map(seriesItem => scalePoints(seriesItem, scales, rotated));\n\n/** @internal */\nexport const getVisibility = (\n  pane: Size, centerX: number, centerY: number, width: number, height: number,\n) => {\n  return (centerX - width / 2 < 0 && centerX + width / 2 < 0)\n  || (centerX - width / 2 > pane.width && centerX + width / 2 > pane.width)\n  || (centerY - height / 2 < 0 && centerY + height / 2 < 0)\n  || (centerY - height / 2 > pane.height && centerY + height / 2 > pane.height) ?\n  'hidden' : 'visible';\n};\n\n/** @internal */\nexport const adjustBarSize = (\n  bar: { width: number, height: number, x: number, y: number }, { width, height }: Size,\n) => {\n  const x = Math.max(0, bar.x);\n  const y = Math.max(0, bar.y);\n  return {\n    x,\n    y,\n    width: Math.min(width, bar.x + bar.width) - x,\n    height: Math.min(height, bar.y + bar.height) - y,\n  };\n};\n\n/** @internal */\nexport const isValuesChanged = (previous: any, current: any): boolean => {\n  return Object.entries(previous).some(el => el[1] !== current[el[0]]);\n};\n\n/** @internal */\nexport const isCoordinatesChanged = (\n  { coordinates: prevCoordinates }: PathStartCoordinates, { coordinates }: PathEndCoordinates,\n) => {\n  if (prevCoordinates.length !== coordinates.length) {\n    return true;\n  }\n  return prevCoordinates.some((el, index) => {\n    return el.arg !== coordinates[index].arg || el.val !== coordinates[index].val;\n  });\n};\n\n/** @internal */\nexport const isScalesChanged = (previous: Scales, current: Scales): boolean => {\n  return !rangesEqual(previous.argScale.range(), current.argScale.range()) ||\n  !rangesEqual(previous.valScale.range(), current.valScale.range());\n};\n","import { stack } from 'd3-shape';\nimport { scaleBand } from 'd3-scale';\nimport {\n  SeriesList, Series, Point, GetPointTransformerFn, DataItems, DomainInfoCache,\n  StackList, GetPointTransformerFnRaw, BarSeries, StackedPoint, StackMap, GetStackedSeriesFn,\n  SeriesPositions, StacksKeys, StackedDataItems, OffsetFn, OrderFn,\n  StackedData, GetStackedDomainsFn,\n} from '../../types';\nimport { extendDomains, updateDomainItems } from '../scale/computeds';\nimport { getValueDomainName } from '../../utils/scale';\n\n// \"Stack\" plugin relies on \"data\" and \"series\" getters and\n// knowledge about \"getPointTransformer\" and \"path\" functions behavior.\nconst buildSeriesToStackMap = (stacks: StackList): StackMap => {\n  const result = {};\n  stacks.forEach(({ series }, i) => {\n    series.forEach((name) => {\n      result[name] = i;\n    });\n  });\n  return result;\n};\n\nconst getStackedPointTransformer = (getPointTransformer: GetPointTransformerFn) => {\n  const wrapper: GetPointTransformerFnRaw = (series) => {\n    const transform = getPointTransformer(series);\n    const { valueScale } = series;\n    return (point: Point) => {\n      const ret = transform(point);\n      return {\n        ...ret,\n        startVal: valueScale((point as StackedPoint).value0),\n      };\n    };\n  };\n  // Preserve static fields of original transformer.\n  Object.assign(wrapper, getPointTransformer);\n  return wrapper as GetPointTransformerFn;\n};\n\nconst collectStacks = (\n  seriesList: SeriesList, seriesToStackMap: StackMap,\n  stacksKeys: StacksKeys, seriesPositions: SeriesPositions,\n) => {\n  seriesList.forEach(({ name, valueField }) => {\n    const stackId = seriesToStackMap[name];\n    if (stackId === undefined) {\n      return;\n    }\n\n    if (!stacksKeys[stackId]) {\n      stacksKeys[stackId] = [];\n    }\n    seriesPositions[name] = stacksKeys[stackId].length;\n    stacksKeys[stackId].push(valueField);\n  });\n  // Stack cannot consist of single series.\n  Object.keys(stacksKeys).forEach((stackId) => {\n    if (stacksKeys[stackId].length === 1) {\n      delete stacksKeys[stackId];\n    }\n  });\n};\n\nconst getStackedData = (\n  stacksKeys: StacksKeys, dataItems: DataItems, offset: OffsetFn, order: OrderFn,\n): StackedData => {\n  const result = {};\n  Object.keys(stacksKeys).forEach((stackId) => {\n    result[stackId] = stack().keys(stacksKeys[stackId])\n      .order(order as any)\n      .offset(offset as any)(dataItems as any);\n  });\n  return result;\n};\n\nconst buildStackedSeries = (series: Series, dataItems: StackedDataItems): Series => {\n  const points = series.points.map((point) => {\n    const [value0, value] = dataItems[point.index];\n    return { ...point, value, value0 };\n  });\n  const stackedSeries = {\n    ...series,\n    points,\n    isStacked: true,\n  };\n  if (series.getPointTransformer.isStartedFromZero) {\n    stackedSeries.getPointTransformer = getStackedPointTransformer(series.getPointTransformer);\n  }\n  return stackedSeries;\n};\n\nconst applyStacking = (\n  seriesList: SeriesList, dataItems: DataItems, seriesToStackMap: StackMap,\n  offset: OffsetFn, order: OrderFn,\n): SeriesList => {\n  const stacksKeys: StacksKeys = {};\n  const seriesPositions: SeriesPositions = {};\n  collectStacks(seriesList, seriesToStackMap, stacksKeys, seriesPositions);\n  if (Object.keys(stacksKeys).length === 0) {\n    return seriesList;\n  }\n  const stackedData = getStackedData(stacksKeys, dataItems, offset, order);\n  return seriesList.map((seriesItem) => {\n    const stackId = seriesToStackMap[seriesItem.name];\n    const stackData = stackedData[stackId];\n    if (!stackData) {\n      return seriesItem;\n    }\n    const position = seriesPositions[seriesItem.name];\n    return buildStackedSeries(seriesItem, stackData[position]);\n  });\n};\n\nconst getGroupName = (series: Series, i: number, seriesToStackMap: StackMap) => {\n  const stackId = seriesToStackMap[series.name];\n  return stackId >= 0 ? String(stackId) : `group-${i}`;\n};\n\nconst getGroupedPointTransformer = (\n  getPointTransformer: GetPointTransformerFn, groupCount: number, groupOffset: number,\n) => {\n  const wrapper: GetPointTransformerFnRaw = (series) => {\n    const transform = getPointTransformer(series);\n    const widthCoeff = 1 / groupCount;\n    return (point) => {\n      const original = transform(point) as BarSeries.PointProps;\n      const arg = (\n        original.arg - original.maxBarWidth * (0.5 - 0.5 * widthCoeff - groupOffset * widthCoeff)\n      );\n      const result: BarSeries.PointProps = {\n        ...original,\n        arg,\n        maxBarWidth: original.maxBarWidth / groupCount,\n      };\n      return result;\n    };\n  };\n  // Preserve static fields of original transformer.\n  Object.assign(wrapper, getPointTransformer);\n  return wrapper as GetPointTransformerFn;\n};\n\nconst applyGrouping = (seriesList: SeriesList, seriesToStackMap: StackMap): SeriesList => {\n  const groups = new Set<string>();\n  seriesList.forEach((seriesItem, i) => {\n    if (seriesItem.getPointTransformer.isBroad) {\n      groups.add(getGroupName(seriesItem, i, seriesToStackMap));\n    }\n  });\n  // There cannot be single group.\n  if (groups.size < 2) {\n    return seriesList;\n  }\n  const scale = scaleBand().domain(Array.from(groups)).range([0, groups.size]);\n  return seriesList.map((seriesItem, i) => {\n    if (!seriesItem.getPointTransformer.isBroad) {\n      return seriesItem;\n    }\n    const getPointTransformer = getGroupedPointTransformer(\n      seriesItem.getPointTransformer,\n      groups.size,\n      scale(getGroupName(seriesItem, i, seriesToStackMap))!,\n    );\n    return {\n      ...seriesItem,\n      getPointTransformer,\n    };\n  });\n};\n\n/** @internal */\nexport const getStackedSeries: GetStackedSeriesFn = (\n  seriesList, dataItems, { stacks, offset, order },\n) => {\n  const map = buildSeriesToStackMap(stacks);\n  const stackedSeriesList = applyStacking(seriesList, dataItems, map, offset, order);\n  const groupedSeriesList = applyGrouping(stackedSeriesList, map);\n  return groupedSeriesList;\n};\n\nconst resetDomainItems = (domains: DomainInfoCache): DomainInfoCache => {\n  const result = {};\n  Object.keys(domains).forEach((key) => {\n    result[key] = { ...domains[key], domain: [] };\n  });\n  return result;\n};\n\nconst extendDomainsWithAdditionalItems = (domains: DomainInfoCache, series: Series) => {\n  const items = series.points.map(point => (point as StackedPoint).value0);\n  const key = getValueDomainName(series.scaleName);\n  const domain = updateDomainItems(domains[key], items);\n  return domain !== domains[key] ? { ...domains, [key]: domain } : domains;\n};\n\n// Stacking changes data - so computed domains have to be discarded\n// and recalculated from the new stacked data.\n/** @internal */\nexport const getStackedDomains: GetStackedDomainsFn = (domains, seriesList) => {\n  const stackedSeries = seriesList.filter(series => (series as any).isStacked);\n  if (!stackedSeries.length) {\n    return domains;\n  }\n  // Recalculate domains in a common way.\n  const rebuiltDomains = seriesList.reduce(extendDomains, resetDomainItems(domains));\n  // Take additional \"value0\" fields into account.\n  return stackedSeries.reduce(extendDomainsWithAdditionalItems, rebuiltDomains);\n};\n","import {\n  Scales, PointComponentProps, PieSeries, PathComponentProps, GetDelayFn,\n} from '../../types';\n\n/** @internal */\nexport const easeOutCubic = (t: number) => (t - 1) * (t - 1) * (t - 1) + 1;\n\n/** @internal */\nexport const getDelay: GetDelayFn = (index, isStart) => isStart ? index * 30 : 0;\n\n/** @internal */\nexport const getStartVal = (scales: Scales) => {\n  return scales.valScale.copy().clamp!(true)(0);\n};\n\n/** @internal */\nexport const getPathStart = (scales: Scales, { coordinates }: PathComponentProps) => {\n  const start = getStartVal(scales);\n  return { coordinates: coordinates.map(coord =>\n    ({ arg: coord.arg, val: start, startVal: start })) };\n};\n\n/** @internal */\nexport const getPointStart = (scales: Scales, { arg }: PointComponentProps) => {\n  const start = getStartVal(scales);\n  return { arg, val: start, startVal: start };\n};\n\n/** @internal */\nexport const getPieStart = (scales: Scales, { startAngle, endAngle }: PieSeries.PointProps) =>\n({ innerRadius: 0, outerRadius: 0, startAngle, endAngle });\n","import { SeriesRef, TargetList, NotifyPointerMoveFn, ProcessedTarget } from '../types';\n\n// Comparing by reference is not an option as Tracker always sends new objects.\n// Tracker cannot persist references as it actually operates with simple scalars\n// and constructs objects to provide info in a slightly more suitable way.\nconst compareTargets = (target1: SeriesRef, target2: SeriesRef) => (\n  target1.series === target2.series && target1.point === target2.point\n);\n\n// If *currentTarget* is among *targets* then it has priority but only while its distance\n// is not significantly greater (DISTANCE_PRIORITY_RATIO) than that of the best candidate.\nconst selectTarget = (targets: TargetList, currentTarget: SeriesRef): ProcessedTarget => {\n  const candidate = targets[0];\n  if (!currentTarget) {\n    return candidate;\n  }\n  if (!candidate) {\n    return null;\n  }\n  return compareTargets(candidate, currentTarget) ? undefined : candidate;\n};\n\n/** @internal */\nexport const processPointerMove = (\n  targets: TargetList, currentTarget: SeriesRef, notify?: NotifyPointerMoveFn,\n) => {\n  const nextTarget = selectTarget(targets, currentTarget);\n  if (nextTarget === undefined) {\n    return undefined;\n  }\n  if (notify) {\n    notify(nextTarget);\n  }\n  return nextTarget;\n};\n","import { NumberArray, Location } from '../types';\n// This function is to be called from context where DOM is available -\n// so *window* can be accessed safely.\n/** @internal */\nexport const getOffset = (element: Element): NumberArray => {\n  const { left, top } = element.getBoundingClientRect();\n  // Safer way to get window.\n  const { defaultView } = element.ownerDocument!;\n  const { pageXOffset, pageYOffset } = defaultView!;\n  return [left + pageXOffset, top + pageYOffset];\n};\n\n/** @internal */\nexport const getEventCoords = (e: any, offset: NumberArray): Location => {\n  const { pageX, pageY } = e.touches ? e.touches[0] : e;\n  return [pageX - offset[0], pageY - offset[1]];\n};\n","import { processPointerMove } from '../../utils/hover-state';\nimport { getOffset } from '../../utils/common';\nimport {\n  SeriesList, SeriesRef, TransformedPoint, TargetList, NotifyPointerMoveFn,\n  TooltipParameters, TooltipReference, Rect,\n} from '../../types';\n\n/** @internal */\nexport const getParameters = (series: SeriesList, target: SeriesRef): TooltipParameters => {\n  const currentSeries = series.find(({ name }) => target.series === name)!;\n  const item = currentSeries.points.find(point => point.index === target.point) as TransformedPoint;\n  return {\n    element: currentSeries.getPointTransformer.getTargetElement(item),\n    text: `${item.value}`,\n  };\n};\n\n/** @internal */\nexport const createReference = (\n  rect: Rect, rootRef: React.RefObject<Element>,\n): TooltipReference => ({\n  // These two fields together with *width* and *height* are left with stub data for\n  // simplicity reasons - they seem to be unused by *Popper*.\n  clientWidth: 0,\n  clientHeight: 0,\n  getBoundingClientRect() {\n    // This function is expected to be called (by the *Popper*) when DOM is ready -\n    // so *rootRef.current* can be accessed.\n    const offset = getOffset(rootRef.current!);\n    // *getBoundingClientRect* of a real html element is affected by window scrolling.\n    // *popper.js* subscribes \"html -> getBoundingClientRect -> (left, top)\" from\n    // \"reference -> getBoundingClientRect\" - so here it is added.\n    const htmlRect = rootRef.current!.ownerDocument!.documentElement.getBoundingClientRect();\n    return {\n      left: rect[0] + offset[0] + htmlRect.left,\n      top: rect[1] + offset[1] + htmlRect.top,\n      right: rect[2] + offset[0] + htmlRect.left,\n      bottom: rect[3] + offset[1] + htmlRect.top,\n      width: 0,\n      height: 0,\n    };\n  },\n});\n\n/** @internal */\nexport const processHandleTooltip = (\n  targets: TargetList, currentTarget: SeriesRef, onTargetItemChange?: NotifyPointerMoveFn,\n) => {\n  const filterTargets = targets.filter(target => target.point !== undefined);\n  return processPointerMove(filterTargets, currentTarget, onTargetItemChange);\n};\n","import {\n  ARGUMENT_DOMAIN, VALUE_DOMAIN,\n} from '../../constants';\nimport {\n  getValueDomainName, makeScale, scaleBounds, rangesEqual,\n  moveBounds, growBounds, invertBoundsRange,\n} from '../../utils/scale';\nimport {\n  NumberArray,\n  Viewport,\n  ScalesCache,\n  DomainInfoCache,\n  RangesCache,\n  DomainInfo,\n  DomainBounds,\n  OnViewportChangeFn,\n  ScaleObject,\n  EventHandlers,\n  Location,\n  Interaction,\n} from '../../types';\nimport { Size } from '@devexpress/dx-react-core';\n\nconst getArgumentBounds = (viewport?: Viewport): DomainBounds | null => (\n  viewport && viewport.argumentStart !== undefined && viewport.argumentEnd !== undefined\n    ? [viewport.argumentStart, viewport.argumentEnd] : null\n);\n\nconst getValueBounds = (viewport?: Viewport): DomainBounds | null => (\n  viewport && viewport.valueStart !== undefined && viewport.valueEnd !== undefined\n    ? [viewport.valueStart, viewport.valueEnd] : null\n);\n\nconst getValueScaleName = (viewport?: Viewport) => (\n  getValueDomainName(viewport && viewport.scaleName)\n);\n\nconst getDefaultBounds = (scale: ScaleObject): DomainBounds => {\n  const domain = scale.domain();\n  return [domain[0], domain[domain.length - 1]];\n};\n\nconst proportionallyExtendRange = (range: NumberArray, subRange: NumberArray): NumberArray => {\n  const p = (subRange[0] - subRange[1]) / (range[0] - range[1]);\n  const q = subRange[0] - p * range[0];\n  return [\n    (range[0] - q) / p,\n    (range[1] - q) / p,\n  ];\n};\n\nconst adjustRange = (domain: DomainInfo, bounds: DomainBounds, range: NumberArray) => {\n  const scale = makeScale(domain, range);\n  const subRange = scaleBounds(scale, bounds);\n  return rangesEqual(subRange, range) ? range : proportionallyExtendRange(range, subRange);\n};\n\nconst update = (\n  ranges: RangesCache, changes: any, key: string, domain: DomainInfo, bounds: DomainBounds,\n) => {\n  const newRange = adjustRange(domain, bounds, ranges[key]);\n  if (newRange !== ranges[key]) {\n    changes[key] = newRange;\n  }\n};\n\n/** @internal */\nexport const adjustLayout = (\n  domains: DomainInfoCache, ranges: RangesCache, viewport?: Viewport,\n) => {\n  const changes = {};\n  const argumentBounds = getArgumentBounds(viewport);\n  if (argumentBounds) {\n    update(ranges, changes, ARGUMENT_DOMAIN, domains[ARGUMENT_DOMAIN], argumentBounds);\n  }\n  const valueBounds = getValueBounds(viewport);\n  if (valueBounds) {\n    update(ranges, changes, VALUE_DOMAIN, domains[getValueScaleName(viewport)], valueBounds);\n  }\n  return Object.keys(changes).length ? { ...ranges, ...changes } : ranges;\n};\n\nconst boundsForScale = (\n  name: string, scales: ScalesCache, currentBounds: DomainBounds | null,\n  interaction: Interaction, type: Interaction, delta: number, anchor: number, range?: NumberArray,\n): DomainBounds | null => {\n  if (!checkInteraction(interaction, type)) {\n    return null;\n  }\n  const scale = scales[name];\n  const bounds = currentBounds || getDefaultBounds(scale);\n  let newBounds: DomainBounds;\n  if (type === 'pan') {\n    newBounds = moveBounds(scale, bounds, delta);\n  } else if (type === 'zoom') {\n    newBounds = range ? invertBoundsRange(scale, range) : growBounds(scale, bounds, delta, anchor);\n  }\n  return newBounds! !== bounds ? newBounds! : null;\n};\n\n/** @internal */\nexport const getViewport = (\n  scales: ScalesCache,\n  rotated: boolean,\n  [argInteraction, valInteraction]: Readonly<[Interaction, Interaction]>, type: Interaction,\n  deltas: Readonly<[number, number]> | null,\n  anchors: Readonly<number[]> | null,\n  ranges: Readonly<[NumberArray, NumberArray]> | null,\n  viewport?: Viewport, onViewportChange?: OnViewportChangeFn,\n) => {\n  const argIndex = Number(rotated);\n  const valIndex = 1 - argIndex;\n  const changes: any = {};\n  const argumentBounds = boundsForScale(\n    ARGUMENT_DOMAIN, scales, getArgumentBounds(viewport),\n    argInteraction, type,\n    deltas ? deltas[argIndex] : 0, anchors ? anchors[argIndex] : 0,\n    ranges ? ranges[argIndex] : undefined,\n  );\n  const valueBounds = boundsForScale(\n    getValueScaleName(viewport), scales, getValueBounds(viewport),\n    valInteraction, type,\n    deltas ? deltas[valIndex] : 0, anchors ? anchors[valIndex] : 0,\n    ranges ? ranges[valIndex] : undefined,\n  );\n  if (argumentBounds) {\n    changes.argumentStart = argumentBounds[0];\n    changes.argumentEnd = argumentBounds[1];\n  }\n  if (valueBounds) {\n    changes.valueStart = valueBounds[0];\n    changes.valueEnd = valueBounds[1];\n  }\n  if (Object.keys(changes).length) {\n    const newViewport = { ...viewport, ...changes };\n    if (onViewportChange) {\n      onViewportChange(newViewport);\n    }\n    return { viewport: newViewport };\n  }\n  return null;\n};\n\n/** @internal */\nexport const getDeltaForTouches = (touches: Touch[]) => {\n  const deltaX = touches[0].pageX - touches[1].pageX;\n  const deltaY = touches[0].pageY - touches[1].pageY;\n  const delta = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n  const center: NumberArray = [\n    (touches[0].pageX + touches[1].pageX) / 2,\n    (touches[0].pageY + touches[1].pageY) / 2,\n  ];\n  return { delta, center };\n};\n\n/** @internal */\nexport const isKeyPressed = (event: MouseEvent, key: string) => event[`${key}Key`];\n\n/** @internal */\nexport const getWheelDelta = ({ wheelDelta, deltaY }: { wheelDelta?: number, deltaY?: number }) => {\n  return wheelDelta !== undefined ? wheelDelta : deltaY! * -30; // deltaY for FF\n};\n\n/** @internal */\nexport const isMultiTouch = (e: any) => e.touches && e.touches.length === 2;\n\n/** @internal */\nexport const attachEvents = (node: any, handlers: EventHandlers) => {\n  Object.keys(handlers).forEach((el) => {\n    node.addEventListener(el, handlers[el], { passive: false });\n  });\n};\n\n/** @internal */\nexport const detachEvents = (node: any, handlers: EventHandlers) => {\n  Object.keys(handlers).forEach((el) => {\n    node.removeEventListener(el, handlers[el]);\n  });\n};\n\n/** @internal */\nexport const getRect = (\n  rotated: boolean,\n  interactionWithArguments: Interaction,\n  interactionWithValues: Interaction,\n  initial: Location,\n  current: Location,\n  pane: Size,\n) => {\n  const isZoomArgument = checkInteraction(interactionWithArguments, 'zoom');\n  const isZoomValue = checkInteraction(interactionWithValues, 'zoom');\n  const isXFixed = rotated ? isZoomValue : isZoomArgument;\n  const isYFixed = rotated ? isZoomArgument : isZoomValue;\n  const x = isXFixed ? Math.min(initial[0], current[0]) : 0;\n  const width = isXFixed ? Math.abs(initial[0] - current[0]) : pane.width;\n  const y = isYFixed ? Math.min(initial[1], current[1]) : 0;\n  const height = isYFixed ? Math.abs(initial[1] - current[1]) : pane.height;\n  return {\n    x, y, width, height,\n  };\n};\n\nconst checkInteraction = (interaction: Interaction, type: Interaction) =>\ninteraction === 'both' || interaction === type;\n\n/** @internal */\nexport const setCursorType = (node: any, type?: string) => {\n  const defaultType = 'pointer';\n  node.style.cursor = type ? type : defaultType;\n};\n","import { DIFFERENCE } from '../../constants';\n\n/** @internal */\nexport const isReadyToRenderSeries = (\n  { pane, ...restLayouts }, { current },\n  isPreviousDataEmpty: boolean, axesExist: boolean,\n) => {\n  if (!pane.width && !pane.height) {\n    return false;\n  }\n\n  const bbox = current.getBoundingClientRect();\n  let width = pane.width;\n  let height = pane.height;\n  Object.entries(restLayouts).forEach((el) => {\n    if (el[0].includes('top') || el[0].includes('bottom')) {\n      height += el[1].height;\n    } else {\n      width += el[1].width;\n    }\n  });\n  return Math.abs(bbox.width - width) < DIFFERENCE &&\n    Math.abs(bbox.height - height) < DIFFERENCE\n    && isPreviousDataEmptyOrNoAxes(isPreviousDataEmpty, axesExist);\n};\n\nconst isPreviousDataEmptyOrNoAxes = (\n  isPreviousDataEmpty: boolean, axesExist: boolean,\n) => !isPreviousDataEmpty || !axesExist;\n","import { area } from 'd3-shape';\nimport {\n  dArea, dRotateArea, dLine, dRotateLine, dSpline, dRotateSpline,\n} from '../plugins/series/computeds';\nimport {\n  SeriesList, TransformedPoint, PointList, TargetList, PointDistance, Location,\n  CreateHitTesterFn, MakePathFn, IsPointInPathFn,\n  HitTestPointFn, Filter,\n  BarSeries, ScatterSeries, PieSeries,\n  PathFn,\n} from '../types';\n\nconst getSegmentLength = (dx: number, dy: number) => Math.sqrt(dx * dx + dy * dy);\n\n// *distance* is a normalized distance to point.\n// It belongs to [0, Infinity):\n//  = 0 - at point center\n//  = 1 - at point border\n//  > 1 - outside point\n\n// This function is called from event handlers (when DOM is available) -\n// *window.document* can be accessed safely.\nconst createContext = () => document.createElement('canvas').getContext('2d')!;\n\n// For a start using browser canvas will suffice.\n// However a better and more clean solution should be found.\n// Can't d3 perform hit testing?\nconst createCanvasAbusingHitTester = (\n  makePath: MakePathFn, points: PointList, rotated: boolean,\n): IsPointInPathFn => {\n  const ctx = createContext();\n  const path = makePath(rotated);\n  path.context(ctx);\n  path(points as any);\n  return ([x, y]) => ctx.isPointInPath(x, y);\n};\n\nconst LINE_POINT_SIZE = 20;\nconst LINE_TOLERANCE = 10;\n\nconst getDistance = (\n  [px, py]: Location, { arg, val }: TransformedPoint, rotated: boolean,\n) => {\n  const x = rotated ? val : arg;\n  const y = rotated ? arg : val;\n  return getSegmentLength(px - x, py - y);\n};\n\nconst createContinuousSeriesHitTesterCreator =\n  (makePath: MakePathFn): CreateHitTesterFn => (points, rotated) => {\n    const fallbackHitTest = createCanvasAbusingHitTester(makePath, points, rotated);\n    return (target) => {\n      let minDistance = Number.MAX_VALUE;\n      let minIndex: number = 0;\n      const list: PointDistance[] = [];\n      points.forEach((point, i) => {\n        const distance = getDistance(target, point as TransformedPoint, rotated);\n        if (distance <= LINE_POINT_SIZE) {\n          list.push({ distance, index: point.index });\n        }\n        if (distance < minDistance) {\n          minDistance = distance;\n          minIndex = i;\n        }\n      });\n      // This is special case for continuous series - if no point is actually hit\n      // then the closest point to the pointer position is picked.\n      if (!list.length && fallbackHitTest(target)) {\n        list.push({ index: points[minIndex].index, distance: minDistance });\n      }\n      return list.length ? { points: list } : null;\n    };\n  };\n\nconst createPointsEnumeratingHitTesterCreator =\n  (hitTestPoint: HitTestPointFn): CreateHitTesterFn => (points, rotated) => (target) => {\n    const list: PointDistance[] = [];\n    points.forEach((point) => {\n      const status = hitTestPoint(target, point as TransformedPoint, rotated);\n      if (status) {\n        list.push({ index: point.index, distance: status.distance });\n      }\n    });\n    return list.length ? { points: list } : null;\n  };\n\n/** @internal */\nexport const createAreaHitTester = createContinuousSeriesHitTesterCreator((rotated) => {\n  const path: PathFn = area() as any;\n  const hitArea = rotated ? dRotateArea : dArea;\n  if (rotated) {\n    path.x1!(hitArea.x1!());\n    path.x0!(hitArea.x0!());\n    path.y(hitArea.y());\n  } else {\n    path.x(hitArea.x());\n    path.y1!(hitArea.y1!());\n    path.y0!(hitArea.y0!());\n  }\n  return path;\n});\n\n/** @internal */\nexport const createLineHitTester = createContinuousSeriesHitTesterCreator((rotated) => {\n  const path: PathFn = area() as any;\n  const hitLine = rotated ? dRotateLine : dLine;\n  if (rotated) {\n    const getX = hitLine.x();\n    path.y(hitLine.y());\n    path.x0!(point => getX(point) + LINE_TOLERANCE);\n    path.x1!(point => getX(point) - LINE_TOLERANCE);\n  } else {\n    const getY = hitLine.y();\n    path.x(hitLine.x());\n    path.y1!(point => getY(point) - LINE_TOLERANCE);\n    path.y0!(point => getY(point) + LINE_TOLERANCE);\n  }\n  return path;\n});\n\n/** @internal */\nexport const createSplineHitTester = createContinuousSeriesHitTesterCreator((rotated) => {\n  const path: PathFn = area() as any;\n  const hitSpline = rotated ? dRotateSpline : dSpline;\n  if (rotated) {\n    const getX = hitSpline.x();\n    path.y(hitSpline.y());\n    path.x1!(point => getX(point) - LINE_TOLERANCE);\n    path.x0!(point => getX(point) + LINE_TOLERANCE);\n  } else {\n    const getY = hitSpline.y();\n    path.x(hitSpline.x());\n    path.y1!(point => getY(point) - LINE_TOLERANCE);\n    path.y0!(point => getY(point) + LINE_TOLERANCE);\n  }\n  path.curve!(hitSpline.curve!());\n  return path;\n});\n\nconst hitTestRect = (dx: number, dy: number, halfX: number, halfY: number) => (\n  Math.abs(dx) <= halfX && Math.abs(dy) <= halfY ? {\n    distance: getSegmentLength(dx, dy),\n  } : null\n);\n\n// Some kind of binary search can be used here as bars can be ordered along argument axis.\n/** @internal */\nexport const createBarHitTester = createPointsEnumeratingHitTesterCreator(\n  ([px, py], point, rotated) => {\n    const {\n      arg, val, startVal, barWidth, maxBarWidth,\n    } = point as BarSeries.PointProps;\n    const halfWidth = maxBarWidth * barWidth / 2;\n    const halfHeight = Math.abs(val - startVal!) / 2;\n    const centerVal = (val + startVal!) / 2;\n    const xCenter = rotated ? centerVal : arg;\n    const yCenter = rotated ? arg : centerVal;\n    return hitTestRect(\n      px - xCenter,\n      py - yCenter,\n      rotated ? halfHeight : halfWidth,\n      rotated ? halfWidth : halfHeight,\n    );\n  },\n);\n\n/** @internal */\nexport const createScatterHitTester = createPointsEnumeratingHitTesterCreator(\n  ([px, py], obj, rotated) => {\n    const { point } = obj as ScatterSeries.PointProps;\n    const distance = getDistance([px, py], obj, rotated);\n    return distance <= point.size / 2 ? { distance } : null;\n  },\n);\n\nconst mapAngleTod3 = (angle: number) => {\n  const ret = angle + Math.PI / 2;\n  return ret >= 0 ? ret : ret + Math.PI * 2;\n};\n\n// Some kind of binary search can be used here as pies can be ordered along angle axis.\n/** @internal */\nexport const createPieHitTester = createPointsEnumeratingHitTesterCreator(\n  ([px, py], point) => {\n    const {\n      arg: x, val: y, innerRadius, outerRadius, startAngle, maxRadius, endAngle,\n    } = point as PieSeries.PointProps;\n    const inner = innerRadius * maxRadius;\n    const outer = outerRadius * maxRadius;\n    const rCenter = (inner + outer) / 2;\n    const angleCenter = (startAngle + endAngle) / 2;\n    const halfRadius = (outer - inner) / 2;\n    const halfAngle = Math.abs(startAngle - endAngle) / 2;\n    const dx = px - x;\n    const dy = py - y;\n    const r = getSegmentLength(dx, dy);\n    const angle = mapAngleTod3(Math.atan2(dy, dx));\n    // This is not a correct distance calculation but for now it will suffice.\n    // For Pie series it would not be actually used.\n    return hitTestRect(r - rCenter, angle - angleCenter, halfRadius, halfAngle);\n  },\n);\n\nconst buildFilter = (targets: TargetList): Filter => {\n  const result = {};\n  targets.forEach(({ series, point }) => {\n    (result[series] = result[series] || new Set()).add(point);\n  });\n  return result;\n};\n\n/** @internal */\nexport const changeSeriesState = (seriesList: SeriesList, targets: TargetList, state: string) => {\n  if (targets.length === 0) {\n    return seriesList;\n  }\n  const filter = buildFilter(targets);\n  let matches = 0;\n  const result = seriesList.map((seriesItem) => {\n    const set = filter[seriesItem.name];\n    if (!set) {\n      return seriesItem;\n    }\n    matches += 1;\n    const props: { state: string, points?: TransformedPoint[] } = { state };\n    if (set.size) {\n      props.points = (seriesItem.points as TransformedPoint[]).map(\n        point => (set.has(point.index) ? { ...point, state } : point),\n      );\n    }\n    return { ...seriesItem, ...props };\n  });\n  // This is to prevent false rerenders.\n  return matches > 0 ? result : seriesList;\n};\n","import { SeriesList, LegendItemList } from '../types';\n\nconst getDefaultLegendItems = (series: SeriesList): LegendItemList => series.map(\n  ({ name: text, color }) => ({ text, color }),\n);\n\nconst getPieLegendItems = (series: SeriesList): LegendItemList => series[0]\n  .points.map(({ argument: text, color }) => ({ text, color }));\n\n// The function supports special case when there is single Pie series.\n// There is no common way to tell if series is PieSeries -\n// checking `radius` props will suffice for now.\nconst isSinglePieSeriesCase = (series: SeriesList) => (\n  series.length === 1 && 'innerRadius' in series[0] && 'outerRadius' in series[0]\n);\n\n/** @internal */\nexport const getLegendItems = (series: SeriesList) => (\n  (isSinglePieSeriesCase(series) ? getPieLegendItems : getDefaultLegendItems)(series)\n);\n","import { hasWindow } from '@devexpress/dx-core';\nimport { getEventCoords, getOffset } from './common';\nimport {\n  TrackerTarget, HandlerFnList, SeriesList, HitTesters,\n  EventHandlerFn, TargetData, EventHandlers, HandlersObject,\n} from '../types';\n\nconst DISTANCE_THRESHOLD = 20;\n\nconst compareHitTargets = (t1: TrackerTarget, t2: TrackerTarget) => {\n  const distanceDelta = t1.distance - t2.distance;\n  if (Math.abs(distanceDelta) <= DISTANCE_THRESHOLD) {\n    const orderDelta = t2.order - t1.order;\n    return orderDelta !== 0 ? orderDelta : distanceDelta;\n  }\n  return distanceDelta;\n};\n\nconst buildEventHandler = (seriesList: SeriesList, handlers: HandlerFnList): EventHandlerFn => {\n  let hitTesters: HitTesters | null = null;\n\n  const createHitTesters = () => {\n    const obj: HitTesters = {};\n    seriesList.forEach((seriesItem) => {\n      obj[seriesItem.symbolName as unknown as string] = seriesItem\n      .createHitTester(seriesItem.points, seriesItem.rotated);\n    });\n    return obj;\n  };\n\n  return (e) => {\n    const location = getEventCoords(e, getOffset(e.currentTarget));\n    hitTesters = hitTesters || createHitTesters();\n    const targets: TrackerTarget[] = [];\n    seriesList.forEach(({ name: series, index: order, symbolName }) => {\n      const status = hitTesters![symbolName as unknown as string](location);\n      if (status) {\n        targets.push(...status.points.map(\n          point => ({\n            series, order, point: point.index, distance: point.distance,\n          }),\n        ));\n      }\n    });\n    targets.sort(compareHitTargets);\n    const arg: TargetData = { location, targets, event: e.nativeEvent };\n    handlers.forEach(handler => handler(arg));\n  };\n};\n\nconst buildLeaveEventHandler = (handlers: HandlerFnList): EventHandlerFn => (e) => {\n  const location = getEventCoords(e, getOffset(e.currentTarget));\n  const arg: TargetData = { location, targets: [] };\n  handlers.forEach(handler => handler(arg));\n};\n\n// The result is of Map<string, Function> type.\n// Keys are DOM event names (https://developer.mozilla.org/en-US/docs/Web/Events).\n/** @internal */\nexport const buildEventHandlers = (\n  seriesList: SeriesList, { clickHandlers, pointerMoveHandlers }: HandlersObject,\n) => {\n  const handlers: EventHandlers = {};\n  if (!hasWindow()) return handlers;\n  if (clickHandlers.length) {\n    handlers.click = buildEventHandler(seriesList, clickHandlers);\n  }\n  if (pointerMoveHandlers.length) {\n    const moveHandler = buildEventHandler(seriesList, pointerMoveHandlers);\n    const leaveHandler = buildLeaveEventHandler(pointerMoveHandlers);\n    if ('ontouchstart' in window) {\n      handlers.touchstart = moveHandler;\n    } else {\n      handlers.mousemove = moveHandler;\n      handlers.mouseleave = leaveHandler;\n    }\n  }\n  return handlers;\n};\n","import {\n  EasingFn, SetAttributeFn, AnimationFn, GetNewPositionsFn,\n  RangePointCoordinates, PointCoordinates, PointComponentProps,\n  PieCoordinates, PathStartCoordinates, PathEndCoordinates,\n} from '../types';\n\n/** @internal */\nconst getProgress = ({ elapsed, total }: {elapsed: number, total: number}) =>\nMath.min(elapsed / total, 1);\n\n/** @internal */\nconst runAnimation = (\n  setAttributes: SetAttributeFn,\n  getNewPositions: GetNewPositionsFn,\n  easing: EasingFn, duration: number, delay: number,\n) => new Promise((resolve) => {\n  setTimeout(() => {\n    const time = {\n      start: Date.now(),\n      total: duration,\n      elapsed: 0,\n    };\n    const step = () => {\n      time.elapsed = Date.now() - time.start;\n      const progress = getProgress(time);\n      setAttributes(getNewPositions(easing(progress)));\n\n      if (progress < 1) requestAnimationFrame(step);\n    };\n    resolve(requestAnimationFrame(step));\n  }, delay);\n});\n\n/** @internal */\nexport const buildAnimation = (easing: EasingFn, duration: number): AnimationFn => (\n  startCoords, endCoords, processAnimation, setAttributes, delay = 0,\n) => {\n  let animationID;\n\n  const stop = () => {\n    if (animationID) {\n      cancelAnimationFrame(animationID);\n      animationID = undefined;\n    }\n  };\n\n  const run = (start, end, delayValue) => {\n    animationID = runAnimation(\n      setAttributes, processAnimation(start, end),\n      easing, duration, delayValue,\n    ).then((res) => {\n      animationID = res;\n    });\n  };\n\n  run(startCoords, endCoords, delay);\n\n  return {\n    update: (updatedStartCoords, updatedEndCoords, updatedDelay = 0) => {\n      stop();\n      run(updatedStartCoords, updatedEndCoords, updatedDelay);\n    },\n    stop,\n  };\n};\n\nconst lerp = (a: number, b: number, t: number) => a + t * (b - a);\n\n/** @internal */\nexport const processPointAnimation = (\n  startCoords: PointCoordinates, endCoords: PointComponentProps,\n) => {\n  return (progress: number) => {\n    return {\n      arg: lerp(startCoords.arg, endCoords.arg, progress),\n      val: lerp(startCoords.val, endCoords.val, progress),\n    };\n  };\n};\n\n/** @internal */\nexport const processBarAnimation = (\n  startCoords: RangePointCoordinates, endCoords: PointComponentProps,\n) => {\n  return (progress: number) => {\n    return {\n      arg: lerp(startCoords.arg, endCoords.arg, progress),\n      val: lerp(startCoords.val, endCoords.val, progress),\n      startVal: lerp(startCoords.startVal, endCoords.startVal, progress),\n    };\n  };\n};\n\n/** @internal */\nexport const processLineAnimation = (\n  { coordinates }: PathStartCoordinates,\n  { coordinates: endCoordinates }: PathEndCoordinates,\n) => {\n  return (progress: number) => {\n    return {\n      coordinates: endCoordinates.map((coord, index) => {\n        const startCurCoord = coordinates[index];\n        return {\n          ...coord,\n          arg: lerp(startCurCoord.arg, coord.arg, progress),\n          val: lerp(startCurCoord.val, coord.val, progress),\n        };\n      }),\n    };\n  };\n};\n\n/** @internal */\nexport const processAreaAnimation = (\n  { coordinates }: PathStartCoordinates,\n  { coordinates: endCoordinates }: PathEndCoordinates,\n) => {\n  return (progress: number) => {\n    return {\n      coordinates: endCoordinates.map((coord, index) => {\n        const startCurCoord = coordinates[index];\n        return {\n          ...coord,\n          arg: lerp(startCurCoord.arg, coord.arg, progress),\n          val: lerp(startCurCoord.val, coord.val, progress),\n          startVal: lerp(startCurCoord.startVal, coord.startVal, progress),\n        };\n      }),\n    };\n  };\n};\n\n/** @internal */\nexport const processPieAnimation = (start: PieCoordinates, end: PieCoordinates) => {\n  return (progress: number) => {\n    return {\n      innerRadius: lerp(start.innerRadius, end.innerRadius, progress),\n      outerRadius: lerp(start.outerRadius, end.outerRadius, progress),\n      startAngle: lerp(start.startAngle, end.startAngle, progress),\n      endAngle: lerp(start.endAngle, end.endAngle, progress),\n    };\n  };\n};\n"]},"metadata":{},"sourceType":"module"}