{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/bar_series.js)\r\n * Version: 20.2.3\r\n * Build date: Tue Oct 20 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (\"function\" === typeof Symbol && \"symbol\" === typeof Symbol.iterator) {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && \"function\" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nexports.polar = exports.chart = void 0;\n\nvar _extend2 = require(\"../../core/utils/extend\");\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar scatterSeries = _interopRequireWildcard(require(\"./scatter_series\"));\n\nvar _area_series = require(\"./area_series\");\n\nvar _utils = require(\"../core/utils\");\n\nvar _type = require(\"../../core/utils/type\");\n\nfunction _getRequireWildcardCache() {\n  if (\"function\" !== typeof WeakMap) {\n    return null;\n  }\n\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (null === obj || \"object\" !== _typeof(obj) && \"function\" !== typeof obj) {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar areaSeries = _area_series.chart.area;\nvar chartSeries = scatterSeries.chart;\nvar polarSeries = scatterSeries.polar;\nvar _extend = _extend2.extend;\nvar _each = _iterator.each;\nvar chart = {};\nexports.chart = chart;\nvar polar = {};\nexports.polar = polar;\nvar baseBarSeriesMethods = {\n  _createLegendState: function (styleOptions, defaultColor) {\n    return {\n      fill: styleOptions.color || defaultColor,\n      hatching: styleOptions.hatching\n    };\n  },\n  _parsePointStyle: function (style, defaultColor, defaultBorderColor) {\n    var color = style.color || defaultColor;\n\n    var base = chartSeries._parsePointStyle.call(this, style, color, defaultBorderColor);\n\n    base.fill = color;\n    base.hatching = style.hatching;\n    base.dashStyle = style.border && style.border.dashStyle || \"solid\";\n    delete base.r;\n    return base;\n  },\n  _applyMarkerClipRect: function (settings) {\n    settings[\"clip-path\"] = null;\n  },\n  _setGroupsSettings: function (animationEnabled, firstDrawing) {\n    var that = this;\n    var settings = {};\n\n    chartSeries._setGroupsSettings.apply(that, arguments);\n\n    if (animationEnabled && firstDrawing) {\n      settings = this._getAffineCoordOptions();\n    } else {\n      if (!animationEnabled) {\n        settings = {\n          scaleX: 1,\n          scaleY: 1,\n          translateX: 0,\n          translateY: 0\n        };\n      }\n    }\n\n    that._markersGroup.attr(settings);\n  },\n  _drawPoint: function (options) {\n    options.hasAnimation = options.hasAnimation && !options.firstDrawing;\n    options.firstDrawing = false;\n\n    chartSeries._drawPoint.call(this, options);\n  },\n  _getMainColor: function () {\n    return this._options.mainSeriesColor;\n  },\n  _createPointStyles: function (pointOptions) {\n    var that = this;\n\n    var mainColor = pointOptions.color || that._getMainColor();\n\n    return {\n      normal: that._parsePointStyle(pointOptions, mainColor, mainColor),\n      hover: that._parsePointStyle(pointOptions.hoverStyle || {}, mainColor, mainColor),\n      selection: that._parsePointStyle(pointOptions.selectionStyle || {}, mainColor, mainColor)\n    };\n  },\n  _updatePointsVisibility: function () {\n    var visibility = this._options.visible;\n    (0, _iterator.each)(this._points, function (_, point) {\n      point._options.visible = visibility;\n    });\n  },\n  _getOptionsForPoint: function () {\n    return this._options;\n  },\n  _animate: function (firstDrawing) {\n    var that = this;\n\n    var complete = function () {\n      that._animateComplete();\n    };\n\n    var animateFunc = function (drawnPoints, complete) {\n      var lastPointIndex = drawnPoints.length - 1;\n\n      _each(drawnPoints || [], function (i, point) {\n        point.animate(i === lastPointIndex ? complete : void 0, point.getMarkerCoords());\n      });\n    };\n\n    that._animatePoints(firstDrawing, complete, animateFunc);\n  },\n  getValueRangeInitialValue: areaSeries.getValueRangeInitialValue,\n  _patchMarginOptions: function (options) {\n    options.checkInterval = true;\n    return options;\n  },\n  _defaultAggregator: \"sum\",\n  _defineDrawingState: function () {},\n  usePointsToDefineAutoHiding: function () {\n    return false;\n  }\n};\nchart.bar = _extend({}, chartSeries, baseBarSeriesMethods, {\n  _getAffineCoordOptions: function () {\n    var rotated = this._options.rotated;\n    var direction = rotated ? \"X\" : \"Y\";\n    var settings = {\n      scaleX: rotated ? .001 : 1,\n      scaleY: rotated ? 1 : .001\n    };\n    settings[\"translate\" + direction] = this.getValueAxis().getTranslator().translate(\"canvas_position_default\");\n    return settings;\n  },\n  _animatePoints: function (firstDrawing, complete, animateFunc) {\n    var that = this;\n\n    that._markersGroup.animate({\n      scaleX: 1,\n      scaleY: 1,\n      translateY: 0,\n      translateX: 0\n    }, void 0, complete);\n\n    if (!firstDrawing) {\n      animateFunc(that._drawnPoints, complete);\n    }\n  },\n  checkSeriesViewportCoord: function (axis, coord) {\n    if (0 === this._points.length) {\n      return false;\n    }\n\n    if (axis.isArgumentAxis) {\n      return true;\n    }\n\n    var translator = axis.getTranslator();\n    var range = this.getViewport();\n    var min = translator.translate(range.categories ? range.categories[0] : range.min);\n    var max = translator.translate(range.categories ? range.categories[range.categories.length - 1] : range.max);\n    var rotated = this.getOptions().rotated;\n    var inverted = axis.getOptions().inverted;\n    return rotated && !inverted || !rotated && inverted ? coord >= min && coord <= max : coord >= max && coord <= min;\n  },\n  getSeriesPairCoord: function (coord, isArgument) {\n    var oppositeCoord = null;\n    var rotated = this._options.rotated;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = isOpposite ? \"vy\" : \"vx\";\n    var oppositeCoordName = isOpposite ? \"vx\" : \"vy\";\n    var points = this.getPoints();\n\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      var tmpCoord = void 0;\n\n      if (isArgument) {\n        tmpCoord = p.getCenterCoord()[coordName[1]] === coord ? p[oppositeCoordName] : void 0;\n      } else {\n        tmpCoord = p[coordName] === coord ? p[oppositeCoordName] : void 0;\n      }\n\n      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  }\n});\npolar.bar = _extend({}, polarSeries, baseBarSeriesMethods, {\n  _animatePoints: function (firstDrawing, complete, animateFunc) {\n    animateFunc(this._drawnPoints, complete);\n  },\n  _setGroupsSettings: chartSeries._setGroupsSettings,\n  _drawPoint: function (point, groups, animationEnabled) {\n    chartSeries._drawPoint.call(this, point, groups, animationEnabled);\n  },\n  _parsePointStyle: function (style) {\n    var base = baseBarSeriesMethods._parsePointStyle.apply(this, arguments);\n\n    base.opacity = style.opacity;\n    return base;\n  },\n  _createGroups: chartSeries._createGroups,\n  _setMarkerGroupSettings: function () {\n    var that = this;\n\n    var markersSettings = that._createPointStyles(that._getMarkerGroupOptions()).normal;\n\n    markersSettings.class = \"dxc-markers\";\n\n    that._applyMarkerClipRect(markersSettings);\n\n    var groupSettings = _extend({}, markersSettings);\n\n    delete groupSettings.opacity;\n\n    that._markersGroup.attr(groupSettings);\n  },\n  getSeriesPairCoord: function (params, isArgument) {\n    var coords = null;\n    var paramName = isArgument ? \"argument\" : \"radius\";\n    var points = this.getVisiblePoints();\n    var argAxis = this.getArgumentAxis();\n    var startAngle = argAxis.getAngles()[0];\n\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      var tmpPoint = (0, _type.isDefined)(p[paramName]) && (0, _type.isDefined)(params[paramName]) && p[paramName].valueOf() === params[paramName].valueOf() ? (0, _utils.convertPolarToXY)(argAxis.getCenter(), startAngle, -argAxis.getTranslatedAngle(p.angle), p.radius) : void 0;\n\n      if ((0, _type.isDefined)(tmpPoint)) {\n        coords = tmpPoint;\n        break;\n      }\n    }\n\n    return coords;\n  },\n  _createLegendState: areaSeries._createLegendState\n});","map":{"version":3,"sources":["E:/Monday.com/quickstart-react/node_modules/devextreme/viz/series/bar_series.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","exports","polar","chart","_extend2","require","_iterator","scatterSeries","_interopRequireWildcard","_area_series","_utils","_type","_getRequireWildcardCache","WeakMap","cache","__esModule","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","hasOwnProperty","call","desc","set","default","areaSeries","area","chartSeries","polarSeries","_extend","extend","_each","each","baseBarSeriesMethods","_createLegendState","styleOptions","defaultColor","fill","color","hatching","_parsePointStyle","style","defaultBorderColor","base","dashStyle","border","r","_applyMarkerClipRect","settings","_setGroupsSettings","animationEnabled","firstDrawing","that","apply","arguments","_getAffineCoordOptions","scaleX","scaleY","translateX","translateY","_markersGroup","attr","_drawPoint","options","hasAnimation","_getMainColor","_options","mainSeriesColor","_createPointStyles","pointOptions","mainColor","normal","hover","hoverStyle","selection","selectionStyle","_updatePointsVisibility","visibility","visible","_points","_","point","_getOptionsForPoint","_animate","complete","_animateComplete","animateFunc","drawnPoints","lastPointIndex","length","i","animate","getMarkerCoords","_animatePoints","getValueRangeInitialValue","_patchMarginOptions","checkInterval","_defaultAggregator","_defineDrawingState","usePointsToDefineAutoHiding","bar","rotated","direction","getValueAxis","getTranslator","translate","_drawnPoints","checkSeriesViewportCoord","axis","coord","isArgumentAxis","translator","range","getViewport","min","categories","max","getOptions","inverted","getSeriesPairCoord","isArgument","oppositeCoord","isOpposite","coordName","oppositeCoordName","points","getPoints","p","tmpCoord","getCenterCoord","_checkAxisVisibleAreaCoord","groups","opacity","_createGroups","_setMarkerGroupSettings","markersSettings","_getMarkerGroupOptions","class","groupSettings","params","coords","paramName","getVisiblePoints","argAxis","getArgumentAxis","startAngle","getAngles","tmpPoint","isDefined","valueOf","convertPolarToXY","getCenter","getTranslatedAngle","angle","radius"],"mappings":"AAAA;;;;;;;;AAQA;;AAEA,SAASA,OAAT,CAAiBC,GAAjB,EAAsB;AAClB;;AACA,MAAI,eAAe,OAAOC,MAAtB,IAAgC,aAAa,OAAOA,MAAM,CAACC,QAA/D,EAAyE;AACrEH,IAAAA,OAAO,GAAG,UAASC,GAAT,EAAc;AACpB,aAAO,OAAOA,GAAd;AACH,KAFD;AAGH,GAJD,MAIO;AACHD,IAAAA,OAAO,GAAG,UAASC,GAAT,EAAc;AACpB,aAAOA,GAAG,IAAI,eAAe,OAAOC,MAA7B,IAAuCD,GAAG,CAACG,WAAJ,KAAoBF,MAA3D,IAAqED,GAAG,KAAKC,MAAM,CAACG,SAApF,GAAgG,QAAhG,GAA2G,OAAOJ,GAAzH;AACH,KAFD;AAGH;;AACD,SAAOD,OAAO,CAACC,GAAD,CAAd;AACH;;AACDK,OAAO,CAACC,KAAR,GAAgBD,OAAO,CAACE,KAAR,GAAgB,KAAK,CAArC;;AACA,IAAIC,QAAQ,GAAGC,OAAO,CAAC,yBAAD,CAAtB;;AACA,IAAIC,SAAS,GAAGD,OAAO,CAAC,2BAAD,CAAvB;;AACA,IAAIE,aAAa,GAAGC,uBAAuB,CAACH,OAAO,CAAC,kBAAD,CAAR,CAA3C;;AACA,IAAII,YAAY,GAAGJ,OAAO,CAAC,eAAD,CAA1B;;AACA,IAAIK,MAAM,GAAGL,OAAO,CAAC,eAAD,CAApB;;AACA,IAAIM,KAAK,GAAGN,OAAO,CAAC,uBAAD,CAAnB;;AAEA,SAASO,wBAAT,GAAoC;AAChC,MAAI,eAAe,OAAOC,OAA1B,EAAmC;AAC/B,WAAO,IAAP;AACH;;AACD,MAAIC,KAAK,GAAG,IAAID,OAAJ,EAAZ;;AACAD,EAAAA,wBAAwB,GAAG,YAAW;AAClC,WAAOE,KAAP;AACH,GAFD;;AAGA,SAAOA,KAAP;AACH;;AAED,SAASN,uBAAT,CAAiCZ,GAAjC,EAAsC;AAClC,MAAIA,GAAG,IAAIA,GAAG,CAACmB,UAAf,EAA2B;AACvB,WAAOnB,GAAP;AACH;;AACD,MAAI,SAASA,GAAT,IAAgB,aAAaD,OAAO,CAACC,GAAD,CAApB,IAA6B,eAAe,OAAOA,GAAvE,EAA4E;AACxE,WAAO;AACH,iBAAWA;AADR,KAAP;AAGH;;AACD,MAAIkB,KAAK,GAAGF,wBAAwB,EAApC;;AACA,MAAIE,KAAK,IAAIA,KAAK,CAACE,GAAN,CAAUpB,GAAV,CAAb,EAA6B;AACzB,WAAOkB,KAAK,CAACG,GAAN,CAAUrB,GAAV,CAAP;AACH;;AACD,MAAIsB,MAAM,GAAG,EAAb;AACA,MAAIC,qBAAqB,GAAGC,MAAM,CAACC,cAAP,IAAyBD,MAAM,CAACE,wBAA5D;;AACA,OAAK,IAAIC,GAAT,IAAgB3B,GAAhB,EAAqB;AACjB,QAAIwB,MAAM,CAACpB,SAAP,CAAiBwB,cAAjB,CAAgCC,IAAhC,CAAqC7B,GAArC,EAA0C2B,GAA1C,CAAJ,EAAoD;AAChD,UAAIG,IAAI,GAAGP,qBAAqB,GAAGC,MAAM,CAACE,wBAAP,CAAgC1B,GAAhC,EAAqC2B,GAArC,CAAH,GAA+C,IAA/E;;AACA,UAAIG,IAAI,KAAKA,IAAI,CAACT,GAAL,IAAYS,IAAI,CAACC,GAAtB,CAAR,EAAoC;AAChCP,QAAAA,MAAM,CAACC,cAAP,CAAsBH,MAAtB,EAA8BK,GAA9B,EAAmCG,IAAnC;AACH,OAFD,MAEO;AACHR,QAAAA,MAAM,CAACK,GAAD,CAAN,GAAc3B,GAAG,CAAC2B,GAAD,CAAjB;AACH;AACJ;AACJ;;AACDL,EAAAA,MAAM,CAACU,OAAP,GAAiBhC,GAAjB;;AACA,MAAIkB,KAAJ,EAAW;AACPA,IAAAA,KAAK,CAACa,GAAN,CAAU/B,GAAV,EAAesB,MAAf;AACH;;AACD,SAAOA,MAAP;AACH;;AACD,IAAIW,UAAU,GAAGpB,YAAY,CAACN,KAAb,CAAmB2B,IAApC;AACA,IAAIC,WAAW,GAAGxB,aAAa,CAACJ,KAAhC;AACA,IAAI6B,WAAW,GAAGzB,aAAa,CAACL,KAAhC;AACA,IAAI+B,OAAO,GAAG7B,QAAQ,CAAC8B,MAAvB;AACA,IAAIC,KAAK,GAAG7B,SAAS,CAAC8B,IAAtB;AACA,IAAIjC,KAAK,GAAG,EAAZ;AACAF,OAAO,CAACE,KAAR,GAAgBA,KAAhB;AACA,IAAID,KAAK,GAAG,EAAZ;AACAD,OAAO,CAACC,KAAR,GAAgBA,KAAhB;AACA,IAAImC,oBAAoB,GAAG;AACvBC,EAAAA,kBAAkB,EAAE,UAASC,YAAT,EAAuBC,YAAvB,EAAqC;AACrD,WAAO;AACHC,MAAAA,IAAI,EAAEF,YAAY,CAACG,KAAb,IAAsBF,YADzB;AAEHG,MAAAA,QAAQ,EAAEJ,YAAY,CAACI;AAFpB,KAAP;AAIH,GANsB;AAOvBC,EAAAA,gBAAgB,EAAE,UAASC,KAAT,EAAgBL,YAAhB,EAA8BM,kBAA9B,EAAkD;AAChE,QAAIJ,KAAK,GAAGG,KAAK,CAACH,KAAN,IAAeF,YAA3B;;AACA,QAAIO,IAAI,GAAGhB,WAAW,CAACa,gBAAZ,CAA6BnB,IAA7B,CAAkC,IAAlC,EAAwCoB,KAAxC,EAA+CH,KAA/C,EAAsDI,kBAAtD,CAAX;;AACAC,IAAAA,IAAI,CAACN,IAAL,GAAYC,KAAZ;AACAK,IAAAA,IAAI,CAACJ,QAAL,GAAgBE,KAAK,CAACF,QAAtB;AACAI,IAAAA,IAAI,CAACC,SAAL,GAAiBH,KAAK,CAACI,MAAN,IAAgBJ,KAAK,CAACI,MAAN,CAAaD,SAA7B,IAA0C,OAA3D;AACA,WAAOD,IAAI,CAACG,CAAZ;AACA,WAAOH,IAAP;AACH,GAfsB;AAgBvBI,EAAAA,oBAAoB,EAAE,UAASC,QAAT,EAAmB;AACrCA,IAAAA,QAAQ,CAAC,WAAD,CAAR,GAAwB,IAAxB;AACH,GAlBsB;AAmBvBC,EAAAA,kBAAkB,EAAE,UAASC,gBAAT,EAA2BC,YAA3B,EAAyC;AACzD,QAAIC,IAAI,GAAG,IAAX;AACA,QAAIJ,QAAQ,GAAG,EAAf;;AACArB,IAAAA,WAAW,CAACsB,kBAAZ,CAA+BI,KAA/B,CAAqCD,IAArC,EAA2CE,SAA3C;;AACA,QAAIJ,gBAAgB,IAAIC,YAAxB,EAAsC;AAClCH,MAAAA,QAAQ,GAAG,KAAKO,sBAAL,EAAX;AACH,KAFD,MAEO;AACH,UAAI,CAACL,gBAAL,EAAuB;AACnBF,QAAAA,QAAQ,GAAG;AACPQ,UAAAA,MAAM,EAAE,CADD;AAEPC,UAAAA,MAAM,EAAE,CAFD;AAGPC,UAAAA,UAAU,EAAE,CAHL;AAIPC,UAAAA,UAAU,EAAE;AAJL,SAAX;AAMH;AACJ;;AACDP,IAAAA,IAAI,CAACQ,aAAL,CAAmBC,IAAnB,CAAwBb,QAAxB;AACH,GApCsB;AAqCvBc,EAAAA,UAAU,EAAE,UAASC,OAAT,EAAkB;AAC1BA,IAAAA,OAAO,CAACC,YAAR,GAAuBD,OAAO,CAACC,YAAR,IAAwB,CAACD,OAAO,CAACZ,YAAxD;AACAY,IAAAA,OAAO,CAACZ,YAAR,GAAuB,KAAvB;;AACAxB,IAAAA,WAAW,CAACmC,UAAZ,CAAuBzC,IAAvB,CAA4B,IAA5B,EAAkC0C,OAAlC;AACH,GAzCsB;AA0CvBE,EAAAA,aAAa,EAAE,YAAW;AACtB,WAAO,KAAKC,QAAL,CAAcC,eAArB;AACH,GA5CsB;AA6CvBC,EAAAA,kBAAkB,EAAE,UAASC,YAAT,EAAuB;AACvC,QAAIjB,IAAI,GAAG,IAAX;;AACA,QAAIkB,SAAS,GAAGD,YAAY,CAAC/B,KAAb,IAAsBc,IAAI,CAACa,aAAL,EAAtC;;AACA,WAAO;AACHM,MAAAA,MAAM,EAAEnB,IAAI,CAACZ,gBAAL,CAAsB6B,YAAtB,EAAoCC,SAApC,EAA+CA,SAA/C,CADL;AAEHE,MAAAA,KAAK,EAAEpB,IAAI,CAACZ,gBAAL,CAAsB6B,YAAY,CAACI,UAAb,IAA2B,EAAjD,EAAqDH,SAArD,EAAgEA,SAAhE,CAFJ;AAGHI,MAAAA,SAAS,EAAEtB,IAAI,CAACZ,gBAAL,CAAsB6B,YAAY,CAACM,cAAb,IAA+B,EAArD,EAAyDL,SAAzD,EAAoEA,SAApE;AAHR,KAAP;AAKH,GArDsB;AAsDvBM,EAAAA,uBAAuB,EAAE,YAAW;AAChC,QAAIC,UAAU,GAAG,KAAKX,QAAL,CAAcY,OAA/B;AACA,KAAC,GAAG5E,SAAS,CAAC8B,IAAd,EAAoB,KAAK+C,OAAzB,EAAkC,UAASC,CAAT,EAAYC,KAAZ,EAAmB;AACjDA,MAAAA,KAAK,CAACf,QAAN,CAAeY,OAAf,GAAyBD,UAAzB;AACH,KAFD;AAGH,GA3DsB;AA4DvBK,EAAAA,mBAAmB,EAAE,YAAW;AAC5B,WAAO,KAAKhB,QAAZ;AACH,GA9DsB;AA+DvBiB,EAAAA,QAAQ,EAAE,UAAShC,YAAT,EAAuB;AAC7B,QAAIC,IAAI,GAAG,IAAX;;AACA,QAAIgC,QAAQ,GAAG,YAAW;AACtBhC,MAAAA,IAAI,CAACiC,gBAAL;AACH,KAFD;;AAGA,QAAIC,WAAW,GAAG,UAASC,WAAT,EAAsBH,QAAtB,EAAgC;AAC9C,UAAII,cAAc,GAAGD,WAAW,CAACE,MAAZ,GAAqB,CAA1C;;AACA1D,MAAAA,KAAK,CAACwD,WAAW,IAAI,EAAhB,EAAoB,UAASG,CAAT,EAAYT,KAAZ,EAAmB;AACxCA,QAAAA,KAAK,CAACU,OAAN,CAAcD,CAAC,KAAKF,cAAN,GAAuBJ,QAAvB,GAAkC,KAAK,CAArD,EAAwDH,KAAK,CAACW,eAAN,EAAxD;AACH,OAFI,CAAL;AAGH,KALD;;AAMAxC,IAAAA,IAAI,CAACyC,cAAL,CAAoB1C,YAApB,EAAkCiC,QAAlC,EAA4CE,WAA5C;AACH,GA3EsB;AA4EvBQ,EAAAA,yBAAyB,EAAErE,UAAU,CAACqE,yBA5Ef;AA6EvBC,EAAAA,mBAAmB,EAAE,UAAShC,OAAT,EAAkB;AACnCA,IAAAA,OAAO,CAACiC,aAAR,GAAwB,IAAxB;AACA,WAAOjC,OAAP;AACH,GAhFsB;AAiFvBkC,EAAAA,kBAAkB,EAAE,KAjFG;AAkFvBC,EAAAA,mBAAmB,EAAE,YAAW,CAAE,CAlFX;AAmFvBC,EAAAA,2BAA2B,EAAE,YAAW;AACpC,WAAO,KAAP;AACH;AArFsB,CAA3B;AAuFApG,KAAK,CAACqG,GAAN,GAAYvE,OAAO,CAAC,EAAD,EAAKF,WAAL,EAAkBM,oBAAlB,EAAwC;AACvDsB,EAAAA,sBAAsB,EAAE,YAAW;AAC/B,QAAI8C,OAAO,GAAG,KAAKnC,QAAL,CAAcmC,OAA5B;AACA,QAAIC,SAAS,GAAGD,OAAO,GAAG,GAAH,GAAS,GAAhC;AACA,QAAIrD,QAAQ,GAAG;AACXQ,MAAAA,MAAM,EAAE6C,OAAO,GAAG,IAAH,GAAU,CADd;AAEX5C,MAAAA,MAAM,EAAE4C,OAAO,GAAG,CAAH,GAAO;AAFX,KAAf;AAIArD,IAAAA,QAAQ,CAAC,cAAcsD,SAAf,CAAR,GAAoC,KAAKC,YAAL,GAAoBC,aAApB,GAAoCC,SAApC,CAA8C,yBAA9C,CAApC;AACA,WAAOzD,QAAP;AACH,GAVsD;AAWvD6C,EAAAA,cAAc,EAAE,UAAS1C,YAAT,EAAuBiC,QAAvB,EAAiCE,WAAjC,EAA8C;AAC1D,QAAIlC,IAAI,GAAG,IAAX;;AACAA,IAAAA,IAAI,CAACQ,aAAL,CAAmB+B,OAAnB,CAA2B;AACvBnC,MAAAA,MAAM,EAAE,CADe;AAEvBC,MAAAA,MAAM,EAAE,CAFe;AAGvBE,MAAAA,UAAU,EAAE,CAHW;AAIvBD,MAAAA,UAAU,EAAE;AAJW,KAA3B,EAKG,KAAK,CALR,EAKW0B,QALX;;AAMA,QAAI,CAACjC,YAAL,EAAmB;AACfmC,MAAAA,WAAW,CAAClC,IAAI,CAACsD,YAAN,EAAoBtB,QAApB,CAAX;AACH;AACJ,GAtBsD;AAuBvDuB,EAAAA,wBAAwB,EAAE,UAASC,IAAT,EAAeC,KAAf,EAAsB;AAC5C,QAAI,MAAM,KAAK9B,OAAL,CAAaU,MAAvB,EAA+B;AAC3B,aAAO,KAAP;AACH;;AACD,QAAImB,IAAI,CAACE,cAAT,EAAyB;AACrB,aAAO,IAAP;AACH;;AACD,QAAIC,UAAU,GAAGH,IAAI,CAACJ,aAAL,EAAjB;AACA,QAAIQ,KAAK,GAAG,KAAKC,WAAL,EAAZ;AACA,QAAIC,GAAG,GAAGH,UAAU,CAACN,SAAX,CAAqBO,KAAK,CAACG,UAAN,GAAmBH,KAAK,CAACG,UAAN,CAAiB,CAAjB,CAAnB,GAAyCH,KAAK,CAACE,GAApE,CAAV;AACA,QAAIE,GAAG,GAAGL,UAAU,CAACN,SAAX,CAAqBO,KAAK,CAACG,UAAN,GAAmBH,KAAK,CAACG,UAAN,CAAiBH,KAAK,CAACG,UAAN,CAAiB1B,MAAjB,GAA0B,CAA3C,CAAnB,GAAmEuB,KAAK,CAACI,GAA9F,CAAV;AACA,QAAIf,OAAO,GAAG,KAAKgB,UAAL,GAAkBhB,OAAhC;AACA,QAAIiB,QAAQ,GAAGV,IAAI,CAACS,UAAL,GAAkBC,QAAjC;AACA,WAAOjB,OAAO,IAAI,CAACiB,QAAZ,IAAwB,CAACjB,OAAD,IAAYiB,QAApC,GAA+CT,KAAK,IAAIK,GAAT,IAAgBL,KAAK,IAAIO,GAAxE,GAA8EP,KAAK,IAAIO,GAAT,IAAgBP,KAAK,IAAIK,GAA9G;AACH,GArCsD;AAsCvDK,EAAAA,kBAAkB,EAAE,UAASV,KAAT,EAAgBW,UAAhB,EAA4B;AAC5C,QAAIC,aAAa,GAAG,IAApB;AACA,QAAIpB,OAAO,GAAG,KAAKnC,QAAL,CAAcmC,OAA5B;AACA,QAAIqB,UAAU,GAAG,CAACF,UAAD,IAAe,CAACnB,OAAhB,IAA2BmB,UAAU,IAAInB,OAA1D;AACA,QAAIsB,SAAS,GAAGD,UAAU,GAAG,IAAH,GAAU,IAApC;AACA,QAAIE,iBAAiB,GAAGF,UAAU,GAAG,IAAH,GAAU,IAA5C;AACA,QAAIG,MAAM,GAAG,KAAKC,SAAL,EAAb;;AACA,SAAK,IAAIpC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmC,MAAM,CAACpC,MAA3B,EAAmCC,CAAC,EAApC,EAAwC;AACpC,UAAIqC,CAAC,GAAGF,MAAM,CAACnC,CAAD,CAAd;AACA,UAAIsC,QAAQ,GAAG,KAAK,CAApB;;AACA,UAAIR,UAAJ,EAAgB;AACZQ,QAAAA,QAAQ,GAAGD,CAAC,CAACE,cAAF,GAAmBN,SAAS,CAAC,CAAD,CAA5B,MAAqCd,KAArC,GAA6CkB,CAAC,CAACH,iBAAD,CAA9C,GAAoE,KAAK,CAApF;AACH,OAFD,MAEO;AACHI,QAAAA,QAAQ,GAAGD,CAAC,CAACJ,SAAD,CAAD,KAAiBd,KAAjB,GAAyBkB,CAAC,CAACH,iBAAD,CAA1B,GAAgD,KAAK,CAAhE;AACH;;AACD,UAAI,KAAKM,0BAAL,CAAgC,CAACV,UAAjC,EAA6CQ,QAA7C,CAAJ,EAA4D;AACxDP,QAAAA,aAAa,GAAGO,QAAhB;AACA;AACH;AACJ;;AACD,WAAOP,aAAP;AACH;AA3DsD,CAAxC,CAAnB;AA6DA3H,KAAK,CAACsG,GAAN,GAAYvE,OAAO,CAAC,EAAD,EAAKD,WAAL,EAAkBK,oBAAlB,EAAwC;AACvD4D,EAAAA,cAAc,EAAE,UAAS1C,YAAT,EAAuBiC,QAAvB,EAAiCE,WAAjC,EAA8C;AAC1DA,IAAAA,WAAW,CAAC,KAAKoB,YAAN,EAAoBtB,QAApB,CAAX;AACH,GAHsD;AAIvDnC,EAAAA,kBAAkB,EAAEtB,WAAW,CAACsB,kBAJuB;AAKvDa,EAAAA,UAAU,EAAE,UAASmB,KAAT,EAAgBkD,MAAhB,EAAwBjF,gBAAxB,EAA0C;AAClDvB,IAAAA,WAAW,CAACmC,UAAZ,CAAuBzC,IAAvB,CAA4B,IAA5B,EAAkC4D,KAAlC,EAAyCkD,MAAzC,EAAiDjF,gBAAjD;AACH,GAPsD;AAQvDV,EAAAA,gBAAgB,EAAE,UAASC,KAAT,EAAgB;AAC9B,QAAIE,IAAI,GAAGV,oBAAoB,CAACO,gBAArB,CAAsCa,KAAtC,CAA4C,IAA5C,EAAkDC,SAAlD,CAAX;;AACAX,IAAAA,IAAI,CAACyF,OAAL,GAAe3F,KAAK,CAAC2F,OAArB;AACA,WAAOzF,IAAP;AACH,GAZsD;AAavD0F,EAAAA,aAAa,EAAE1G,WAAW,CAAC0G,aAb4B;AAcvDC,EAAAA,uBAAuB,EAAE,YAAW;AAChC,QAAIlF,IAAI,GAAG,IAAX;;AACA,QAAImF,eAAe,GAAGnF,IAAI,CAACgB,kBAAL,CAAwBhB,IAAI,CAACoF,sBAAL,EAAxB,EAAuDjE,MAA7E;;AACAgE,IAAAA,eAAe,CAACE,KAAhB,GAAwB,aAAxB;;AACArF,IAAAA,IAAI,CAACL,oBAAL,CAA0BwF,eAA1B;;AACA,QAAIG,aAAa,GAAG7G,OAAO,CAAC,EAAD,EAAK0G,eAAL,CAA3B;;AACA,WAAOG,aAAa,CAACN,OAArB;;AACAhF,IAAAA,IAAI,CAACQ,aAAL,CAAmBC,IAAnB,CAAwB6E,aAAxB;AACH,GAtBsD;AAuBvDnB,EAAAA,kBAAkB,EAAE,UAASoB,MAAT,EAAiBnB,UAAjB,EAA6B;AAC7C,QAAIoB,MAAM,GAAG,IAAb;AACA,QAAIC,SAAS,GAAGrB,UAAU,GAAG,UAAH,GAAgB,QAA1C;AACA,QAAIK,MAAM,GAAG,KAAKiB,gBAAL,EAAb;AACA,QAAIC,OAAO,GAAG,KAAKC,eAAL,EAAd;AACA,QAAIC,UAAU,GAAGF,OAAO,CAACG,SAAR,GAAoB,CAApB,CAAjB;;AACA,SAAK,IAAIxD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmC,MAAM,CAACpC,MAA3B,EAAmCC,CAAC,EAApC,EAAwC;AACpC,UAAIqC,CAAC,GAAGF,MAAM,CAACnC,CAAD,CAAd;AACA,UAAIyD,QAAQ,GAAG,CAAC,GAAG5I,KAAK,CAAC6I,SAAV,EAAqBrB,CAAC,CAACc,SAAD,CAAtB,KAAsC,CAAC,GAAGtI,KAAK,CAAC6I,SAAV,EAAqBT,MAAM,CAACE,SAAD,CAA3B,CAAtC,IAAiFd,CAAC,CAACc,SAAD,CAAD,CAAaQ,OAAb,OAA2BV,MAAM,CAACE,SAAD,CAAN,CAAkBQ,OAAlB,EAA5G,GAA0I,CAAC,GAAG/I,MAAM,CAACgJ,gBAAX,EAA6BP,OAAO,CAACQ,SAAR,EAA7B,EAAkDN,UAAlD,EAA8D,CAACF,OAAO,CAACS,kBAAR,CAA2BzB,CAAC,CAAC0B,KAA7B,CAA/D,EAAoG1B,CAAC,CAAC2B,MAAtG,CAA1I,GAA0P,KAAK,CAA9Q;;AACA,UAAI,CAAC,GAAGnJ,KAAK,CAAC6I,SAAV,EAAqBD,QAArB,CAAJ,EAAoC;AAChCP,QAAAA,MAAM,GAAGO,QAAT;AACA;AACH;AACJ;;AACD,WAAOP,MAAP;AACH,GAtCsD;AAuCvD1G,EAAAA,kBAAkB,EAAET,UAAU,CAACS;AAvCwB,CAAxC,CAAnB","sourcesContent":["/**\r\n * DevExtreme (viz/series/bar_series.js)\r\n * Version: 20.2.3\r\n * Build date: Tue Oct 20 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\n\r\nfunction _typeof(obj) {\r\n    \"@babel/helpers - typeof\";\r\n    if (\"function\" === typeof Symbol && \"symbol\" === typeof Symbol.iterator) {\r\n        _typeof = function(obj) {\r\n            return typeof obj\r\n        }\r\n    } else {\r\n        _typeof = function(obj) {\r\n            return obj && \"function\" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj\r\n        }\r\n    }\r\n    return _typeof(obj)\r\n}\r\nexports.polar = exports.chart = void 0;\r\nvar _extend2 = require(\"../../core/utils/extend\");\r\nvar _iterator = require(\"../../core/utils/iterator\");\r\nvar scatterSeries = _interopRequireWildcard(require(\"./scatter_series\"));\r\nvar _area_series = require(\"./area_series\");\r\nvar _utils = require(\"../core/utils\");\r\nvar _type = require(\"../../core/utils/type\");\r\n\r\nfunction _getRequireWildcardCache() {\r\n    if (\"function\" !== typeof WeakMap) {\r\n        return null\r\n    }\r\n    var cache = new WeakMap;\r\n    _getRequireWildcardCache = function() {\r\n        return cache\r\n    };\r\n    return cache\r\n}\r\n\r\nfunction _interopRequireWildcard(obj) {\r\n    if (obj && obj.__esModule) {\r\n        return obj\r\n    }\r\n    if (null === obj || \"object\" !== _typeof(obj) && \"function\" !== typeof obj) {\r\n        return {\r\n            \"default\": obj\r\n        }\r\n    }\r\n    var cache = _getRequireWildcardCache();\r\n    if (cache && cache.has(obj)) {\r\n        return cache.get(obj)\r\n    }\r\n    var newObj = {};\r\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\r\n    for (var key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\r\n            if (desc && (desc.get || desc.set)) {\r\n                Object.defineProperty(newObj, key, desc)\r\n            } else {\r\n                newObj[key] = obj[key]\r\n            }\r\n        }\r\n    }\r\n    newObj.default = obj;\r\n    if (cache) {\r\n        cache.set(obj, newObj)\r\n    }\r\n    return newObj\r\n}\r\nvar areaSeries = _area_series.chart.area;\r\nvar chartSeries = scatterSeries.chart;\r\nvar polarSeries = scatterSeries.polar;\r\nvar _extend = _extend2.extend;\r\nvar _each = _iterator.each;\r\nvar chart = {};\r\nexports.chart = chart;\r\nvar polar = {};\r\nexports.polar = polar;\r\nvar baseBarSeriesMethods = {\r\n    _createLegendState: function(styleOptions, defaultColor) {\r\n        return {\r\n            fill: styleOptions.color || defaultColor,\r\n            hatching: styleOptions.hatching\r\n        }\r\n    },\r\n    _parsePointStyle: function(style, defaultColor, defaultBorderColor) {\r\n        var color = style.color || defaultColor;\r\n        var base = chartSeries._parsePointStyle.call(this, style, color, defaultBorderColor);\r\n        base.fill = color;\r\n        base.hatching = style.hatching;\r\n        base.dashStyle = style.border && style.border.dashStyle || \"solid\";\r\n        delete base.r;\r\n        return base\r\n    },\r\n    _applyMarkerClipRect: function(settings) {\r\n        settings[\"clip-path\"] = null\r\n    },\r\n    _setGroupsSettings: function(animationEnabled, firstDrawing) {\r\n        var that = this;\r\n        var settings = {};\r\n        chartSeries._setGroupsSettings.apply(that, arguments);\r\n        if (animationEnabled && firstDrawing) {\r\n            settings = this._getAffineCoordOptions()\r\n        } else {\r\n            if (!animationEnabled) {\r\n                settings = {\r\n                    scaleX: 1,\r\n                    scaleY: 1,\r\n                    translateX: 0,\r\n                    translateY: 0\r\n                }\r\n            }\r\n        }\r\n        that._markersGroup.attr(settings)\r\n    },\r\n    _drawPoint: function(options) {\r\n        options.hasAnimation = options.hasAnimation && !options.firstDrawing;\r\n        options.firstDrawing = false;\r\n        chartSeries._drawPoint.call(this, options)\r\n    },\r\n    _getMainColor: function() {\r\n        return this._options.mainSeriesColor\r\n    },\r\n    _createPointStyles: function(pointOptions) {\r\n        var that = this;\r\n        var mainColor = pointOptions.color || that._getMainColor();\r\n        return {\r\n            normal: that._parsePointStyle(pointOptions, mainColor, mainColor),\r\n            hover: that._parsePointStyle(pointOptions.hoverStyle || {}, mainColor, mainColor),\r\n            selection: that._parsePointStyle(pointOptions.selectionStyle || {}, mainColor, mainColor)\r\n        }\r\n    },\r\n    _updatePointsVisibility: function() {\r\n        var visibility = this._options.visible;\r\n        (0, _iterator.each)(this._points, function(_, point) {\r\n            point._options.visible = visibility\r\n        })\r\n    },\r\n    _getOptionsForPoint: function() {\r\n        return this._options\r\n    },\r\n    _animate: function(firstDrawing) {\r\n        var that = this;\r\n        var complete = function() {\r\n            that._animateComplete()\r\n        };\r\n        var animateFunc = function(drawnPoints, complete) {\r\n            var lastPointIndex = drawnPoints.length - 1;\r\n            _each(drawnPoints || [], function(i, point) {\r\n                point.animate(i === lastPointIndex ? complete : void 0, point.getMarkerCoords())\r\n            })\r\n        };\r\n        that._animatePoints(firstDrawing, complete, animateFunc)\r\n    },\r\n    getValueRangeInitialValue: areaSeries.getValueRangeInitialValue,\r\n    _patchMarginOptions: function(options) {\r\n        options.checkInterval = true;\r\n        return options\r\n    },\r\n    _defaultAggregator: \"sum\",\r\n    _defineDrawingState: function() {},\r\n    usePointsToDefineAutoHiding: function() {\r\n        return false\r\n    }\r\n};\r\nchart.bar = _extend({}, chartSeries, baseBarSeriesMethods, {\r\n    _getAffineCoordOptions: function() {\r\n        var rotated = this._options.rotated;\r\n        var direction = rotated ? \"X\" : \"Y\";\r\n        var settings = {\r\n            scaleX: rotated ? .001 : 1,\r\n            scaleY: rotated ? 1 : .001\r\n        };\r\n        settings[\"translate\" + direction] = this.getValueAxis().getTranslator().translate(\"canvas_position_default\");\r\n        return settings\r\n    },\r\n    _animatePoints: function(firstDrawing, complete, animateFunc) {\r\n        var that = this;\r\n        that._markersGroup.animate({\r\n            scaleX: 1,\r\n            scaleY: 1,\r\n            translateY: 0,\r\n            translateX: 0\r\n        }, void 0, complete);\r\n        if (!firstDrawing) {\r\n            animateFunc(that._drawnPoints, complete)\r\n        }\r\n    },\r\n    checkSeriesViewportCoord: function(axis, coord) {\r\n        if (0 === this._points.length) {\r\n            return false\r\n        }\r\n        if (axis.isArgumentAxis) {\r\n            return true\r\n        }\r\n        var translator = axis.getTranslator();\r\n        var range = this.getViewport();\r\n        var min = translator.translate(range.categories ? range.categories[0] : range.min);\r\n        var max = translator.translate(range.categories ? range.categories[range.categories.length - 1] : range.max);\r\n        var rotated = this.getOptions().rotated;\r\n        var inverted = axis.getOptions().inverted;\r\n        return rotated && !inverted || !rotated && inverted ? coord >= min && coord <= max : coord >= max && coord <= min\r\n    },\r\n    getSeriesPairCoord: function(coord, isArgument) {\r\n        var oppositeCoord = null;\r\n        var rotated = this._options.rotated;\r\n        var isOpposite = !isArgument && !rotated || isArgument && rotated;\r\n        var coordName = isOpposite ? \"vy\" : \"vx\";\r\n        var oppositeCoordName = isOpposite ? \"vx\" : \"vy\";\r\n        var points = this.getPoints();\r\n        for (var i = 0; i < points.length; i++) {\r\n            var p = points[i];\r\n            var tmpCoord = void 0;\r\n            if (isArgument) {\r\n                tmpCoord = p.getCenterCoord()[coordName[1]] === coord ? p[oppositeCoordName] : void 0\r\n            } else {\r\n                tmpCoord = p[coordName] === coord ? p[oppositeCoordName] : void 0\r\n            }\r\n            if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\r\n                oppositeCoord = tmpCoord;\r\n                break\r\n            }\r\n        }\r\n        return oppositeCoord\r\n    }\r\n});\r\npolar.bar = _extend({}, polarSeries, baseBarSeriesMethods, {\r\n    _animatePoints: function(firstDrawing, complete, animateFunc) {\r\n        animateFunc(this._drawnPoints, complete)\r\n    },\r\n    _setGroupsSettings: chartSeries._setGroupsSettings,\r\n    _drawPoint: function(point, groups, animationEnabled) {\r\n        chartSeries._drawPoint.call(this, point, groups, animationEnabled)\r\n    },\r\n    _parsePointStyle: function(style) {\r\n        var base = baseBarSeriesMethods._parsePointStyle.apply(this, arguments);\r\n        base.opacity = style.opacity;\r\n        return base\r\n    },\r\n    _createGroups: chartSeries._createGroups,\r\n    _setMarkerGroupSettings: function() {\r\n        var that = this;\r\n        var markersSettings = that._createPointStyles(that._getMarkerGroupOptions()).normal;\r\n        markersSettings.class = \"dxc-markers\";\r\n        that._applyMarkerClipRect(markersSettings);\r\n        var groupSettings = _extend({}, markersSettings);\r\n        delete groupSettings.opacity;\r\n        that._markersGroup.attr(groupSettings)\r\n    },\r\n    getSeriesPairCoord: function(params, isArgument) {\r\n        var coords = null;\r\n        var paramName = isArgument ? \"argument\" : \"radius\";\r\n        var points = this.getVisiblePoints();\r\n        var argAxis = this.getArgumentAxis();\r\n        var startAngle = argAxis.getAngles()[0];\r\n        for (var i = 0; i < points.length; i++) {\r\n            var p = points[i];\r\n            var tmpPoint = (0, _type.isDefined)(p[paramName]) && (0, _type.isDefined)(params[paramName]) && p[paramName].valueOf() === params[paramName].valueOf() ? (0, _utils.convertPolarToXY)(argAxis.getCenter(), startAngle, -argAxis.getTranslatedAngle(p.angle), p.radius) : void 0;\r\n            if ((0, _type.isDefined)(tmpPoint)) {\r\n                coords = tmpPoint;\r\n                break\r\n            }\r\n        }\r\n        return coords\r\n    },\r\n    _createLegendState: areaSeries._createLegendState\r\n});\r\n"]},"metadata":{},"sourceType":"script"}