{"ast":null,"code":"/**\r\n * DevExtreme (viz/axes/xy_axes.js)\r\n * Version: 20.2.3\r\n * Build date: Tue Oct 20 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nexports.default = void 0;\n\nvar _range = require(\"../translators/range\");\n\nvar _format_helper = _interopRequireDefault(require(\"../../format_helper\"));\n\nvar _date = _interopRequireDefault(require(\"../../core/utils/date\"));\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _datetime_breaks = require(\"./datetime_breaks\");\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _utils = require(\"../core/utils\");\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _axes_constants = _interopRequireDefault(require(\"./axes_constants\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar getNextDateUnit = _date.default.getNextDateUnit;\nvar correctDateWithUnitBeginning = _date.default.correctDateWithUnitBeginning;\nvar _math = Math;\nvar _max = _math.max;\nvar TOP = _axes_constants.default.top;\nvar BOTTOM = _axes_constants.default.bottom;\nvar LEFT = _axes_constants.default.left;\nvar RIGHT = _axes_constants.default.right;\nvar CENTER = _axes_constants.default.center;\nvar SCALE_BREAK_OFFSET = 3;\nvar RANGE_RATIO = .3;\nvar WAVED_LINE_CENTER = 2;\nvar WAVED_LINE_TOP = 0;\nvar WAVED_LINE_BOTTOM = 4;\nvar WAVED_LINE_LENGTH = 24;\nvar TICKS_CORRECTIONS = {\n  left: -1,\n  top: -1,\n  right: 0,\n  bottom: 0,\n  center: -.5\n};\n\nfunction prepareDatesDifferences(datesDifferences, tickInterval) {\n  var dateUnitInterval;\n  var i;\n\n  if (\"week\" === tickInterval) {\n    tickInterval = \"day\";\n  }\n\n  if (\"quarter\" === tickInterval) {\n    tickInterval = \"month\";\n  }\n\n  if (datesDifferences[tickInterval]) {\n    for (i = 0; i < _date.default.dateUnitIntervals.length; i++) {\n      dateUnitInterval = _date.default.dateUnitIntervals[i];\n\n      if (datesDifferences[dateUnitInterval]) {\n        datesDifferences[dateUnitInterval] = false;\n        datesDifferences.count--;\n      }\n\n      if (dateUnitInterval === tickInterval) {\n        break;\n      }\n    }\n  }\n}\n\nfunction sortingBreaks(breaks) {\n  return breaks.sort(function (a, b) {\n    return a.from - b.from;\n  });\n}\n\nfunction getMarkerDates(min, max, markerInterval) {\n  var origMin = min;\n  var dates;\n  min = correctDateWithUnitBeginning(min, markerInterval);\n  max = correctDateWithUnitBeginning(max, markerInterval);\n  dates = _date.default.getSequenceByInterval(min, max, markerInterval);\n\n  if (dates.length && origMin > dates[0]) {\n    dates = dates.slice(1);\n  }\n\n  return dates;\n}\n\nfunction getStripHorizontalAlignmentPosition(alignment) {\n  var position = \"start\";\n\n  if (\"center\" === alignment) {\n    position = \"center\";\n  }\n\n  if (\"right\" === alignment) {\n    position = \"end\";\n  }\n\n  return position;\n}\n\nfunction getStripVerticalAlignmentPosition(alignment) {\n  var position = \"start\";\n\n  if (\"center\" === alignment) {\n    position = \"center\";\n  }\n\n  if (\"bottom\" === alignment) {\n    position = \"end\";\n  }\n\n  return position;\n}\n\nfunction getMarkerInterval(tickInterval) {\n  var markerInterval = getNextDateUnit(tickInterval);\n\n  if (\"quarter\" === markerInterval) {\n    markerInterval = getNextDateUnit(markerInterval);\n  }\n\n  return markerInterval;\n}\n\nfunction getMarkerFormat(curDate, prevDate, tickInterval, markerInterval) {\n  var format = markerInterval;\n\n  var datesDifferences = prevDate && _date.default.getDatesDifferences(prevDate, curDate);\n\n  if (prevDate && \"year\" !== tickInterval) {\n    prepareDatesDifferences(datesDifferences, tickInterval);\n    format = _format_helper.default.getDateFormatByDifferences(datesDifferences);\n  }\n\n  return format;\n}\n\nfunction getMaxSide(act, boxes) {\n  return boxes.reduce(function (prevValue, box) {\n    return _max(prevValue, act(box));\n  }, 0);\n}\n\nfunction getDistanceByAngle(bBox, rotationAngle) {\n  rotationAngle = _math.abs(rotationAngle);\n  rotationAngle = rotationAngle % 180 >= 90 ? 90 - rotationAngle % 90 : rotationAngle % 90;\n  var a = rotationAngle * (_math.PI / 180);\n\n  if (a >= _math.atan(bBox.height / bBox.width)) {\n    return bBox.height / _math.abs(_math.sin(a));\n  } else {\n    return bBox.width;\n  }\n}\n\nfunction getMaxConstantLinePadding(constantLines) {\n  return constantLines.reduce(function (padding, options) {\n    return _max(padding, options.paddingTopBottom);\n  }, 0);\n}\n\nfunction getConstantLineLabelMarginForVerticalAlignment(constantLines, alignment, labelHeight) {\n  return constantLines.some(function (options) {\n    return options.label.verticalAlignment === alignment;\n  }) && labelHeight || 0;\n}\n\nfunction getLeftMargin(bBox) {\n  return _math.abs(bBox.x) || 0;\n}\n\nfunction getRightMargin(bBox) {\n  return _math.abs(bBox.width - _math.abs(bBox.x)) || 0;\n}\n\nfunction generateRangesOnPoints(points, edgePoints, getRange) {\n  var i;\n  var length;\n  var maxRange = null;\n  var ranges = [];\n  var curValue;\n  var prevValue;\n  var curRange;\n\n  for (i = 1, length = points.length; i < length; i++) {\n    curValue = points[i];\n    prevValue = points[i - 1];\n    curRange = getRange(curValue, prevValue);\n\n    if (edgePoints.indexOf(curValue) >= 0) {\n      if (!maxRange || curRange > maxRange.length) {\n        maxRange = {\n          start: curValue,\n          end: prevValue,\n          length: curRange\n        };\n      }\n    } else {\n      if (maxRange && curRange < maxRange.length) {\n        ranges.push(maxRange);\n      } else {\n        ranges.push({\n          start: curValue,\n          end: prevValue,\n          length: curRange\n        });\n      }\n\n      maxRange = null;\n    }\n  }\n\n  if (maxRange) {\n    ranges.push(maxRange);\n  }\n\n  return ranges;\n}\n\nfunction generateAutoBreaks(_ref, series, _ref2) {\n  var logarithmBase = _ref.logarithmBase,\n      type = _ref.type,\n      maxAutoBreakCount = _ref.maxAutoBreakCount;\n  var minVisible = _ref2.minVisible,\n      maxVisible = _ref2.maxVisible;\n  var breaks = [];\n  var getRange = \"logarithmic\" === type ? function (min, max) {\n    return (0, _utils.getLog)(max / min, logarithmBase);\n  } : function (min, max) {\n    return max - min;\n  };\n  var visibleRange = getRange(minVisible, maxVisible);\n  var points = series.reduce(function (result, s) {\n    var points = s.getPointsInViewPort();\n    result[0] = result[0].concat(points[0]);\n    result[1] = result[1].concat(points[1]);\n    return result;\n  }, [[], []]);\n  var sortedAllPoints = points[0].concat(points[1]).sort(function (a, b) {\n    return b - a;\n  });\n  var edgePoints = points[1].filter(function (p) {\n    return points[0].indexOf(p) < 0;\n  });\n  var minDiff = RANGE_RATIO * visibleRange;\n  var ranges = generateRangesOnPoints(sortedAllPoints, edgePoints, getRange).sort(function (a, b) {\n    return b.length - a.length;\n  });\n  var epsilon = _math.min.apply(null, ranges.map(function (r) {\n    return r.length;\n  })) / 1e3;\n\n  var _maxAutoBreakCount = (0, _type.isDefined)(maxAutoBreakCount) ? _math.min(maxAutoBreakCount, ranges.length) : ranges.length;\n\n  for (var i = 0; i < _maxAutoBreakCount; i++) {\n    if (ranges[i].length >= minDiff) {\n      if (visibleRange <= ranges[i].length) {\n        break;\n      }\n\n      visibleRange -= ranges[i].length;\n\n      if (visibleRange > epsilon || visibleRange < -epsilon) {\n        breaks.push({\n          from: ranges[i].start,\n          to: ranges[i].end\n        });\n        minDiff = RANGE_RATIO * visibleRange;\n      }\n    } else {\n      break;\n    }\n  }\n\n  sortingBreaks(breaks);\n  return breaks;\n}\n\nvar _default = {\n  linear: {\n    _getStep: function _getStep(boxes, rotationAngle) {\n      var spacing = this._options.label.minSpacing;\n      var func = this._isHorizontal ? function (box) {\n        return box.width + spacing;\n      } : function (box) {\n        return box.height;\n      };\n      var maxLabelLength = getMaxSide(func, boxes);\n\n      if (rotationAngle) {\n        maxLabelLength = getDistanceByAngle({\n          width: maxLabelLength,\n          height: this._getMaxLabelHeight(boxes, 0)\n        }, rotationAngle);\n      }\n\n      return _axes_constants.default.getTicksCountInRange(this._majorTicks, this._isHorizontal ? \"x\" : \"y\", maxLabelLength);\n    },\n    _getMaxLabelHeight: function _getMaxLabelHeight(boxes, spacing) {\n      return getMaxSide(function (box) {\n        return box.height;\n      }, boxes) + spacing;\n    },\n    _validateOverlappingMode: function _validateOverlappingMode(mode, displayMode) {\n      if (this._isHorizontal && (\"rotate\" === displayMode || \"stagger\" === displayMode) || !this._isHorizontal) {\n        return _axes_constants.default.validateOverlappingMode(mode);\n      }\n\n      return mode;\n    },\n    _validateDisplayMode: function _validateDisplayMode(mode) {\n      return this._isHorizontal ? mode : \"standard\";\n    },\n    getMarkerTrackers: function getMarkerTrackers() {\n      return this._markerTrackers;\n    },\n    _getSharpParam: function _getSharpParam(opposite) {\n      return this._isHorizontal ^ opposite ? \"h\" : \"v\";\n    },\n    _createAxisElement: function _createAxisElement() {\n      return this._renderer.path([], \"line\");\n    },\n    _updateAxisElementPosition: function _updateAxisElementPosition() {\n      var axisCoord = this._axisPosition;\n\n      var canvas = this._getCanvasStartEnd();\n\n      this._axisElement.attr({\n        points: this._isHorizontal ? [canvas.start, axisCoord, canvas.end, axisCoord] : [axisCoord, canvas.start, axisCoord, canvas.end]\n      });\n    },\n    _getTranslatedCoord: function _getTranslatedCoord(value, offset) {\n      return this._translator.translate(value, offset);\n    },\n    _initAxisPositions: function _initAxisPositions() {\n      var that = this;\n\n      if (that.customPositionIsAvailable() && !(0, _type.isDefined)(that._customBoundaryPosition)) {\n        that._customBoundaryPosition = that.getCustomBoundaryPosition();\n      }\n\n      if (!that.customPositionIsAvailable() || that.customPositionIsBoundary()) {\n        that._axisPosition = that.getPredefinedPosition(that.getResolvedBoundaryPosition());\n      } else {\n        that._axisPosition = that.getCustomPosition();\n      }\n    },\n    _getTickMarkPoints: function _getTickMarkPoints(coords, length, tickOptions) {\n      var isHorizontal = this._isHorizontal;\n      var tickOrientation = this._options.tickOrientation;\n      var labelPosition = this._options.label.position;\n      var tickStartCoord;\n\n      if ((0, _type.isDefined)(tickOrientation)) {\n        tickStartCoord = TICKS_CORRECTIONS[tickOrientation] * length;\n      } else {\n        var shift = tickOptions.shift || 0;\n\n        if (!isHorizontal && labelPosition === LEFT || isHorizontal && labelPosition !== BOTTOM) {\n          shift = -shift;\n        }\n\n        tickStartCoord = shift + this.getTickStartPositionShift(length);\n      }\n\n      return [coords.x + (isHorizontal ? 0 : tickStartCoord), coords.y + (isHorizontal ? tickStartCoord : 0), coords.x + (isHorizontal ? 0 : tickStartCoord + length), coords.y + (isHorizontal ? tickStartCoord + length : 0)];\n    },\n    getTickStartPositionShift: function getTickStartPositionShift(length) {\n      var width = this._options.width;\n      var position = this.getResolvedBoundaryPosition();\n      return length % 2 === 1 ? width % 2 === 0 && (position === LEFT || position === TOP) || width % 2 === 1 && (position === RIGHT || position === BOTTOM) && !this.hasCustomPosition() ? Math.floor(-length / 2) : -Math.floor(length / 2) : -length / 2 + (width % 2 === 0 ? 0 : position === BOTTOM || position === RIGHT ? -1 : 1);\n    },\n    _getTitleCoords: function _getTitleCoords() {\n      var that = this;\n      var horizontal = that._isHorizontal;\n      var x = that._axisPosition;\n      var y = that._axisPosition;\n      var align = that._options.title.alignment;\n\n      var canvas = that._getCanvasStartEnd();\n\n      var fromStartToEnd = horizontal || that._options.position === LEFT;\n      var canvasStart = fromStartToEnd ? canvas.start : canvas.end;\n      var canvasEnd = fromStartToEnd ? canvas.end : canvas.start;\n      var coord = align === LEFT ? canvasStart : align === RIGHT ? canvasEnd : canvas.start + (canvas.end - canvas.start) / 2;\n\n      if (horizontal) {\n        x = coord;\n      } else {\n        y = coord;\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _drawTitleText: function _drawTitleText(group, coords) {\n      var options = this._options;\n      var titleOptions = options.title;\n      var attrs = {\n        opacity: titleOptions.opacity,\n        align: titleOptions.alignment,\n        \"class\": titleOptions.cssClass\n      };\n\n      if (!titleOptions.text || !group) {\n        return;\n      }\n\n      coords = coords || this._getTitleCoords();\n\n      if (!this._isHorizontal) {\n        attrs.rotate = options.position === LEFT ? 270 : 90;\n      }\n\n      var text = this._renderer.text(titleOptions.text, coords.x, coords.y).css((0, _utils.patchFontOptions)(titleOptions.font)).attr(attrs).append(group);\n\n      this._checkTitleOverflow(text);\n\n      return text;\n    },\n    _updateTitleCoords: function _updateTitleCoords() {\n      this._title && this._title.element.attr(this._getTitleCoords());\n    },\n    _drawTitle: function _drawTitle() {\n      var title = this._drawTitleText(this._axisTitleGroup);\n\n      if (title) {\n        this._title = {\n          element: title\n        };\n      }\n    },\n    _measureTitle: function _measureTitle() {\n      if (this._title) {\n        if (this._title.bBox && !this._title.originalSize) {\n          this._title.originalSize = this._title.bBox;\n        }\n\n        this._title.bBox = this._title.element.getBBox();\n      }\n    },\n    _drawDateMarker: function _drawDateMarker(date, options, range) {\n      var that = this;\n      var markerOptions = that._options.marker;\n\n      var invert = that._translator.getBusinessRange().invert;\n\n      var textIndent = markerOptions.width + markerOptions.textLeftIndent;\n      var pathElement;\n\n      if (null === options.x) {\n        return;\n      }\n\n      if (!options.withoutStick) {\n        pathElement = that._renderer.path([options.x, options.y, options.x, options.y + markerOptions.separatorHeight], \"line\").attr({\n          \"stroke-width\": markerOptions.width,\n          stroke: markerOptions.color,\n          \"stroke-opacity\": markerOptions.opacity,\n          sharp: \"h\"\n        }).append(that._axisElementsGroup);\n      }\n\n      var text = String(that.formatLabel(date, options.labelOptions, range));\n      return {\n        date: date,\n        x: options.x,\n        y: options.y,\n        cropped: options.withoutStick,\n        label: that._renderer.text(text, options.x, options.y).css((0, _utils.patchFontOptions)(markerOptions.label.font)).append(that._axisElementsGroup),\n        line: pathElement,\n        getContentContainer: function getContentContainer() {\n          return this.label;\n        },\n        getEnd: function getEnd() {\n          return this.x + (invert ? -1 : 1) * (textIndent + this.labelBBox.width);\n        },\n        setTitle: function setTitle() {\n          this.title = text;\n        },\n        hideLabel: function hideLabel() {\n          this.label.dispose();\n          this.label = null;\n          this.title = text;\n        },\n        hide: function hide() {\n          if (pathElement) {\n            pathElement.dispose();\n            pathElement = null;\n          }\n\n          this.label.dispose();\n          this.label = null;\n          this.hidden = true;\n        }\n      };\n    },\n    _drawDateMarkers: function _drawDateMarkers() {\n      var that = this;\n      var options = that._options;\n      var translator = that._translator;\n\n      var viewport = that._getViewportRange();\n\n      var minBound = viewport.minVisible;\n      var dateMarkers = [];\n      var dateMarker;\n\n      function draw(markerDate, format, withoutStick) {\n        return that._drawDateMarker(markerDate, {\n          x: translator.translate(markerDate),\n          y: markersAreaTop,\n          labelOptions: that._getLabelFormatOptions(format),\n          withoutStick: withoutStick\n        }, viewport);\n      }\n\n      if (viewport.isEmpty() || !options.marker.visible || \"datetime\" !== options.argumentType || \"discrete\" === options.type || that._majorTicks.length <= 1) {\n        return [];\n      }\n\n      var markersAreaTop = that._axisPosition + options.marker.topIndent;\n\n      var tickInterval = _date.default.getDateUnitInterval(this._tickInterval);\n\n      var markerInterval = getMarkerInterval(tickInterval);\n      var markerDates = getMarkerDates(minBound, viewport.maxVisible, markerInterval);\n\n      if (markerDates.length > 1 || 1 === markerDates.length && minBound < markerDates[0]) {\n        dateMarkers = markerDates.reduce(function (markers, curDate, i, dates) {\n          var marker = draw(curDate, getMarkerFormat(curDate, dates[i - 1] || minBound < curDate && minBound, tickInterval, markerInterval));\n          marker && markers.push(marker);\n          return markers;\n        }, []);\n\n        if (minBound < markerDates[0]) {\n          dateMarker = draw(minBound, getMarkerFormat(minBound, markerDates[0], tickInterval, markerInterval), true);\n          dateMarker && dateMarkers.unshift(dateMarker);\n        }\n      }\n\n      return dateMarkers;\n    },\n    _adjustDateMarkers: function _adjustDateMarkers(offset) {\n      offset = offset || 0;\n      var that = this;\n      var markerOptions = this._options.marker;\n      var textIndent = markerOptions.width + markerOptions.textLeftIndent;\n\n      var invert = this._translator.getBusinessRange().invert;\n\n      var canvas = that._getCanvasStartEnd();\n\n      var dateMarkers = this._dateMarkers;\n\n      if (!dateMarkers.length) {\n        return offset;\n      }\n\n      if (dateMarkers[0].cropped) {\n        if (!this._checkMarkersPosition(invert, dateMarkers[1], dateMarkers[0])) {\n          dateMarkers[0].hideLabel();\n        }\n      }\n\n      var prevDateMarker;\n      dateMarkers.forEach(function (marker, i, markers) {\n        if (marker.cropped) {\n          return;\n        }\n\n        if (invert ? marker.getEnd() < canvas.end : marker.getEnd() > canvas.end) {\n          marker.hideLabel();\n        } else {\n          if (that._checkMarkersPosition(invert, marker, prevDateMarker)) {\n            prevDateMarker = marker;\n          } else {\n            marker.hide();\n          }\n        }\n      });\n\n      this._dateMarkers.forEach(function (marker) {\n        if (marker.label) {\n          var labelBBox = marker.labelBBox;\n          var dy = marker.y + markerOptions.textTopIndent - labelBBox.y;\n          marker.label.attr({\n            translateX: invert ? marker.x - textIndent - labelBBox.x - labelBBox.width : marker.x + textIndent - labelBBox.x,\n            translateY: dy + offset\n          });\n        }\n\n        if (marker.line) {\n          marker.line.attr({\n            translateY: offset\n          });\n        }\n      });\n\n      that._initializeMarkersTrackers(offset);\n\n      return offset + markerOptions.topIndent + markerOptions.separatorHeight;\n    },\n    _checkMarkersPosition: function _checkMarkersPosition(invert, dateMarker, prevDateMarker) {\n      if (void 0 === prevDateMarker) {\n        return true;\n      }\n\n      return invert ? dateMarker.x < prevDateMarker.getEnd() : dateMarker.x > prevDateMarker.getEnd();\n    },\n    _initializeMarkersTrackers: function _initializeMarkersTrackers(offset) {\n      var that = this;\n      var separatorHeight = that._options.marker.separatorHeight;\n      var renderer = that._renderer;\n\n      var businessRange = this._translator.getBusinessRange();\n\n      var canvas = that._getCanvasStartEnd();\n\n      var group = that._axisElementsGroup;\n      that._markerTrackers = this._dateMarkers.filter(function (marker) {\n        return !marker.hidden;\n      }).map(function (marker, i, markers) {\n        var nextMarker = markers[i + 1] || {\n          x: canvas.end,\n          date: businessRange.max\n        };\n        var x = marker.x;\n        var y = marker.y + offset;\n        var markerTracker = renderer.path([x, y, x, y + separatorHeight, nextMarker.x, y + separatorHeight, nextMarker.x, y, x, y], \"area\").attr({\n          \"stroke-width\": 1,\n          stroke: \"grey\",\n          fill: \"grey\",\n          opacity: 1e-4\n        }).append(group);\n        markerTracker.data(\"range\", {\n          startValue: marker.date,\n          endValue: nextMarker.date\n        });\n\n        if (marker.title) {\n          markerTracker.setTitle(marker.title);\n        }\n\n        return markerTracker;\n      });\n    },\n    _getLabelFormatOptions: function _getLabelFormatOptions(formatString) {\n      var that = this;\n      var markerLabelOptions = that._markerLabelOptions;\n\n      if (!markerLabelOptions) {\n        that._markerLabelOptions = markerLabelOptions = (0, _extend.extend)(true, {}, that._options.marker.label);\n      }\n\n      if (!(0, _type.isDefined)(that._options.marker.label.format)) {\n        markerLabelOptions.format = formatString;\n      }\n\n      return markerLabelOptions;\n    },\n    _adjustConstantLineLabels: function _adjustConstantLineLabels(constantLines) {\n      var that = this;\n      var axisPosition = that._options.position;\n      var canvas = that.getCanvas();\n      var canvasLeft = canvas.left;\n      var canvasRight = canvas.width - canvas.right;\n      var canvasTop = canvas.top;\n      var canvasBottom = canvas.height - canvas.bottom;\n      var verticalCenter = canvasTop + (canvasBottom - canvasTop) / 2;\n      var horizontalCenter = canvasLeft + (canvasRight - canvasLeft) / 2;\n      var maxLabel = 0;\n      constantLines.forEach(function (item) {\n        var isHorizontal = that._isHorizontal;\n        var linesOptions = item.options;\n        var paddingTopBottom = linesOptions.paddingTopBottom;\n        var paddingLeftRight = linesOptions.paddingLeftRight;\n        var labelOptions = linesOptions.label;\n        var labelVerticalAlignment = labelOptions.verticalAlignment;\n        var labelHorizontalAlignment = labelOptions.horizontalAlignment;\n        var labelIsInside = \"inside\" === labelOptions.position;\n        var label = item.label;\n        var box = item.labelBBox;\n        var translateX;\n        var translateY;\n\n        if (null === label || box.isEmpty) {\n          return;\n        }\n\n        if (isHorizontal) {\n          if (labelIsInside) {\n            if (labelHorizontalAlignment === LEFT) {\n              translateX = item.coord - paddingLeftRight - box.x - box.width;\n            } else {\n              translateX = item.coord + paddingLeftRight - box.x;\n            }\n\n            switch (labelVerticalAlignment) {\n              case CENTER:\n                translateY = verticalCenter - box.y - box.height / 2;\n                break;\n\n              case BOTTOM:\n                translateY = canvasBottom - paddingTopBottom - box.y - box.height;\n                break;\n\n              default:\n                translateY = canvasTop + paddingTopBottom - box.y;\n            }\n          } else {\n            if (axisPosition === labelVerticalAlignment) {\n              maxLabel = _max(maxLabel, box.height + paddingTopBottom);\n            }\n\n            translateX = item.coord - box.x - box.width / 2;\n\n            if (labelVerticalAlignment === BOTTOM) {\n              translateY = canvasBottom + paddingTopBottom - box.y;\n            } else {\n              translateY = canvasTop - paddingTopBottom - box.y - box.height;\n            }\n          }\n        } else {\n          if (labelIsInside) {\n            if (labelVerticalAlignment === BOTTOM) {\n              translateY = item.coord + paddingTopBottom - box.y;\n            } else {\n              translateY = item.coord - paddingTopBottom - box.y - box.height;\n            }\n\n            switch (labelHorizontalAlignment) {\n              case CENTER:\n                translateX = horizontalCenter - box.x - box.width / 2;\n                break;\n\n              case RIGHT:\n                translateX = canvasRight - paddingLeftRight - box.x - box.width;\n                break;\n\n              default:\n                translateX = canvasLeft + paddingLeftRight - box.x;\n            }\n          } else {\n            if (axisPosition === labelHorizontalAlignment) {\n              maxLabel = _max(maxLabel, box.width + paddingLeftRight);\n            }\n\n            translateY = item.coord - box.y - box.height / 2;\n\n            if (labelHorizontalAlignment === RIGHT) {\n              translateX = canvasRight + paddingLeftRight - box.x;\n            } else {\n              translateX = canvasLeft - paddingLeftRight - box.x - box.width;\n            }\n          }\n        }\n\n        label.attr({\n          translateX: translateX,\n          translateY: translateY\n        });\n      });\n      return maxLabel;\n    },\n    _drawConstantLinesForEstimating: function _drawConstantLinesForEstimating(constantLines) {\n      var that = this;\n      var renderer = this._renderer;\n      var group = renderer.g();\n      constantLines.forEach(function (options) {\n        that._drawConstantLineLabelText(options.label.text, 0, 0, options.label, group).attr({\n          align: \"center\"\n        });\n      });\n      return group.append(renderer.root);\n    },\n    _estimateLabelHeight: function _estimateLabelHeight(bBox, labelOptions) {\n      var height = bBox.height;\n      var drawingType = labelOptions.drawingType;\n\n      if (\"stagger\" === this._validateDisplayMode(drawingType) || \"stagger\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\n        height = 2 * height + labelOptions.staggeringSpacing;\n      }\n\n      if (\"rotate\" === this._validateDisplayMode(drawingType) || \"rotate\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\n        var sinCos = (0, _utils.getCosAndSin)(labelOptions.rotationAngle);\n        height = height * sinCos.cos + bBox.width * sinCos.sin;\n      }\n\n      return height && (height + labelOptions.indentFromAxis || 0) || 0;\n    },\n    estimateMargins: function estimateMargins(canvas) {\n      this.updateCanvas(canvas);\n      var that = this;\n\n      var range = that._getViewportRange();\n\n      var ticksData = this._createTicksAndLabelFormat(range);\n\n      var ticks = ticksData.ticks;\n      var tickInterval = ticksData.tickInterval;\n      var options = this._options;\n\n      var constantLineOptions = that._outsideConstantLines.filter(function (l) {\n        return l.labelOptions.visible;\n      }).map(function (l) {\n        return l.options;\n      });\n\n      var rootElement = that._renderer.root;\n      var labelIsVisible = options.label.visible && !range.isEmpty() && ticks.length;\n      var labelValue = labelIsVisible && that.formatLabel(ticks[ticks.length - 1], options.label, void 0, void 0, tickInterval, ticks);\n\n      var labelElement = labelIsVisible && that._renderer.text(labelValue, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(rootElement);\n\n      var titleElement = that._drawTitleText(rootElement, {\n        x: 0,\n        y: 0\n      });\n\n      var constantLinesLabelsElement = that._drawConstantLinesForEstimating(constantLineOptions);\n\n      var labelBox = !options.label.template && labelElement && labelElement.getBBox() || {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n      var titleBox = titleElement && titleElement.getBBox() || {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n      var constantLinesBox = constantLinesLabelsElement.getBBox();\n      var titleHeight = titleBox.height ? titleBox.height + options.title.margin : 0;\n\n      var labelHeight = that._estimateLabelHeight(labelBox, options.label);\n\n      var constantLinesHeight = constantLinesBox.height ? constantLinesBox.height + getMaxConstantLinePadding(constantLineOptions) : 0;\n      var height = labelHeight + titleHeight;\n      var margins = {\n        left: _max(getLeftMargin(labelBox), getLeftMargin(constantLinesBox)),\n        right: _max(getRightMargin(labelBox), getRightMargin(constantLinesBox)),\n        top: (\"top\" === options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"top\", constantLinesHeight),\n        bottom: (\"top\" !== options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"bottom\", constantLinesHeight)\n      };\n      labelElement && labelElement.remove();\n      titleElement && titleElement.remove();\n      constantLinesLabelsElement && constantLinesLabelsElement.remove();\n      return margins;\n    },\n    _checkAlignmentConstantLineLabels: function _checkAlignmentConstantLineLabels(labelOptions) {\n      var position = labelOptions.position;\n      var verticalAlignment = (labelOptions.verticalAlignment || \"\").toLowerCase();\n      var horizontalAlignment = (labelOptions.horizontalAlignment || \"\").toLowerCase();\n\n      if (this._isHorizontal) {\n        if (\"outside\" === position) {\n          verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\n          horizontalAlignment = CENTER;\n        } else {\n          verticalAlignment = verticalAlignment === CENTER ? CENTER : verticalAlignment === BOTTOM ? BOTTOM : TOP;\n          horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT;\n        }\n      } else {\n        if (\"outside\" === position) {\n          verticalAlignment = CENTER;\n          horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT;\n        } else {\n          verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\n          horizontalAlignment = horizontalAlignment === RIGHT ? RIGHT : horizontalAlignment === CENTER ? CENTER : LEFT;\n        }\n      }\n\n      labelOptions.verticalAlignment = verticalAlignment;\n      labelOptions.horizontalAlignment = horizontalAlignment;\n    },\n    _getConstantLineLabelsCoords: function _getConstantLineLabelsCoords(value, lineLabelOptions) {\n      var that = this;\n      var x = value;\n      var y = value;\n\n      if (that._isHorizontal) {\n        y = that._orthogonalPositions[\"top\" === lineLabelOptions.verticalAlignment ? \"start\" : \"end\"];\n      } else {\n        x = that._orthogonalPositions[\"right\" === lineLabelOptions.horizontalAlignment ? \"end\" : \"start\"];\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _getAdjustedStripLabelCoords: function _getAdjustedStripLabelCoords(strip) {\n      var stripOptions = strip.options;\n      var paddingTopBottom = stripOptions.paddingTopBottom;\n      var paddingLeftRight = stripOptions.paddingLeftRight;\n      var horizontalAlignment = stripOptions.label.horizontalAlignment;\n      var verticalAlignment = stripOptions.label.verticalAlignment;\n      var box = strip.labelBBox;\n      var labelHeight = box.height;\n      var labelWidth = box.width;\n      var labelCoords = strip.labelCoords;\n      var y = labelCoords.y - box.y;\n      var x = labelCoords.x - box.x;\n\n      if (verticalAlignment === TOP) {\n        y += paddingTopBottom;\n      } else {\n        if (verticalAlignment === CENTER) {\n          y -= labelHeight / 2;\n        } else {\n          if (verticalAlignment === BOTTOM) {\n            y -= paddingTopBottom + labelHeight;\n          }\n        }\n      }\n\n      if (horizontalAlignment === LEFT) {\n        x += paddingLeftRight;\n      } else {\n        if (horizontalAlignment === CENTER) {\n          x -= labelWidth / 2;\n        } else {\n          if (horizontalAlignment === RIGHT) {\n            x -= paddingLeftRight + labelWidth;\n          }\n        }\n      }\n\n      return {\n        translateX: x,\n        translateY: y\n      };\n    },\n    _adjustTitle: function _adjustTitle(offset) {\n      offset = offset || 0;\n\n      if (!this._title) {\n        return;\n      }\n\n      var that = this;\n      var options = that._options;\n      var position = options.position;\n      var margin = options.title.margin;\n      var title = that._title;\n      var boxTitle = title.bBox;\n      var x = boxTitle.x;\n      var y = boxTitle.y;\n      var width = boxTitle.width;\n      var height = boxTitle.height;\n      var axisPosition = that._axisPosition;\n      var loCoord = axisPosition - margin - offset;\n      var hiCoord = axisPosition + margin + offset;\n      var params = {};\n\n      if (that._isHorizontal) {\n        if (position === TOP) {\n          params.translateY = loCoord - (y + height);\n        } else {\n          params.translateY = hiCoord - y;\n        }\n      } else {\n        if (position === LEFT) {\n          params.translateX = loCoord - (x + width);\n        } else {\n          params.translateX = hiCoord - x;\n        }\n      }\n\n      title.element.attr(params);\n    },\n    _checkTitleOverflow: function _checkTitleOverflow(titleElement) {\n      if (!this._title && !titleElement) {\n        return;\n      }\n\n      var canvasLength = this._getScreenDelta();\n\n      var title = titleElement ? {\n        bBox: titleElement.getBBox(),\n        element: titleElement\n      } : this._title;\n      var titleOptions = this._options.title;\n      var boxTitle = title.bBox;\n\n      if ((this._isHorizontal ? boxTitle.width : boxTitle.height) > canvasLength) {\n        title.element.setMaxSize(canvasLength, void 0, {\n          wordWrap: titleOptions.wordWrap || \"none\",\n          textOverflow: titleOptions.textOverflow || \"ellipsis\"\n        });\n        this._wrapped = titleOptions.wordWrap && \"none\" !== titleOptions.wordWrap;\n      } else {\n        var moreThanOriginalSize = title.originalSize && canvasLength > (this._isHorizontal ? title.originalSize.width : title.originalSize.height);\n        !this._wrapped && moreThanOriginalSize && title.element.restoreText();\n      }\n    },\n    coordsIn: function coordsIn(x, y) {\n      var canvas = this.getCanvas();\n      var isHorizontal = this._options.isHorizontal;\n      var position = this._options.position;\n      var coord = isHorizontal ? y : x;\n\n      if (isHorizontal && (x < canvas.left || x > canvas.width - canvas.right) || !isHorizontal && (y < canvas.top || y > canvas.height - canvas.bottom)) {\n        return false;\n      }\n\n      if (isHorizontal && position === _axes_constants.default.top || !isHorizontal && position === _axes_constants.default.left) {\n        return coord < canvas[position];\n      }\n\n      return coord > canvas[isHorizontal ? \"height\" : \"width\"] - canvas[position];\n    },\n    _boundaryTicksVisibility: {\n      min: true,\n      max: true\n    },\n    adjust: function adjust(alignToBounds) {\n      var that = this;\n      var seriesData = that._seriesData;\n      var viewport = {\n        min: seriesData.min,\n        max: seriesData.max\n      };\n\n      if (!alignToBounds) {\n        viewport = that._series.filter(function (s) {\n          return s.isVisible();\n        }).reduce(function (range, s) {\n          var seriesRange = s.getViewport();\n          range.min = (0, _type.isDefined)(seriesRange.min) ? range.min < seriesRange.min ? range.min : seriesRange.min : range.min;\n          range.max = (0, _type.isDefined)(seriesRange.max) ? range.max > seriesRange.max ? range.max : seriesRange.max : range.max;\n\n          if (s.showZero) {\n            range = new _range.Range(range);\n            range.correctValueZeroLevel();\n          }\n\n          return range;\n        }, {});\n      }\n\n      if ((0, _type.isDefined)(viewport.min) && (0, _type.isDefined)(viewport.max)) {\n        seriesData.minVisible = viewport.min;\n        seriesData.maxVisible = viewport.max;\n      }\n\n      seriesData.userBreaks = that._getScaleBreaks(that._options, {\n        minVisible: seriesData.minVisible,\n        maxVisible: seriesData.maxVisible\n      }, that._series, that.isArgumentAxis);\n\n      that._translator.updateBusinessRange(that._getViewportRange());\n    },\n    hasWrap: function hasWrap() {\n      return this._wrapped;\n    },\n    getAxisPosition: function getAxisPosition() {\n      return this._axisPosition;\n    },\n    _getStick: function _getStick() {\n      return !this._options.valueMarginsEnabled;\n    },\n    _getStripLabelCoords: function _getStripLabelCoords(from, to, stripLabelOptions) {\n      var that = this;\n      var orthogonalPositions = that._orthogonalPositions;\n      var isHorizontal = that._isHorizontal;\n      var horizontalAlignment = stripLabelOptions.horizontalAlignment;\n      var verticalAlignment = stripLabelOptions.verticalAlignment;\n      var x;\n      var y;\n\n      if (isHorizontal) {\n        if (horizontalAlignment === CENTER) {\n          x = from + (to - from) / 2;\n        } else {\n          if (horizontalAlignment === LEFT) {\n            x = from;\n          } else {\n            if (horizontalAlignment === RIGHT) {\n              x = to;\n            }\n          }\n        }\n\n        y = orthogonalPositions[getStripVerticalAlignmentPosition(verticalAlignment)];\n      } else {\n        x = orthogonalPositions[getStripHorizontalAlignmentPosition(horizontalAlignment)];\n\n        if (verticalAlignment === TOP) {\n          y = from;\n        } else {\n          if (verticalAlignment === CENTER) {\n            y = to + (from - to) / 2;\n          } else {\n            if (verticalAlignment === BOTTOM) {\n              y = to;\n            }\n          }\n        }\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _getTranslatedValue: function _getTranslatedValue(value, offset) {\n      var pos1 = this._translator.translate(value, offset, \"semidiscrete\" === this._options.type && this._options.tickInterval);\n\n      var pos2 = this._axisPosition;\n      var isHorizontal = this._isHorizontal;\n      return {\n        x: isHorizontal ? pos1 : pos2,\n        y: isHorizontal ? pos2 : pos1\n      };\n    },\n    areCoordsOutsideAxis: function areCoordsOutsideAxis(coords) {\n      var coord = this._isHorizontal ? coords.x : coords.y;\n      var visibleArea = this.getVisibleArea();\n\n      if (coord < visibleArea[0] || coord > visibleArea[1]) {\n        return true;\n      }\n\n      return false;\n    },\n    _getSkippedCategory: function _getSkippedCategory(ticks) {\n      var skippedCategory;\n\n      if (this._options.type === _axes_constants.default.discrete && this._tickOffset && 0 !== ticks.length) {\n        skippedCategory = ticks[ticks.length - 1];\n      }\n\n      return skippedCategory;\n    },\n    _filterBreaks: function _filterBreaks(breaks, viewport, breakStyle) {\n      var minVisible = viewport.minVisible;\n      var maxVisible = viewport.maxVisible;\n      var breakSize = breakStyle ? breakStyle.width : 0;\n      return breaks.reduce(function (result, currentBreak) {\n        var from = currentBreak.from;\n        var to = currentBreak.to;\n        var lastResult = result[result.length - 1];\n        var newBreak;\n\n        if (!(0, _type.isDefined)(from) || !(0, _type.isDefined)(to)) {\n          return result;\n        }\n\n        if (from > to) {\n          to = [from, from = to][0];\n        }\n\n        if (result.length && from < lastResult.to) {\n          if (to > lastResult.to) {\n            lastResult.to = to > maxVisible ? maxVisible : to;\n\n            if (lastResult.gapSize) {\n              lastResult.gapSize = void 0;\n              lastResult.cumulativeWidth += breakSize;\n            }\n          }\n        } else {\n          if (from >= minVisible && from < maxVisible || to <= maxVisible && to > minVisible) {\n            from = from >= minVisible ? from : minVisible;\n            to = to <= maxVisible ? to : maxVisible;\n\n            if (to - from < maxVisible - minVisible) {\n              var _lastResult$cumulativ;\n\n              newBreak = {\n                from: from,\n                to: to,\n                cumulativeWidth: (null !== (_lastResult$cumulativ = null === lastResult || void 0 === lastResult ? void 0 : lastResult.cumulativeWidth) && void 0 !== _lastResult$cumulativ ? _lastResult$cumulativ : 0) + breakSize\n              };\n\n              if (currentBreak.gapSize) {\n                var _lastResult$cumulativ2;\n\n                newBreak.gapSize = _date.default.convertMillisecondsToDateUnits(to - from);\n                newBreak.cumulativeWidth = null !== (_lastResult$cumulativ2 = null === lastResult || void 0 === lastResult ? void 0 : lastResult.cumulativeWidth) && void 0 !== _lastResult$cumulativ2 ? _lastResult$cumulativ2 : 0;\n              }\n\n              result.push(newBreak);\n            }\n          }\n        }\n\n        return result;\n      }, []);\n    },\n    _getScaleBreaks: function _getScaleBreaks(axisOptions, viewport, series, isArgumentAxis) {\n      var that = this;\n      var breaks = (axisOptions.breaks || []).map(function (b) {\n        return {\n          from: that.parser(b.startValue),\n          to: that.parser(b.endValue)\n        };\n      });\n\n      if (\"discrete\" !== axisOptions.type && \"datetime\" === axisOptions.dataType && axisOptions.workdaysOnly) {\n        breaks = breaks.concat((0, _datetime_breaks.generateDateBreaks)(viewport.minVisible, viewport.maxVisible, axisOptions.workWeek, axisOptions.singleWorkdays, axisOptions.holidays));\n      }\n\n      if (!isArgumentAxis && \"discrete\" !== axisOptions.type && \"datetime\" !== axisOptions.dataType && axisOptions.autoBreaksEnabled && 0 !== axisOptions.maxAutoBreakCount) {\n        breaks = breaks.concat(generateAutoBreaks(axisOptions, series, viewport));\n      }\n\n      return sortingBreaks(breaks);\n    },\n    _drawBreak: function _drawBreak(translatedEnd, positionFrom, positionTo, width, options, group) {\n      var that = this;\n      var breakStart = translatedEnd - (!that._translator.isInverted() ? width + 1 : 0);\n      var attr = {\n        \"stroke-width\": 1,\n        stroke: options.borderColor,\n        sharp: !options.isWaved ? options.isHorizontal ? \"h\" : \"v\" : void 0\n      };\n      var spaceAttr = {\n        stroke: options.color,\n        \"stroke-width\": width\n      };\n      var getPoints = that._isHorizontal ? rotateLine : function (p) {\n        return p;\n      };\n      var drawer = getLineDrawer(that._renderer, group, getPoints, positionFrom, breakStart, positionTo, options.isWaved);\n      drawer(width / 2, spaceAttr);\n      drawer(0, attr);\n      drawer(width, attr);\n    },\n    _createBreakClipRect: function _createBreakClipRect(from, to) {\n      var that = this;\n      var canvas = that._canvas;\n      var clipWidth = to - from;\n      var clipRect;\n\n      if (that._isHorizontal) {\n        clipRect = that._renderer.clipRect(canvas.left, from, canvas.width, clipWidth);\n      } else {\n        clipRect = that._renderer.clipRect(from, canvas.top, clipWidth, canvas.height);\n      }\n\n      that._breaksElements = that._breaksElements || [];\n\n      that._breaksElements.push(clipRect);\n\n      return clipRect.id;\n    },\n    _createBreaksGroup: function _createBreaksGroup(clipFrom, clipTo) {\n      var that = this;\n\n      var group = that._renderer.g().attr({\n        \"class\": that._axisCssPrefix + \"breaks\",\n        \"clip-path\": that._createBreakClipRect(clipFrom, clipTo)\n      }).append(that._scaleBreaksGroup);\n\n      that._breaksElements = that._breaksElements || [];\n\n      that._breaksElements.push(group);\n\n      return group;\n    },\n    _disposeBreaksGroup: function _disposeBreaksGroup() {\n      (this._breaksElements || []).forEach(function (clipRect) {\n        clipRect.dispose();\n      });\n      this._breaksElements = null;\n    },\n    drawScaleBreaks: function drawScaleBreaks(customCanvas) {\n      var that = this;\n      var options = that._options;\n      var breakStyle = options.breakStyle;\n      var position = options.position;\n      var positionFrom;\n      var positionTo;\n      var breaks = that._translator.getBusinessRange().breaks || [];\n      var additionGroup;\n      var additionBreakFrom;\n      var additionBreakTo;\n\n      that._disposeBreaksGroup();\n\n      if (!(breaks && breaks.length)) {\n        return;\n      }\n\n      var breakOptions = {\n        color: that._options.containerColor,\n        borderColor: breakStyle.color,\n        isHorizontal: that._isHorizontal,\n        isWaved: \"straight\" !== breakStyle.line.toLowerCase()\n      };\n\n      if (customCanvas) {\n        positionFrom = customCanvas.start;\n        positionTo = customCanvas.end;\n      } else {\n        positionFrom = that._orthogonalPositions.start - (options.visible && !that._axisShift && (position === LEFT || position === TOP) ? SCALE_BREAK_OFFSET : 0);\n        positionTo = that._orthogonalPositions.end + (options.visible && (position === RIGHT || position === BOTTOM) ? SCALE_BREAK_OFFSET : 0);\n      }\n\n      var mainGroup = that._createBreaksGroup(positionFrom, positionTo);\n\n      if (that._axisShift && options.visible) {\n        additionBreakFrom = that._axisPosition - that._axisShift - SCALE_BREAK_OFFSET;\n        additionBreakTo = additionBreakFrom + 2 * SCALE_BREAK_OFFSET;\n        additionGroup = that._createBreaksGroup(additionBreakFrom, additionBreakTo);\n      }\n\n      breaks.forEach(function (br) {\n        if (!br.gapSize) {\n          var breakCoord = that._getTranslatedCoord(br.to);\n\n          that._drawBreak(breakCoord, positionFrom, positionTo, breakStyle.width, breakOptions, mainGroup);\n\n          if (that._axisShift && options.visible) {\n            that._drawBreak(breakCoord, additionBreakFrom, additionBreakTo, breakStyle.width, breakOptions, additionGroup);\n          }\n        }\n      });\n    },\n    _getSpiderCategoryOption: _common.noop,\n    shift: function shift(margins) {\n      var that = this;\n      var options = that._options;\n      var isHorizontal = options.isHorizontal;\n      var axesSpacing = that.getMultipleAxesSpacing();\n      var constantLinesGroups = that._axisConstantLineGroups;\n\n      function shiftGroup(side, group) {\n        var attr = {\n          translateX: 0,\n          translateY: 0\n        };\n        var shift = margins[side] ? margins[side] + axesSpacing : 0;\n        attr[isHorizontal ? \"translateY\" : \"translateX\"] = (side === LEFT || side === TOP ? -1 : 1) * shift;\n        (group[side] || group).attr(attr);\n        return shift;\n      }\n\n      that._axisShift = shiftGroup(options.position, that._axisGroup);\n      (isHorizontal ? [TOP, BOTTOM] : [LEFT, RIGHT]).forEach(function (side) {\n        shiftGroup(side, constantLinesGroups.above);\n        shiftGroup(side, constantLinesGroups.under);\n      });\n    },\n    getCustomPosition: function getCustomPosition(position) {\n      var that = this;\n      var orthogonalAxis = that.getOrthogonalAxis();\n      var resolvedPosition = null !== position && void 0 !== position ? position : that.getResolvedPositionOption();\n      var offset = that.getOptions().offset;\n      var orthogonalTranslator = orthogonalAxis.getTranslator();\n      var orthogonalAxisType = orthogonalAxis.getOptions().type;\n      var validPosition = orthogonalAxis.validateUnit(resolvedPosition);\n      var currentPosition;\n\n      if (\"discrete\" === orthogonalAxisType && (!orthogonalTranslator._categories || orthogonalTranslator._categories.indexOf(validPosition) < 0)) {\n        validPosition = void 0;\n      }\n\n      if (that.positionIsBoundary(resolvedPosition)) {\n        currentPosition = that.getPredefinedPosition(resolvedPosition);\n      } else {\n        if (!(0, _type.isDefined)(validPosition)) {\n          currentPosition = that.getPredefinedPosition(that.getOptions().position);\n        } else {\n          currentPosition = orthogonalTranslator.to(validPosition, -1);\n        }\n      }\n\n      if (isFinite(currentPosition) && isFinite(offset)) {\n        currentPosition += offset;\n      }\n\n      return currentPosition;\n    },\n    getCustomBoundaryPosition: function getCustomBoundaryPosition(position) {\n      var that = this;\n      var orthogonalAxis = that.getOrthogonalAxis();\n      var resolvedPosition = null !== position && void 0 !== position ? position : that.getResolvedPositionOption();\n      var orthogonalTranslator = orthogonalAxis.getTranslator();\n      var visibleArea = orthogonalTranslator.getCanvasVisibleArea();\n\n      if (!(0, _type.isDefined)(orthogonalAxis._orthogonalPositions) || 0 === orthogonalTranslator.canvasLength) {\n        return;\n      }\n\n      var currentPosition = that.getCustomPosition(resolvedPosition);\n\n      if (!(0, _type.isDefined)(currentPosition)) {\n        return that.getResolvedBoundaryPosition();\n      } else {\n        if (currentPosition <= visibleArea.min) {\n          return that._isHorizontal ? TOP : LEFT;\n        } else {\n          if (currentPosition >= visibleArea.max) {\n            return that._isHorizontal ? BOTTOM : RIGHT;\n          }\n        }\n      }\n\n      return currentPosition;\n    },\n    getResolvedPositionOption: function getResolvedPositionOption() {\n      var _options$customPositi;\n\n      var options = this.getOptions();\n      return null !== (_options$customPositi = options.customPosition) && void 0 !== _options$customPositi ? _options$customPositi : options.position;\n    },\n    customPositionIsAvailable: function customPositionIsAvailable() {\n      var options = this.getOptions();\n      return (0, _type.isDefined)(this.getOrthogonalAxis()) && ((0, _type.isDefined)(options.customPosition) || isFinite(options.offset));\n    },\n    hasCustomPosition: function hasCustomPosition() {\n      return this.customPositionIsAvailable() && !this.customPositionIsBoundary();\n    },\n    getResolvedBoundaryPosition: function getResolvedBoundaryPosition() {\n      return this.customPositionIsBoundary() ? this._customBoundaryPosition : this.getOptions().position;\n    },\n    customPositionEqualsToPredefined: function customPositionEqualsToPredefined() {\n      return this.customPositionIsBoundary() && this._customBoundaryPosition === this.getOptions().position;\n    },\n    customPositionIsBoundary: function customPositionIsBoundary() {\n      return this.positionIsBoundary(this._customBoundaryPosition);\n    },\n    positionIsBoundary: function positionIsBoundary(position) {\n      return [TOP, LEFT, BOTTOM, RIGHT].indexOf(position) >= 0;\n    },\n    getPredefinedPosition: function getPredefinedPosition(position) {\n      var _this$_orthogonalPosi;\n\n      return null === (_this$_orthogonalPosi = this._orthogonalPositions) || void 0 === _this$_orthogonalPosi ? void 0 : _this$_orthogonalPosi[position === TOP || position === LEFT ? \"start\" : \"end\"];\n    },\n    resolveOverlappingForCustomPositioning: function resolveOverlappingForCustomPositioning(oppositeAxes) {\n      var that = this;\n\n      if (!that.hasCustomPosition() && !that.customPositionIsBoundary() && !oppositeAxes.some(function (a) {\n        return a.hasCustomPosition();\n      })) {\n        return;\n      }\n\n      var overlappingObj = {\n        axes: [],\n        ticks: []\n      };\n      oppositeAxes.filter(function (orthogonalAxis) {\n        return orthogonalAxis.pane === that.pane;\n      }).forEach(function (orthogonalAxis) {\n        for (var i = 0; i < that._majorTicks.length; i++) {\n          var tick = that._majorTicks[i];\n          var label = tick.label;\n\n          if (label) {\n            if (overlappingObj.axes.indexOf(orthogonalAxis) < 0 && that._detectElementsOverlapping(label, orthogonalAxis._axisElement)) {\n              overlappingObj.axes.push(orthogonalAxis);\n\n              that._shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis);\n            }\n\n            for (var j = 0; j < orthogonalAxis._majorTicks.length; j++) {\n              var oppositeTick = orthogonalAxis._majorTicks[j];\n              var oppositeLabel = oppositeTick.label;\n\n              if (oppositeLabel && that._detectElementsOverlapping(label, oppositeLabel)) {\n                overlappingObj.ticks.push(tick);\n\n                that._shiftThroughAxisOverlappedTick(tick);\n\n                i = that._majorTicks.length;\n                break;\n              }\n            }\n          }\n\n          if (tick.mark && overlappingObj.ticks.indexOf(tick) < 0) {\n            if (that._isHorizontal && tick.mark.attr(\"translateY\")) {\n              tick.mark.attr({\n                translateY: 0\n              });\n            } else {\n              if (!that._isHorizontal && tick.mark.attr(\"translateX\")) {\n                tick.mark.attr({\n                  translateX: 0\n                });\n              }\n            }\n          }\n        }\n      });\n    },\n    _shiftThroughOrthogonalAxisOverlappedTick: function _shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis) {\n      var that = this;\n      var labelBBox = label.getBBox();\n      var orthogonalAxisPosition = orthogonalAxis.getAxisPosition();\n      var orthogonalAxisLabelOptions = orthogonalAxis.getOptions().label;\n      var orthogonalAxisLabelPosition = orthogonalAxisLabelOptions.position;\n      var orthogonalAxisLabelIndent = orthogonalAxisLabelOptions.indentFromAxis / 2;\n      var translateCoordName = that._isHorizontal ? \"translateX\" : \"translateY\";\n      var defaultOrthogonalAxisLabelPosition = that._isHorizontal ? LEFT : TOP;\n      var translate = label.attr(translateCoordName);\n      var labelCoord = (that._isHorizontal ? labelBBox.x : labelBBox.y) + translate;\n      var labelSize = that._isHorizontal ? labelBBox.width : labelBBox.height;\n      var outsidePart = orthogonalAxisPosition - labelCoord;\n      var insidePart = labelCoord + labelSize - orthogonalAxisPosition;\n      var attr = {};\n      attr[translateCoordName] = translate;\n\n      if (outsidePart > 0 && insidePart > 0) {\n        if (insidePart - outsidePart > 1) {\n          attr[translateCoordName] += outsidePart + orthogonalAxisLabelIndent;\n        } else {\n          if (outsidePart - insidePart > 1) {\n            attr[translateCoordName] -= insidePart + orthogonalAxisLabelIndent;\n          } else {\n            attr[translateCoordName] += orthogonalAxisLabelPosition === defaultOrthogonalAxisLabelPosition ? outsidePart + orthogonalAxisLabelIndent : -(insidePart + orthogonalAxisLabelIndent);\n          }\n        }\n\n        label.attr(attr);\n      }\n    },\n    _shiftThroughAxisOverlappedTick: function _shiftThroughAxisOverlappedTick(tick) {\n      var _tick$mark;\n\n      var that = this;\n      var label = tick.label;\n\n      if (!label) {\n        return;\n      }\n\n      var labelBBox = label.getBBox();\n      var tickMarkBBox = null === (_tick$mark = tick.mark) || void 0 === _tick$mark ? void 0 : _tick$mark.getBBox();\n      var axisPosition = that.getAxisPosition();\n      var labelOptions = that.getOptions().label;\n      var labelIndent = labelOptions.indentFromAxis;\n      var labelPosition = labelOptions.position;\n      var defaultLabelPosition = that._isHorizontal ? TOP : LEFT;\n      var translateCoordName = that._isHorizontal ? \"translateY\" : \"translateX\";\n      var translate = label.attr(translateCoordName);\n      var labelCoord = (that._isHorizontal ? labelBBox.y : labelBBox.x) + translate;\n      var labelSize = that._isHorizontal ? labelBBox.height : labelBBox.width;\n      var attr = {};\n      attr[translateCoordName] = translate + (labelPosition === defaultLabelPosition ? axisPosition - labelCoord + labelIndent : -(labelCoord - axisPosition + labelSize + labelIndent));\n      label.attr(attr);\n\n      if (tick.mark) {\n        var markerCoord = that._isHorizontal ? tickMarkBBox.y : tickMarkBBox.x;\n        var markerSize = that._isHorizontal ? tickMarkBBox.height : tickMarkBBox.width;\n        attr[translateCoordName] = 2 * (axisPosition - markerCoord) - markerSize + 1;\n        tick.mark.attr(attr);\n      }\n    },\n    _detectElementsOverlapping: function _detectElementsOverlapping(element1, element2) {\n      if (!element1 || !element2) {\n        return false;\n      }\n\n      var bBox1 = element1.getBBox();\n      var x1 = bBox1.x + element1.attr(\"translateX\");\n      var y1 = bBox1.y + element1.attr(\"translateY\");\n      var bBox2 = element2.getBBox();\n      var x2 = bBox2.x + element2.attr(\"translateX\");\n      var y2 = bBox2.y + element2.attr(\"translateY\");\n      return (x2 >= x1 && x2 <= x1 + bBox1.width || x1 >= x2 && x1 <= x2 + bBox2.width) && (y2 >= y1 && y2 <= y1 + bBox1.height || y1 >= y2 && y1 <= y2 + bBox2.height);\n    }\n  }\n};\nexports.default = _default;\n\nfunction getLineDrawer(renderer, root, rotatePoints, positionFrom, breakStart, positionTo, isWaved) {\n  var elementType = isWaved ? \"bezier\" : \"line\";\n  var group = renderer.g().append(root);\n  return function (offset, attr) {\n    renderer.path(rotatePoints(getPoints(positionFrom, breakStart, positionTo, offset, isWaved)), elementType).attr(attr).append(group);\n  };\n}\n\nfunction getPoints(positionFrom, breakStart, positionTo, offset, isWaved) {\n  if (!isWaved) {\n    return [positionFrom, breakStart + offset, positionTo, breakStart + offset];\n  }\n\n  breakStart += offset;\n  var currentPosition;\n  var topPoint = breakStart + WAVED_LINE_TOP;\n  var centerPoint = breakStart + WAVED_LINE_CENTER;\n  var bottomPoint = breakStart + WAVED_LINE_BOTTOM;\n  var points = [[positionFrom, centerPoint]];\n\n  for (currentPosition = positionFrom; currentPosition < positionTo + WAVED_LINE_LENGTH; currentPosition += WAVED_LINE_LENGTH) {\n    points.push([currentPosition + 6, topPoint, currentPosition + 6, topPoint, currentPosition + 12, centerPoint, currentPosition + 18, bottomPoint, currentPosition + 18, bottomPoint, currentPosition + 24, centerPoint]);\n  }\n\n  return [].concat.apply([], points);\n}\n\nfunction rotateLine(lineCoords) {\n  var points = [];\n  var i;\n\n  for (i = 0; i < lineCoords.length; i += 2) {\n    points.push(lineCoords[i + 1]);\n    points.push(lineCoords[i]);\n  }\n\n  return points;\n}\n\nmodule.exports = exports.default;","map":{"version":3,"sources":["E:/Monday.com/quickstart-react/node_modules/devextreme/viz/axes/xy_axes.js"],"names":["exports","default","_range","require","_format_helper","_interopRequireDefault","_date","_extend","_datetime_breaks","_common","_utils","_type","_axes_constants","obj","__esModule","getNextDateUnit","correctDateWithUnitBeginning","_math","Math","_max","max","TOP","top","BOTTOM","bottom","LEFT","left","RIGHT","right","CENTER","center","SCALE_BREAK_OFFSET","RANGE_RATIO","WAVED_LINE_CENTER","WAVED_LINE_TOP","WAVED_LINE_BOTTOM","WAVED_LINE_LENGTH","TICKS_CORRECTIONS","prepareDatesDifferences","datesDifferences","tickInterval","dateUnitInterval","i","dateUnitIntervals","length","count","sortingBreaks","breaks","sort","a","b","from","getMarkerDates","min","markerInterval","origMin","dates","getSequenceByInterval","slice","getStripHorizontalAlignmentPosition","alignment","position","getStripVerticalAlignmentPosition","getMarkerInterval","getMarkerFormat","curDate","prevDate","format","getDatesDifferences","getDateFormatByDifferences","getMaxSide","act","boxes","reduce","prevValue","box","getDistanceByAngle","bBox","rotationAngle","abs","PI","atan","height","width","sin","getMaxConstantLinePadding","constantLines","padding","options","paddingTopBottom","getConstantLineLabelMarginForVerticalAlignment","labelHeight","some","label","verticalAlignment","getLeftMargin","x","getRightMargin","generateRangesOnPoints","points","edgePoints","getRange","maxRange","ranges","curValue","curRange","indexOf","start","end","push","generateAutoBreaks","_ref","series","_ref2","logarithmBase","type","maxAutoBreakCount","minVisible","maxVisible","getLog","visibleRange","result","s","getPointsInViewPort","concat","sortedAllPoints","filter","p","minDiff","epsilon","apply","map","r","_maxAutoBreakCount","isDefined","to","_default","linear","_getStep","spacing","_options","minSpacing","func","_isHorizontal","maxLabelLength","_getMaxLabelHeight","getTicksCountInRange","_majorTicks","_validateOverlappingMode","mode","displayMode","validateOverlappingMode","_validateDisplayMode","getMarkerTrackers","_markerTrackers","_getSharpParam","opposite","_createAxisElement","_renderer","path","_updateAxisElementPosition","axisCoord","_axisPosition","canvas","_getCanvasStartEnd","_axisElement","attr","_getTranslatedCoord","value","offset","_translator","translate","_initAxisPositions","that","customPositionIsAvailable","_customBoundaryPosition","getCustomBoundaryPosition","customPositionIsBoundary","getPredefinedPosition","getResolvedBoundaryPosition","getCustomPosition","_getTickMarkPoints","coords","tickOptions","isHorizontal","tickOrientation","labelPosition","tickStartCoord","shift","getTickStartPositionShift","y","hasCustomPosition","floor","_getTitleCoords","horizontal","align","title","fromStartToEnd","canvasStart","canvasEnd","coord","_drawTitleText","group","titleOptions","attrs","opacity","cssClass","text","rotate","css","patchFontOptions","font","append","_checkTitleOverflow","_updateTitleCoords","_title","element","_drawTitle","_axisTitleGroup","_measureTitle","originalSize","getBBox","_drawDateMarker","date","range","markerOptions","marker","invert","getBusinessRange","textIndent","textLeftIndent","pathElement","withoutStick","separatorHeight","stroke","color","sharp","_axisElementsGroup","String","formatLabel","labelOptions","cropped","line","getContentContainer","getEnd","labelBBox","setTitle","hideLabel","dispose","hide","hidden","_drawDateMarkers","translator","viewport","_getViewportRange","minBound","dateMarkers","dateMarker","draw","markerDate","markersAreaTop","_getLabelFormatOptions","isEmpty","visible","argumentType","topIndent","getDateUnitInterval","_tickInterval","markerDates","markers","unshift","_adjustDateMarkers","_dateMarkers","_checkMarkersPosition","prevDateMarker","forEach","dy","textTopIndent","translateX","translateY","_initializeMarkersTrackers","renderer","businessRange","nextMarker","markerTracker","fill","data","startValue","endValue","formatString","markerLabelOptions","_markerLabelOptions","extend","_adjustConstantLineLabels","axisPosition","getCanvas","canvasLeft","canvasRight","canvasTop","canvasBottom","verticalCenter","horizontalCenter","maxLabel","item","linesOptions","paddingLeftRight","labelVerticalAlignment","labelHorizontalAlignment","horizontalAlignment","labelIsInside","_drawConstantLinesForEstimating","g","_drawConstantLineLabelText","root","_estimateLabelHeight","drawingType","overlappingBehavior","staggeringSpacing","sinCos","getCosAndSin","cos","indentFromAxis","estimateMargins","updateCanvas","ticksData","_createTicksAndLabelFormat","ticks","constantLineOptions","_outsideConstantLines","l","rootElement","labelIsVisible","labelValue","labelElement","_textFontStyles","_textOptions","titleElement","constantLinesLabelsElement","labelBox","template","titleBox","constantLinesBox","titleHeight","margin","constantLinesHeight","margins","remove","_checkAlignmentConstantLineLabels","toLowerCase","_getConstantLineLabelsCoords","lineLabelOptions","_orthogonalPositions","_getAdjustedStripLabelCoords","strip","stripOptions","labelWidth","labelCoords","_adjustTitle","boxTitle","loCoord","hiCoord","params","canvasLength","_getScreenDelta","setMaxSize","wordWrap","textOverflow","_wrapped","moreThanOriginalSize","restoreText","coordsIn","_boundaryTicksVisibility","adjust","alignToBounds","seriesData","_seriesData","_series","isVisible","seriesRange","getViewport","showZero","Range","correctValueZeroLevel","userBreaks","_getScaleBreaks","isArgumentAxis","updateBusinessRange","hasWrap","getAxisPosition","_getStick","valueMarginsEnabled","_getStripLabelCoords","stripLabelOptions","orthogonalPositions","_getTranslatedValue","pos1","pos2","areCoordsOutsideAxis","visibleArea","getVisibleArea","_getSkippedCategory","skippedCategory","discrete","_tickOffset","_filterBreaks","breakStyle","breakSize","currentBreak","lastResult","newBreak","gapSize","cumulativeWidth","_lastResult$cumulativ","_lastResult$cumulativ2","convertMillisecondsToDateUnits","axisOptions","parser","dataType","workdaysOnly","generateDateBreaks","workWeek","singleWorkdays","holidays","autoBreaksEnabled","_drawBreak","translatedEnd","positionFrom","positionTo","breakStart","isInverted","borderColor","isWaved","spaceAttr","getPoints","rotateLine","drawer","getLineDrawer","_createBreakClipRect","_canvas","clipWidth","clipRect","_breaksElements","id","_createBreaksGroup","clipFrom","clipTo","_axisCssPrefix","_scaleBreaksGroup","_disposeBreaksGroup","drawScaleBreaks","customCanvas","additionGroup","additionBreakFrom","additionBreakTo","breakOptions","containerColor","_axisShift","mainGroup","br","breakCoord","_getSpiderCategoryOption","noop","axesSpacing","getMultipleAxesSpacing","constantLinesGroups","_axisConstantLineGroups","shiftGroup","side","_axisGroup","above","under","orthogonalAxis","getOrthogonalAxis","resolvedPosition","getResolvedPositionOption","getOptions","orthogonalTranslator","getTranslator","orthogonalAxisType","validPosition","validateUnit","currentPosition","_categories","positionIsBoundary","isFinite","getCanvasVisibleArea","_options$customPositi","customPosition","customPositionEqualsToPredefined","_this$_orthogonalPosi","resolveOverlappingForCustomPositioning","oppositeAxes","overlappingObj","axes","pane","tick","_detectElementsOverlapping","_shiftThroughOrthogonalAxisOverlappedTick","j","oppositeTick","oppositeLabel","_shiftThroughAxisOverlappedTick","mark","orthogonalAxisPosition","orthogonalAxisLabelOptions","orthogonalAxisLabelPosition","orthogonalAxisLabelIndent","translateCoordName","defaultOrthogonalAxisLabelPosition","labelCoord","labelSize","outsidePart","insidePart","_tick$mark","tickMarkBBox","labelIndent","defaultLabelPosition","markerCoord","markerSize","element1","element2","bBox1","x1","y1","bBox2","x2","y2","rotatePoints","elementType","topPoint","centerPoint","bottomPoint","lineCoords","module"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/axes/xy_axes.js)\r\n * Version: 20.2.3\r\n * Build date: Tue Oct 20 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nexports.default = void 0;\r\nvar _range = require(\"../translators/range\");\r\nvar _format_helper = _interopRequireDefault(require(\"../../format_helper\"));\r\nvar _date = _interopRequireDefault(require(\"../../core/utils/date\"));\r\nvar _extend = require(\"../../core/utils/extend\");\r\nvar _datetime_breaks = require(\"./datetime_breaks\");\r\nvar _common = require(\"../../core/utils/common\");\r\nvar _utils = require(\"../core/utils\");\r\nvar _type = require(\"../../core/utils/type\");\r\nvar _axes_constants = _interopRequireDefault(require(\"./axes_constants\"));\r\n\r\nfunction _interopRequireDefault(obj) {\r\n    return obj && obj.__esModule ? obj : {\r\n        \"default\": obj\r\n    }\r\n}\r\nvar getNextDateUnit = _date.default.getNextDateUnit;\r\nvar correctDateWithUnitBeginning = _date.default.correctDateWithUnitBeginning;\r\nvar _math = Math;\r\nvar _max = _math.max;\r\nvar TOP = _axes_constants.default.top;\r\nvar BOTTOM = _axes_constants.default.bottom;\r\nvar LEFT = _axes_constants.default.left;\r\nvar RIGHT = _axes_constants.default.right;\r\nvar CENTER = _axes_constants.default.center;\r\nvar SCALE_BREAK_OFFSET = 3;\r\nvar RANGE_RATIO = .3;\r\nvar WAVED_LINE_CENTER = 2;\r\nvar WAVED_LINE_TOP = 0;\r\nvar WAVED_LINE_BOTTOM = 4;\r\nvar WAVED_LINE_LENGTH = 24;\r\nvar TICKS_CORRECTIONS = {\r\n    left: -1,\r\n    top: -1,\r\n    right: 0,\r\n    bottom: 0,\r\n    center: -.5\r\n};\r\n\r\nfunction prepareDatesDifferences(datesDifferences, tickInterval) {\r\n    var dateUnitInterval;\r\n    var i;\r\n    if (\"week\" === tickInterval) {\r\n        tickInterval = \"day\"\r\n    }\r\n    if (\"quarter\" === tickInterval) {\r\n        tickInterval = \"month\"\r\n    }\r\n    if (datesDifferences[tickInterval]) {\r\n        for (i = 0; i < _date.default.dateUnitIntervals.length; i++) {\r\n            dateUnitInterval = _date.default.dateUnitIntervals[i];\r\n            if (datesDifferences[dateUnitInterval]) {\r\n                datesDifferences[dateUnitInterval] = false;\r\n                datesDifferences.count--\r\n            }\r\n            if (dateUnitInterval === tickInterval) {\r\n                break\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction sortingBreaks(breaks) {\r\n    return breaks.sort(function(a, b) {\r\n        return a.from - b.from\r\n    })\r\n}\r\n\r\nfunction getMarkerDates(min, max, markerInterval) {\r\n    var origMin = min;\r\n    var dates;\r\n    min = correctDateWithUnitBeginning(min, markerInterval);\r\n    max = correctDateWithUnitBeginning(max, markerInterval);\r\n    dates = _date.default.getSequenceByInterval(min, max, markerInterval);\r\n    if (dates.length && origMin > dates[0]) {\r\n        dates = dates.slice(1)\r\n    }\r\n    return dates\r\n}\r\n\r\nfunction getStripHorizontalAlignmentPosition(alignment) {\r\n    var position = \"start\";\r\n    if (\"center\" === alignment) {\r\n        position = \"center\"\r\n    }\r\n    if (\"right\" === alignment) {\r\n        position = \"end\"\r\n    }\r\n    return position\r\n}\r\n\r\nfunction getStripVerticalAlignmentPosition(alignment) {\r\n    var position = \"start\";\r\n    if (\"center\" === alignment) {\r\n        position = \"center\"\r\n    }\r\n    if (\"bottom\" === alignment) {\r\n        position = \"end\"\r\n    }\r\n    return position\r\n}\r\n\r\nfunction getMarkerInterval(tickInterval) {\r\n    var markerInterval = getNextDateUnit(tickInterval);\r\n    if (\"quarter\" === markerInterval) {\r\n        markerInterval = getNextDateUnit(markerInterval)\r\n    }\r\n    return markerInterval\r\n}\r\n\r\nfunction getMarkerFormat(curDate, prevDate, tickInterval, markerInterval) {\r\n    var format = markerInterval;\r\n    var datesDifferences = prevDate && _date.default.getDatesDifferences(prevDate, curDate);\r\n    if (prevDate && \"year\" !== tickInterval) {\r\n        prepareDatesDifferences(datesDifferences, tickInterval);\r\n        format = _format_helper.default.getDateFormatByDifferences(datesDifferences)\r\n    }\r\n    return format\r\n}\r\n\r\nfunction getMaxSide(act, boxes) {\r\n    return boxes.reduce(function(prevValue, box) {\r\n        return _max(prevValue, act(box))\r\n    }, 0)\r\n}\r\n\r\nfunction getDistanceByAngle(bBox, rotationAngle) {\r\n    rotationAngle = _math.abs(rotationAngle);\r\n    rotationAngle = rotationAngle % 180 >= 90 ? 90 - rotationAngle % 90 : rotationAngle % 90;\r\n    var a = rotationAngle * (_math.PI / 180);\r\n    if (a >= _math.atan(bBox.height / bBox.width)) {\r\n        return bBox.height / _math.abs(_math.sin(a))\r\n    } else {\r\n        return bBox.width\r\n    }\r\n}\r\n\r\nfunction getMaxConstantLinePadding(constantLines) {\r\n    return constantLines.reduce(function(padding, options) {\r\n        return _max(padding, options.paddingTopBottom)\r\n    }, 0)\r\n}\r\n\r\nfunction getConstantLineLabelMarginForVerticalAlignment(constantLines, alignment, labelHeight) {\r\n    return constantLines.some(function(options) {\r\n        return options.label.verticalAlignment === alignment\r\n    }) && labelHeight || 0\r\n}\r\n\r\nfunction getLeftMargin(bBox) {\r\n    return _math.abs(bBox.x) || 0\r\n}\r\n\r\nfunction getRightMargin(bBox) {\r\n    return _math.abs(bBox.width - _math.abs(bBox.x)) || 0\r\n}\r\n\r\nfunction generateRangesOnPoints(points, edgePoints, getRange) {\r\n    var i;\r\n    var length;\r\n    var maxRange = null;\r\n    var ranges = [];\r\n    var curValue;\r\n    var prevValue;\r\n    var curRange;\r\n    for (i = 1, length = points.length; i < length; i++) {\r\n        curValue = points[i];\r\n        prevValue = points[i - 1];\r\n        curRange = getRange(curValue, prevValue);\r\n        if (edgePoints.indexOf(curValue) >= 0) {\r\n            if (!maxRange || curRange > maxRange.length) {\r\n                maxRange = {\r\n                    start: curValue,\r\n                    end: prevValue,\r\n                    length: curRange\r\n                }\r\n            }\r\n        } else {\r\n            if (maxRange && curRange < maxRange.length) {\r\n                ranges.push(maxRange)\r\n            } else {\r\n                ranges.push({\r\n                    start: curValue,\r\n                    end: prevValue,\r\n                    length: curRange\r\n                })\r\n            }\r\n            maxRange = null\r\n        }\r\n    }\r\n    if (maxRange) {\r\n        ranges.push(maxRange)\r\n    }\r\n    return ranges\r\n}\r\n\r\nfunction generateAutoBreaks(_ref, series, _ref2) {\r\n    var logarithmBase = _ref.logarithmBase,\r\n        type = _ref.type,\r\n        maxAutoBreakCount = _ref.maxAutoBreakCount;\r\n    var minVisible = _ref2.minVisible,\r\n        maxVisible = _ref2.maxVisible;\r\n    var breaks = [];\r\n    var getRange = \"logarithmic\" === type ? function(min, max) {\r\n        return (0, _utils.getLog)(max / min, logarithmBase)\r\n    } : function(min, max) {\r\n        return max - min\r\n    };\r\n    var visibleRange = getRange(minVisible, maxVisible);\r\n    var points = series.reduce(function(result, s) {\r\n        var points = s.getPointsInViewPort();\r\n        result[0] = result[0].concat(points[0]);\r\n        result[1] = result[1].concat(points[1]);\r\n        return result\r\n    }, [\r\n        [],\r\n        []\r\n    ]);\r\n    var sortedAllPoints = points[0].concat(points[1]).sort(function(a, b) {\r\n        return b - a\r\n    });\r\n    var edgePoints = points[1].filter(function(p) {\r\n        return points[0].indexOf(p) < 0\r\n    });\r\n    var minDiff = RANGE_RATIO * visibleRange;\r\n    var ranges = generateRangesOnPoints(sortedAllPoints, edgePoints, getRange).sort(function(a, b) {\r\n        return b.length - a.length\r\n    });\r\n    var epsilon = _math.min.apply(null, ranges.map(function(r) {\r\n        return r.length\r\n    })) / 1e3;\r\n    var _maxAutoBreakCount = (0, _type.isDefined)(maxAutoBreakCount) ? _math.min(maxAutoBreakCount, ranges.length) : ranges.length;\r\n    for (var i = 0; i < _maxAutoBreakCount; i++) {\r\n        if (ranges[i].length >= minDiff) {\r\n            if (visibleRange <= ranges[i].length) {\r\n                break\r\n            }\r\n            visibleRange -= ranges[i].length;\r\n            if (visibleRange > epsilon || visibleRange < -epsilon) {\r\n                breaks.push({\r\n                    from: ranges[i].start,\r\n                    to: ranges[i].end\r\n                });\r\n                minDiff = RANGE_RATIO * visibleRange\r\n            }\r\n        } else {\r\n            break\r\n        }\r\n    }\r\n    sortingBreaks(breaks);\r\n    return breaks\r\n}\r\nvar _default = {\r\n    linear: {\r\n        _getStep: function(boxes, rotationAngle) {\r\n            var spacing = this._options.label.minSpacing;\r\n            var func = this._isHorizontal ? function(box) {\r\n                return box.width + spacing\r\n            } : function(box) {\r\n                return box.height\r\n            };\r\n            var maxLabelLength = getMaxSide(func, boxes);\r\n            if (rotationAngle) {\r\n                maxLabelLength = getDistanceByAngle({\r\n                    width: maxLabelLength,\r\n                    height: this._getMaxLabelHeight(boxes, 0)\r\n                }, rotationAngle)\r\n            }\r\n            return _axes_constants.default.getTicksCountInRange(this._majorTicks, this._isHorizontal ? \"x\" : \"y\", maxLabelLength)\r\n        },\r\n        _getMaxLabelHeight: function(boxes, spacing) {\r\n            return getMaxSide(function(box) {\r\n                return box.height\r\n            }, boxes) + spacing\r\n        },\r\n        _validateOverlappingMode: function(mode, displayMode) {\r\n            if (this._isHorizontal && (\"rotate\" === displayMode || \"stagger\" === displayMode) || !this._isHorizontal) {\r\n                return _axes_constants.default.validateOverlappingMode(mode)\r\n            }\r\n            return mode\r\n        },\r\n        _validateDisplayMode: function(mode) {\r\n            return this._isHorizontal ? mode : \"standard\"\r\n        },\r\n        getMarkerTrackers: function() {\r\n            return this._markerTrackers\r\n        },\r\n        _getSharpParam: function(opposite) {\r\n            return this._isHorizontal ^ opposite ? \"h\" : \"v\"\r\n        },\r\n        _createAxisElement: function() {\r\n            return this._renderer.path([], \"line\")\r\n        },\r\n        _updateAxisElementPosition: function() {\r\n            var axisCoord = this._axisPosition;\r\n            var canvas = this._getCanvasStartEnd();\r\n            this._axisElement.attr({\r\n                points: this._isHorizontal ? [canvas.start, axisCoord, canvas.end, axisCoord] : [axisCoord, canvas.start, axisCoord, canvas.end]\r\n            })\r\n        },\r\n        _getTranslatedCoord: function(value, offset) {\r\n            return this._translator.translate(value, offset)\r\n        },\r\n        _initAxisPositions: function() {\r\n            var that = this;\r\n            if (that.customPositionIsAvailable() && !(0, _type.isDefined)(that._customBoundaryPosition)) {\r\n                that._customBoundaryPosition = that.getCustomBoundaryPosition()\r\n            }\r\n            if (!that.customPositionIsAvailable() || that.customPositionIsBoundary()) {\r\n                that._axisPosition = that.getPredefinedPosition(that.getResolvedBoundaryPosition())\r\n            } else {\r\n                that._axisPosition = that.getCustomPosition()\r\n            }\r\n        },\r\n        _getTickMarkPoints: function(coords, length, tickOptions) {\r\n            var isHorizontal = this._isHorizontal;\r\n            var tickOrientation = this._options.tickOrientation;\r\n            var labelPosition = this._options.label.position;\r\n            var tickStartCoord;\r\n            if ((0, _type.isDefined)(tickOrientation)) {\r\n                tickStartCoord = TICKS_CORRECTIONS[tickOrientation] * length\r\n            } else {\r\n                var shift = tickOptions.shift || 0;\r\n                if (!isHorizontal && labelPosition === LEFT || isHorizontal && labelPosition !== BOTTOM) {\r\n                    shift = -shift\r\n                }\r\n                tickStartCoord = shift + this.getTickStartPositionShift(length)\r\n            }\r\n            return [coords.x + (isHorizontal ? 0 : tickStartCoord), coords.y + (isHorizontal ? tickStartCoord : 0), coords.x + (isHorizontal ? 0 : tickStartCoord + length), coords.y + (isHorizontal ? tickStartCoord + length : 0)]\r\n        },\r\n        getTickStartPositionShift: function(length) {\r\n            var width = this._options.width;\r\n            var position = this.getResolvedBoundaryPosition();\r\n            return length % 2 === 1 ? width % 2 === 0 && (position === LEFT || position === TOP) || width % 2 === 1 && (position === RIGHT || position === BOTTOM) && !this.hasCustomPosition() ? Math.floor(-length / 2) : -Math.floor(length / 2) : -length / 2 + (width % 2 === 0 ? 0 : position === BOTTOM || position === RIGHT ? -1 : 1)\r\n        },\r\n        _getTitleCoords: function() {\r\n            var that = this;\r\n            var horizontal = that._isHorizontal;\r\n            var x = that._axisPosition;\r\n            var y = that._axisPosition;\r\n            var align = that._options.title.alignment;\r\n            var canvas = that._getCanvasStartEnd();\r\n            var fromStartToEnd = horizontal || that._options.position === LEFT;\r\n            var canvasStart = fromStartToEnd ? canvas.start : canvas.end;\r\n            var canvasEnd = fromStartToEnd ? canvas.end : canvas.start;\r\n            var coord = align === LEFT ? canvasStart : align === RIGHT ? canvasEnd : canvas.start + (canvas.end - canvas.start) / 2;\r\n            if (horizontal) {\r\n                x = coord\r\n            } else {\r\n                y = coord\r\n            }\r\n            return {\r\n                x: x,\r\n                y: y\r\n            }\r\n        },\r\n        _drawTitleText: function(group, coords) {\r\n            var options = this._options;\r\n            var titleOptions = options.title;\r\n            var attrs = {\r\n                opacity: titleOptions.opacity,\r\n                align: titleOptions.alignment,\r\n                \"class\": titleOptions.cssClass\r\n            };\r\n            if (!titleOptions.text || !group) {\r\n                return\r\n            }\r\n            coords = coords || this._getTitleCoords();\r\n            if (!this._isHorizontal) {\r\n                attrs.rotate = options.position === LEFT ? 270 : 90\r\n            }\r\n            var text = this._renderer.text(titleOptions.text, coords.x, coords.y).css((0, _utils.patchFontOptions)(titleOptions.font)).attr(attrs).append(group);\r\n            this._checkTitleOverflow(text);\r\n            return text\r\n        },\r\n        _updateTitleCoords: function() {\r\n            this._title && this._title.element.attr(this._getTitleCoords())\r\n        },\r\n        _drawTitle: function() {\r\n            var title = this._drawTitleText(this._axisTitleGroup);\r\n            if (title) {\r\n                this._title = {\r\n                    element: title\r\n                }\r\n            }\r\n        },\r\n        _measureTitle: function() {\r\n            if (this._title) {\r\n                if (this._title.bBox && !this._title.originalSize) {\r\n                    this._title.originalSize = this._title.bBox\r\n                }\r\n                this._title.bBox = this._title.element.getBBox()\r\n            }\r\n        },\r\n        _drawDateMarker: function(date, options, range) {\r\n            var that = this;\r\n            var markerOptions = that._options.marker;\r\n            var invert = that._translator.getBusinessRange().invert;\r\n            var textIndent = markerOptions.width + markerOptions.textLeftIndent;\r\n            var pathElement;\r\n            if (null === options.x) {\r\n                return\r\n            }\r\n            if (!options.withoutStick) {\r\n                pathElement = that._renderer.path([options.x, options.y, options.x, options.y + markerOptions.separatorHeight], \"line\").attr({\r\n                    \"stroke-width\": markerOptions.width,\r\n                    stroke: markerOptions.color,\r\n                    \"stroke-opacity\": markerOptions.opacity,\r\n                    sharp: \"h\"\r\n                }).append(that._axisElementsGroup)\r\n            }\r\n            var text = String(that.formatLabel(date, options.labelOptions, range));\r\n            return {\r\n                date: date,\r\n                x: options.x,\r\n                y: options.y,\r\n                cropped: options.withoutStick,\r\n                label: that._renderer.text(text, options.x, options.y).css((0, _utils.patchFontOptions)(markerOptions.label.font)).append(that._axisElementsGroup),\r\n                line: pathElement,\r\n                getContentContainer: function() {\r\n                    return this.label\r\n                },\r\n                getEnd: function() {\r\n                    return this.x + (invert ? -1 : 1) * (textIndent + this.labelBBox.width)\r\n                },\r\n                setTitle: function() {\r\n                    this.title = text\r\n                },\r\n                hideLabel: function() {\r\n                    this.label.dispose();\r\n                    this.label = null;\r\n                    this.title = text\r\n                },\r\n                hide: function() {\r\n                    if (pathElement) {\r\n                        pathElement.dispose();\r\n                        pathElement = null\r\n                    }\r\n                    this.label.dispose();\r\n                    this.label = null;\r\n                    this.hidden = true\r\n                }\r\n            }\r\n        },\r\n        _drawDateMarkers: function() {\r\n            var that = this;\r\n            var options = that._options;\r\n            var translator = that._translator;\r\n            var viewport = that._getViewportRange();\r\n            var minBound = viewport.minVisible;\r\n            var dateMarkers = [];\r\n            var dateMarker;\r\n\r\n            function draw(markerDate, format, withoutStick) {\r\n                return that._drawDateMarker(markerDate, {\r\n                    x: translator.translate(markerDate),\r\n                    y: markersAreaTop,\r\n                    labelOptions: that._getLabelFormatOptions(format),\r\n                    withoutStick: withoutStick\r\n                }, viewport)\r\n            }\r\n            if (viewport.isEmpty() || !options.marker.visible || \"datetime\" !== options.argumentType || \"discrete\" === options.type || that._majorTicks.length <= 1) {\r\n                return []\r\n            }\r\n            var markersAreaTop = that._axisPosition + options.marker.topIndent;\r\n            var tickInterval = _date.default.getDateUnitInterval(this._tickInterval);\r\n            var markerInterval = getMarkerInterval(tickInterval);\r\n            var markerDates = getMarkerDates(minBound, viewport.maxVisible, markerInterval);\r\n            if (markerDates.length > 1 || 1 === markerDates.length && minBound < markerDates[0]) {\r\n                dateMarkers = markerDates.reduce(function(markers, curDate, i, dates) {\r\n                    var marker = draw(curDate, getMarkerFormat(curDate, dates[i - 1] || minBound < curDate && minBound, tickInterval, markerInterval));\r\n                    marker && markers.push(marker);\r\n                    return markers\r\n                }, []);\r\n                if (minBound < markerDates[0]) {\r\n                    dateMarker = draw(minBound, getMarkerFormat(minBound, markerDates[0], tickInterval, markerInterval), true);\r\n                    dateMarker && dateMarkers.unshift(dateMarker)\r\n                }\r\n            }\r\n            return dateMarkers\r\n        },\r\n        _adjustDateMarkers: function(offset) {\r\n            offset = offset || 0;\r\n            var that = this;\r\n            var markerOptions = this._options.marker;\r\n            var textIndent = markerOptions.width + markerOptions.textLeftIndent;\r\n            var invert = this._translator.getBusinessRange().invert;\r\n            var canvas = that._getCanvasStartEnd();\r\n            var dateMarkers = this._dateMarkers;\r\n            if (!dateMarkers.length) {\r\n                return offset\r\n            }\r\n            if (dateMarkers[0].cropped) {\r\n                if (!this._checkMarkersPosition(invert, dateMarkers[1], dateMarkers[0])) {\r\n                    dateMarkers[0].hideLabel()\r\n                }\r\n            }\r\n            var prevDateMarker;\r\n            dateMarkers.forEach(function(marker, i, markers) {\r\n                if (marker.cropped) {\r\n                    return\r\n                }\r\n                if (invert ? marker.getEnd() < canvas.end : marker.getEnd() > canvas.end) {\r\n                    marker.hideLabel()\r\n                } else {\r\n                    if (that._checkMarkersPosition(invert, marker, prevDateMarker)) {\r\n                        prevDateMarker = marker\r\n                    } else {\r\n                        marker.hide()\r\n                    }\r\n                }\r\n            });\r\n            this._dateMarkers.forEach(function(marker) {\r\n                if (marker.label) {\r\n                    var labelBBox = marker.labelBBox;\r\n                    var dy = marker.y + markerOptions.textTopIndent - labelBBox.y;\r\n                    marker.label.attr({\r\n                        translateX: invert ? marker.x - textIndent - labelBBox.x - labelBBox.width : marker.x + textIndent - labelBBox.x,\r\n                        translateY: dy + offset\r\n                    })\r\n                }\r\n                if (marker.line) {\r\n                    marker.line.attr({\r\n                        translateY: offset\r\n                    })\r\n                }\r\n            });\r\n            that._initializeMarkersTrackers(offset);\r\n            return offset + markerOptions.topIndent + markerOptions.separatorHeight\r\n        },\r\n        _checkMarkersPosition: function(invert, dateMarker, prevDateMarker) {\r\n            if (void 0 === prevDateMarker) {\r\n                return true\r\n            }\r\n            return invert ? dateMarker.x < prevDateMarker.getEnd() : dateMarker.x > prevDateMarker.getEnd()\r\n        },\r\n        _initializeMarkersTrackers: function(offset) {\r\n            var that = this;\r\n            var separatorHeight = that._options.marker.separatorHeight;\r\n            var renderer = that._renderer;\r\n            var businessRange = this._translator.getBusinessRange();\r\n            var canvas = that._getCanvasStartEnd();\r\n            var group = that._axisElementsGroup;\r\n            that._markerTrackers = this._dateMarkers.filter(function(marker) {\r\n                return !marker.hidden\r\n            }).map(function(marker, i, markers) {\r\n                var nextMarker = markers[i + 1] || {\r\n                    x: canvas.end,\r\n                    date: businessRange.max\r\n                };\r\n                var x = marker.x;\r\n                var y = marker.y + offset;\r\n                var markerTracker = renderer.path([x, y, x, y + separatorHeight, nextMarker.x, y + separatorHeight, nextMarker.x, y, x, y], \"area\").attr({\r\n                    \"stroke-width\": 1,\r\n                    stroke: \"grey\",\r\n                    fill: \"grey\",\r\n                    opacity: 1e-4\r\n                }).append(group);\r\n                markerTracker.data(\"range\", {\r\n                    startValue: marker.date,\r\n                    endValue: nextMarker.date\r\n                });\r\n                if (marker.title) {\r\n                    markerTracker.setTitle(marker.title)\r\n                }\r\n                return markerTracker\r\n            })\r\n        },\r\n        _getLabelFormatOptions: function(formatString) {\r\n            var that = this;\r\n            var markerLabelOptions = that._markerLabelOptions;\r\n            if (!markerLabelOptions) {\r\n                that._markerLabelOptions = markerLabelOptions = (0, _extend.extend)(true, {}, that._options.marker.label)\r\n            }\r\n            if (!(0, _type.isDefined)(that._options.marker.label.format)) {\r\n                markerLabelOptions.format = formatString\r\n            }\r\n            return markerLabelOptions\r\n        },\r\n        _adjustConstantLineLabels: function(constantLines) {\r\n            var that = this;\r\n            var axisPosition = that._options.position;\r\n            var canvas = that.getCanvas();\r\n            var canvasLeft = canvas.left;\r\n            var canvasRight = canvas.width - canvas.right;\r\n            var canvasTop = canvas.top;\r\n            var canvasBottom = canvas.height - canvas.bottom;\r\n            var verticalCenter = canvasTop + (canvasBottom - canvasTop) / 2;\r\n            var horizontalCenter = canvasLeft + (canvasRight - canvasLeft) / 2;\r\n            var maxLabel = 0;\r\n            constantLines.forEach(function(item) {\r\n                var isHorizontal = that._isHorizontal;\r\n                var linesOptions = item.options;\r\n                var paddingTopBottom = linesOptions.paddingTopBottom;\r\n                var paddingLeftRight = linesOptions.paddingLeftRight;\r\n                var labelOptions = linesOptions.label;\r\n                var labelVerticalAlignment = labelOptions.verticalAlignment;\r\n                var labelHorizontalAlignment = labelOptions.horizontalAlignment;\r\n                var labelIsInside = \"inside\" === labelOptions.position;\r\n                var label = item.label;\r\n                var box = item.labelBBox;\r\n                var translateX;\r\n                var translateY;\r\n                if (null === label || box.isEmpty) {\r\n                    return\r\n                }\r\n                if (isHorizontal) {\r\n                    if (labelIsInside) {\r\n                        if (labelHorizontalAlignment === LEFT) {\r\n                            translateX = item.coord - paddingLeftRight - box.x - box.width\r\n                        } else {\r\n                            translateX = item.coord + paddingLeftRight - box.x\r\n                        }\r\n                        switch (labelVerticalAlignment) {\r\n                            case CENTER:\r\n                                translateY = verticalCenter - box.y - box.height / 2;\r\n                                break;\r\n                            case BOTTOM:\r\n                                translateY = canvasBottom - paddingTopBottom - box.y - box.height;\r\n                                break;\r\n                            default:\r\n                                translateY = canvasTop + paddingTopBottom - box.y\r\n                        }\r\n                    } else {\r\n                        if (axisPosition === labelVerticalAlignment) {\r\n                            maxLabel = _max(maxLabel, box.height + paddingTopBottom)\r\n                        }\r\n                        translateX = item.coord - box.x - box.width / 2;\r\n                        if (labelVerticalAlignment === BOTTOM) {\r\n                            translateY = canvasBottom + paddingTopBottom - box.y\r\n                        } else {\r\n                            translateY = canvasTop - paddingTopBottom - box.y - box.height\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (labelIsInside) {\r\n                        if (labelVerticalAlignment === BOTTOM) {\r\n                            translateY = item.coord + paddingTopBottom - box.y\r\n                        } else {\r\n                            translateY = item.coord - paddingTopBottom - box.y - box.height\r\n                        }\r\n                        switch (labelHorizontalAlignment) {\r\n                            case CENTER:\r\n                                translateX = horizontalCenter - box.x - box.width / 2;\r\n                                break;\r\n                            case RIGHT:\r\n                                translateX = canvasRight - paddingLeftRight - box.x - box.width;\r\n                                break;\r\n                            default:\r\n                                translateX = canvasLeft + paddingLeftRight - box.x\r\n                        }\r\n                    } else {\r\n                        if (axisPosition === labelHorizontalAlignment) {\r\n                            maxLabel = _max(maxLabel, box.width + paddingLeftRight)\r\n                        }\r\n                        translateY = item.coord - box.y - box.height / 2;\r\n                        if (labelHorizontalAlignment === RIGHT) {\r\n                            translateX = canvasRight + paddingLeftRight - box.x\r\n                        } else {\r\n                            translateX = canvasLeft - paddingLeftRight - box.x - box.width\r\n                        }\r\n                    }\r\n                }\r\n                label.attr({\r\n                    translateX: translateX,\r\n                    translateY: translateY\r\n                })\r\n            });\r\n            return maxLabel\r\n        },\r\n        _drawConstantLinesForEstimating: function(constantLines) {\r\n            var that = this;\r\n            var renderer = this._renderer;\r\n            var group = renderer.g();\r\n            constantLines.forEach(function(options) {\r\n                that._drawConstantLineLabelText(options.label.text, 0, 0, options.label, group).attr({\r\n                    align: \"center\"\r\n                })\r\n            });\r\n            return group.append(renderer.root)\r\n        },\r\n        _estimateLabelHeight: function(bBox, labelOptions) {\r\n            var height = bBox.height;\r\n            var drawingType = labelOptions.drawingType;\r\n            if (\"stagger\" === this._validateDisplayMode(drawingType) || \"stagger\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\r\n                height = 2 * height + labelOptions.staggeringSpacing\r\n            }\r\n            if (\"rotate\" === this._validateDisplayMode(drawingType) || \"rotate\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\r\n                var sinCos = (0, _utils.getCosAndSin)(labelOptions.rotationAngle);\r\n                height = height * sinCos.cos + bBox.width * sinCos.sin\r\n            }\r\n            return height && (height + labelOptions.indentFromAxis || 0) || 0\r\n        },\r\n        estimateMargins: function(canvas) {\r\n            this.updateCanvas(canvas);\r\n            var that = this;\r\n            var range = that._getViewportRange();\r\n            var ticksData = this._createTicksAndLabelFormat(range);\r\n            var ticks = ticksData.ticks;\r\n            var tickInterval = ticksData.tickInterval;\r\n            var options = this._options;\r\n            var constantLineOptions = that._outsideConstantLines.filter(function(l) {\r\n                return l.labelOptions.visible\r\n            }).map(function(l) {\r\n                return l.options\r\n            });\r\n            var rootElement = that._renderer.root;\r\n            var labelIsVisible = options.label.visible && !range.isEmpty() && ticks.length;\r\n            var labelValue = labelIsVisible && that.formatLabel(ticks[ticks.length - 1], options.label, void 0, void 0, tickInterval, ticks);\r\n            var labelElement = labelIsVisible && that._renderer.text(labelValue, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(rootElement);\r\n            var titleElement = that._drawTitleText(rootElement, {\r\n                x: 0,\r\n                y: 0\r\n            });\r\n            var constantLinesLabelsElement = that._drawConstantLinesForEstimating(constantLineOptions);\r\n            var labelBox = !options.label.template && labelElement && labelElement.getBBox() || {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0\r\n            };\r\n            var titleBox = titleElement && titleElement.getBBox() || {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0\r\n            };\r\n            var constantLinesBox = constantLinesLabelsElement.getBBox();\r\n            var titleHeight = titleBox.height ? titleBox.height + options.title.margin : 0;\r\n            var labelHeight = that._estimateLabelHeight(labelBox, options.label);\r\n            var constantLinesHeight = constantLinesBox.height ? constantLinesBox.height + getMaxConstantLinePadding(constantLineOptions) : 0;\r\n            var height = labelHeight + titleHeight;\r\n            var margins = {\r\n                left: _max(getLeftMargin(labelBox), getLeftMargin(constantLinesBox)),\r\n                right: _max(getRightMargin(labelBox), getRightMargin(constantLinesBox)),\r\n                top: (\"top\" === options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"top\", constantLinesHeight),\r\n                bottom: (\"top\" !== options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"bottom\", constantLinesHeight)\r\n            };\r\n            labelElement && labelElement.remove();\r\n            titleElement && titleElement.remove();\r\n            constantLinesLabelsElement && constantLinesLabelsElement.remove();\r\n            return margins\r\n        },\r\n        _checkAlignmentConstantLineLabels: function(labelOptions) {\r\n            var position = labelOptions.position;\r\n            var verticalAlignment = (labelOptions.verticalAlignment || \"\").toLowerCase();\r\n            var horizontalAlignment = (labelOptions.horizontalAlignment || \"\").toLowerCase();\r\n            if (this._isHorizontal) {\r\n                if (\"outside\" === position) {\r\n                    verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\r\n                    horizontalAlignment = CENTER\r\n                } else {\r\n                    verticalAlignment = verticalAlignment === CENTER ? CENTER : verticalAlignment === BOTTOM ? BOTTOM : TOP;\r\n                    horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT\r\n                }\r\n            } else {\r\n                if (\"outside\" === position) {\r\n                    verticalAlignment = CENTER;\r\n                    horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT\r\n                } else {\r\n                    verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\r\n                    horizontalAlignment = horizontalAlignment === RIGHT ? RIGHT : horizontalAlignment === CENTER ? CENTER : LEFT\r\n                }\r\n            }\r\n            labelOptions.verticalAlignment = verticalAlignment;\r\n            labelOptions.horizontalAlignment = horizontalAlignment\r\n        },\r\n        _getConstantLineLabelsCoords: function(value, lineLabelOptions) {\r\n            var that = this;\r\n            var x = value;\r\n            var y = value;\r\n            if (that._isHorizontal) {\r\n                y = that._orthogonalPositions[\"top\" === lineLabelOptions.verticalAlignment ? \"start\" : \"end\"]\r\n            } else {\r\n                x = that._orthogonalPositions[\"right\" === lineLabelOptions.horizontalAlignment ? \"end\" : \"start\"]\r\n            }\r\n            return {\r\n                x: x,\r\n                y: y\r\n            }\r\n        },\r\n        _getAdjustedStripLabelCoords: function(strip) {\r\n            var stripOptions = strip.options;\r\n            var paddingTopBottom = stripOptions.paddingTopBottom;\r\n            var paddingLeftRight = stripOptions.paddingLeftRight;\r\n            var horizontalAlignment = stripOptions.label.horizontalAlignment;\r\n            var verticalAlignment = stripOptions.label.verticalAlignment;\r\n            var box = strip.labelBBox;\r\n            var labelHeight = box.height;\r\n            var labelWidth = box.width;\r\n            var labelCoords = strip.labelCoords;\r\n            var y = labelCoords.y - box.y;\r\n            var x = labelCoords.x - box.x;\r\n            if (verticalAlignment === TOP) {\r\n                y += paddingTopBottom\r\n            } else {\r\n                if (verticalAlignment === CENTER) {\r\n                    y -= labelHeight / 2\r\n                } else {\r\n                    if (verticalAlignment === BOTTOM) {\r\n                        y -= paddingTopBottom + labelHeight\r\n                    }\r\n                }\r\n            }\r\n            if (horizontalAlignment === LEFT) {\r\n                x += paddingLeftRight\r\n            } else {\r\n                if (horizontalAlignment === CENTER) {\r\n                    x -= labelWidth / 2\r\n                } else {\r\n                    if (horizontalAlignment === RIGHT) {\r\n                        x -= paddingLeftRight + labelWidth\r\n                    }\r\n                }\r\n            }\r\n            return {\r\n                translateX: x,\r\n                translateY: y\r\n            }\r\n        },\r\n        _adjustTitle: function(offset) {\r\n            offset = offset || 0;\r\n            if (!this._title) {\r\n                return\r\n            }\r\n            var that = this;\r\n            var options = that._options;\r\n            var position = options.position;\r\n            var margin = options.title.margin;\r\n            var title = that._title;\r\n            var boxTitle = title.bBox;\r\n            var x = boxTitle.x;\r\n            var y = boxTitle.y;\r\n            var width = boxTitle.width;\r\n            var height = boxTitle.height;\r\n            var axisPosition = that._axisPosition;\r\n            var loCoord = axisPosition - margin - offset;\r\n            var hiCoord = axisPosition + margin + offset;\r\n            var params = {};\r\n            if (that._isHorizontal) {\r\n                if (position === TOP) {\r\n                    params.translateY = loCoord - (y + height)\r\n                } else {\r\n                    params.translateY = hiCoord - y\r\n                }\r\n            } else {\r\n                if (position === LEFT) {\r\n                    params.translateX = loCoord - (x + width)\r\n                } else {\r\n                    params.translateX = hiCoord - x\r\n                }\r\n            }\r\n            title.element.attr(params)\r\n        },\r\n        _checkTitleOverflow: function(titleElement) {\r\n            if (!this._title && !titleElement) {\r\n                return\r\n            }\r\n            var canvasLength = this._getScreenDelta();\r\n            var title = titleElement ? {\r\n                bBox: titleElement.getBBox(),\r\n                element: titleElement\r\n            } : this._title;\r\n            var titleOptions = this._options.title;\r\n            var boxTitle = title.bBox;\r\n            if ((this._isHorizontal ? boxTitle.width : boxTitle.height) > canvasLength) {\r\n                title.element.setMaxSize(canvasLength, void 0, {\r\n                    wordWrap: titleOptions.wordWrap || \"none\",\r\n                    textOverflow: titleOptions.textOverflow || \"ellipsis\"\r\n                });\r\n                this._wrapped = titleOptions.wordWrap && \"none\" !== titleOptions.wordWrap\r\n            } else {\r\n                var moreThanOriginalSize = title.originalSize && canvasLength > (this._isHorizontal ? title.originalSize.width : title.originalSize.height);\r\n                !this._wrapped && moreThanOriginalSize && title.element.restoreText()\r\n            }\r\n        },\r\n        coordsIn: function(x, y) {\r\n            var canvas = this.getCanvas();\r\n            var isHorizontal = this._options.isHorizontal;\r\n            var position = this._options.position;\r\n            var coord = isHorizontal ? y : x;\r\n            if (isHorizontal && (x < canvas.left || x > canvas.width - canvas.right) || !isHorizontal && (y < canvas.top || y > canvas.height - canvas.bottom)) {\r\n                return false\r\n            }\r\n            if (isHorizontal && position === _axes_constants.default.top || !isHorizontal && position === _axes_constants.default.left) {\r\n                return coord < canvas[position]\r\n            }\r\n            return coord > canvas[isHorizontal ? \"height\" : \"width\"] - canvas[position]\r\n        },\r\n        _boundaryTicksVisibility: {\r\n            min: true,\r\n            max: true\r\n        },\r\n        adjust: function(alignToBounds) {\r\n            var that = this;\r\n            var seriesData = that._seriesData;\r\n            var viewport = {\r\n                min: seriesData.min,\r\n                max: seriesData.max\r\n            };\r\n            if (!alignToBounds) {\r\n                viewport = that._series.filter(function(s) {\r\n                    return s.isVisible()\r\n                }).reduce(function(range, s) {\r\n                    var seriesRange = s.getViewport();\r\n                    range.min = (0, _type.isDefined)(seriesRange.min) ? range.min < seriesRange.min ? range.min : seriesRange.min : range.min;\r\n                    range.max = (0, _type.isDefined)(seriesRange.max) ? range.max > seriesRange.max ? range.max : seriesRange.max : range.max;\r\n                    if (s.showZero) {\r\n                        range = new _range.Range(range);\r\n                        range.correctValueZeroLevel()\r\n                    }\r\n                    return range\r\n                }, {})\r\n            }\r\n            if ((0, _type.isDefined)(viewport.min) && (0, _type.isDefined)(viewport.max)) {\r\n                seriesData.minVisible = viewport.min;\r\n                seriesData.maxVisible = viewport.max\r\n            }\r\n            seriesData.userBreaks = that._getScaleBreaks(that._options, {\r\n                minVisible: seriesData.minVisible,\r\n                maxVisible: seriesData.maxVisible\r\n            }, that._series, that.isArgumentAxis);\r\n            that._translator.updateBusinessRange(that._getViewportRange())\r\n        },\r\n        hasWrap: function() {\r\n            return this._wrapped\r\n        },\r\n        getAxisPosition: function() {\r\n            return this._axisPosition\r\n        },\r\n        _getStick: function() {\r\n            return !this._options.valueMarginsEnabled\r\n        },\r\n        _getStripLabelCoords: function(from, to, stripLabelOptions) {\r\n            var that = this;\r\n            var orthogonalPositions = that._orthogonalPositions;\r\n            var isHorizontal = that._isHorizontal;\r\n            var horizontalAlignment = stripLabelOptions.horizontalAlignment;\r\n            var verticalAlignment = stripLabelOptions.verticalAlignment;\r\n            var x;\r\n            var y;\r\n            if (isHorizontal) {\r\n                if (horizontalAlignment === CENTER) {\r\n                    x = from + (to - from) / 2\r\n                } else {\r\n                    if (horizontalAlignment === LEFT) {\r\n                        x = from\r\n                    } else {\r\n                        if (horizontalAlignment === RIGHT) {\r\n                            x = to\r\n                        }\r\n                    }\r\n                }\r\n                y = orthogonalPositions[getStripVerticalAlignmentPosition(verticalAlignment)]\r\n            } else {\r\n                x = orthogonalPositions[getStripHorizontalAlignmentPosition(horizontalAlignment)];\r\n                if (verticalAlignment === TOP) {\r\n                    y = from\r\n                } else {\r\n                    if (verticalAlignment === CENTER) {\r\n                        y = to + (from - to) / 2\r\n                    } else {\r\n                        if (verticalAlignment === BOTTOM) {\r\n                            y = to\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return {\r\n                x: x,\r\n                y: y\r\n            }\r\n        },\r\n        _getTranslatedValue: function(value, offset) {\r\n            var pos1 = this._translator.translate(value, offset, \"semidiscrete\" === this._options.type && this._options.tickInterval);\r\n            var pos2 = this._axisPosition;\r\n            var isHorizontal = this._isHorizontal;\r\n            return {\r\n                x: isHorizontal ? pos1 : pos2,\r\n                y: isHorizontal ? pos2 : pos1\r\n            }\r\n        },\r\n        areCoordsOutsideAxis: function(coords) {\r\n            var coord = this._isHorizontal ? coords.x : coords.y;\r\n            var visibleArea = this.getVisibleArea();\r\n            if (coord < visibleArea[0] || coord > visibleArea[1]) {\r\n                return true\r\n            }\r\n            return false\r\n        },\r\n        _getSkippedCategory: function(ticks) {\r\n            var skippedCategory;\r\n            if (this._options.type === _axes_constants.default.discrete && this._tickOffset && 0 !== ticks.length) {\r\n                skippedCategory = ticks[ticks.length - 1]\r\n            }\r\n            return skippedCategory\r\n        },\r\n        _filterBreaks: function(breaks, viewport, breakStyle) {\r\n            var minVisible = viewport.minVisible;\r\n            var maxVisible = viewport.maxVisible;\r\n            var breakSize = breakStyle ? breakStyle.width : 0;\r\n            return breaks.reduce(function(result, currentBreak) {\r\n                var from = currentBreak.from;\r\n                var to = currentBreak.to;\r\n                var lastResult = result[result.length - 1];\r\n                var newBreak;\r\n                if (!(0, _type.isDefined)(from) || !(0, _type.isDefined)(to)) {\r\n                    return result\r\n                }\r\n                if (from > to) {\r\n                    to = [from, from = to][0]\r\n                }\r\n                if (result.length && from < lastResult.to) {\r\n                    if (to > lastResult.to) {\r\n                        lastResult.to = to > maxVisible ? maxVisible : to;\r\n                        if (lastResult.gapSize) {\r\n                            lastResult.gapSize = void 0;\r\n                            lastResult.cumulativeWidth += breakSize\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (from >= minVisible && from < maxVisible || to <= maxVisible && to > minVisible) {\r\n                        from = from >= minVisible ? from : minVisible;\r\n                        to = to <= maxVisible ? to : maxVisible;\r\n                        if (to - from < maxVisible - minVisible) {\r\n                            var _lastResult$cumulativ;\r\n                            newBreak = {\r\n                                from: from,\r\n                                to: to,\r\n                                cumulativeWidth: (null !== (_lastResult$cumulativ = null === lastResult || void 0 === lastResult ? void 0 : lastResult.cumulativeWidth) && void 0 !== _lastResult$cumulativ ? _lastResult$cumulativ : 0) + breakSize\r\n                            };\r\n                            if (currentBreak.gapSize) {\r\n                                var _lastResult$cumulativ2;\r\n                                newBreak.gapSize = _date.default.convertMillisecondsToDateUnits(to - from);\r\n                                newBreak.cumulativeWidth = null !== (_lastResult$cumulativ2 = null === lastResult || void 0 === lastResult ? void 0 : lastResult.cumulativeWidth) && void 0 !== _lastResult$cumulativ2 ? _lastResult$cumulativ2 : 0\r\n                            }\r\n                            result.push(newBreak)\r\n                        }\r\n                    }\r\n                }\r\n                return result\r\n            }, [])\r\n        },\r\n        _getScaleBreaks: function(axisOptions, viewport, series, isArgumentAxis) {\r\n            var that = this;\r\n            var breaks = (axisOptions.breaks || []).map(function(b) {\r\n                return {\r\n                    from: that.parser(b.startValue),\r\n                    to: that.parser(b.endValue)\r\n                }\r\n            });\r\n            if (\"discrete\" !== axisOptions.type && \"datetime\" === axisOptions.dataType && axisOptions.workdaysOnly) {\r\n                breaks = breaks.concat((0, _datetime_breaks.generateDateBreaks)(viewport.minVisible, viewport.maxVisible, axisOptions.workWeek, axisOptions.singleWorkdays, axisOptions.holidays))\r\n            }\r\n            if (!isArgumentAxis && \"discrete\" !== axisOptions.type && \"datetime\" !== axisOptions.dataType && axisOptions.autoBreaksEnabled && 0 !== axisOptions.maxAutoBreakCount) {\r\n                breaks = breaks.concat(generateAutoBreaks(axisOptions, series, viewport))\r\n            }\r\n            return sortingBreaks(breaks)\r\n        },\r\n        _drawBreak: function(translatedEnd, positionFrom, positionTo, width, options, group) {\r\n            var that = this;\r\n            var breakStart = translatedEnd - (!that._translator.isInverted() ? width + 1 : 0);\r\n            var attr = {\r\n                \"stroke-width\": 1,\r\n                stroke: options.borderColor,\r\n                sharp: !options.isWaved ? options.isHorizontal ? \"h\" : \"v\" : void 0\r\n            };\r\n            var spaceAttr = {\r\n                stroke: options.color,\r\n                \"stroke-width\": width\r\n            };\r\n            var getPoints = that._isHorizontal ? rotateLine : function(p) {\r\n                return p\r\n            };\r\n            var drawer = getLineDrawer(that._renderer, group, getPoints, positionFrom, breakStart, positionTo, options.isWaved);\r\n            drawer(width / 2, spaceAttr);\r\n            drawer(0, attr);\r\n            drawer(width, attr)\r\n        },\r\n        _createBreakClipRect: function(from, to) {\r\n            var that = this;\r\n            var canvas = that._canvas;\r\n            var clipWidth = to - from;\r\n            var clipRect;\r\n            if (that._isHorizontal) {\r\n                clipRect = that._renderer.clipRect(canvas.left, from, canvas.width, clipWidth)\r\n            } else {\r\n                clipRect = that._renderer.clipRect(from, canvas.top, clipWidth, canvas.height)\r\n            }\r\n            that._breaksElements = that._breaksElements || [];\r\n            that._breaksElements.push(clipRect);\r\n            return clipRect.id\r\n        },\r\n        _createBreaksGroup: function(clipFrom, clipTo) {\r\n            var that = this;\r\n            var group = that._renderer.g().attr({\r\n                \"class\": that._axisCssPrefix + \"breaks\",\r\n                \"clip-path\": that._createBreakClipRect(clipFrom, clipTo)\r\n            }).append(that._scaleBreaksGroup);\r\n            that._breaksElements = that._breaksElements || [];\r\n            that._breaksElements.push(group);\r\n            return group\r\n        },\r\n        _disposeBreaksGroup: function() {\r\n            (this._breaksElements || []).forEach(function(clipRect) {\r\n                clipRect.dispose()\r\n            });\r\n            this._breaksElements = null\r\n        },\r\n        drawScaleBreaks: function(customCanvas) {\r\n            var that = this;\r\n            var options = that._options;\r\n            var breakStyle = options.breakStyle;\r\n            var position = options.position;\r\n            var positionFrom;\r\n            var positionTo;\r\n            var breaks = that._translator.getBusinessRange().breaks || [];\r\n            var additionGroup;\r\n            var additionBreakFrom;\r\n            var additionBreakTo;\r\n            that._disposeBreaksGroup();\r\n            if (!(breaks && breaks.length)) {\r\n                return\r\n            }\r\n            var breakOptions = {\r\n                color: that._options.containerColor,\r\n                borderColor: breakStyle.color,\r\n                isHorizontal: that._isHorizontal,\r\n                isWaved: \"straight\" !== breakStyle.line.toLowerCase()\r\n            };\r\n            if (customCanvas) {\r\n                positionFrom = customCanvas.start;\r\n                positionTo = customCanvas.end\r\n            } else {\r\n                positionFrom = that._orthogonalPositions.start - (options.visible && !that._axisShift && (position === LEFT || position === TOP) ? SCALE_BREAK_OFFSET : 0);\r\n                positionTo = that._orthogonalPositions.end + (options.visible && (position === RIGHT || position === BOTTOM) ? SCALE_BREAK_OFFSET : 0)\r\n            }\r\n            var mainGroup = that._createBreaksGroup(positionFrom, positionTo);\r\n            if (that._axisShift && options.visible) {\r\n                additionBreakFrom = that._axisPosition - that._axisShift - SCALE_BREAK_OFFSET;\r\n                additionBreakTo = additionBreakFrom + 2 * SCALE_BREAK_OFFSET;\r\n                additionGroup = that._createBreaksGroup(additionBreakFrom, additionBreakTo)\r\n            }\r\n            breaks.forEach(function(br) {\r\n                if (!br.gapSize) {\r\n                    var breakCoord = that._getTranslatedCoord(br.to);\r\n                    that._drawBreak(breakCoord, positionFrom, positionTo, breakStyle.width, breakOptions, mainGroup);\r\n                    if (that._axisShift && options.visible) {\r\n                        that._drawBreak(breakCoord, additionBreakFrom, additionBreakTo, breakStyle.width, breakOptions, additionGroup)\r\n                    }\r\n                }\r\n            })\r\n        },\r\n        _getSpiderCategoryOption: _common.noop,\r\n        shift: function(margins) {\r\n            var that = this;\r\n            var options = that._options;\r\n            var isHorizontal = options.isHorizontal;\r\n            var axesSpacing = that.getMultipleAxesSpacing();\r\n            var constantLinesGroups = that._axisConstantLineGroups;\r\n\r\n            function shiftGroup(side, group) {\r\n                var attr = {\r\n                    translateX: 0,\r\n                    translateY: 0\r\n                };\r\n                var shift = margins[side] ? margins[side] + axesSpacing : 0;\r\n                attr[isHorizontal ? \"translateY\" : \"translateX\"] = (side === LEFT || side === TOP ? -1 : 1) * shift;\r\n                (group[side] || group).attr(attr);\r\n                return shift\r\n            }\r\n            that._axisShift = shiftGroup(options.position, that._axisGroup);\r\n            (isHorizontal ? [TOP, BOTTOM] : [LEFT, RIGHT]).forEach(function(side) {\r\n                shiftGroup(side, constantLinesGroups.above);\r\n                shiftGroup(side, constantLinesGroups.under)\r\n            })\r\n        },\r\n        getCustomPosition: function(position) {\r\n            var that = this;\r\n            var orthogonalAxis = that.getOrthogonalAxis();\r\n            var resolvedPosition = null !== position && void 0 !== position ? position : that.getResolvedPositionOption();\r\n            var offset = that.getOptions().offset;\r\n            var orthogonalTranslator = orthogonalAxis.getTranslator();\r\n            var orthogonalAxisType = orthogonalAxis.getOptions().type;\r\n            var validPosition = orthogonalAxis.validateUnit(resolvedPosition);\r\n            var currentPosition;\r\n            if (\"discrete\" === orthogonalAxisType && (!orthogonalTranslator._categories || orthogonalTranslator._categories.indexOf(validPosition) < 0)) {\r\n                validPosition = void 0\r\n            }\r\n            if (that.positionIsBoundary(resolvedPosition)) {\r\n                currentPosition = that.getPredefinedPosition(resolvedPosition)\r\n            } else {\r\n                if (!(0, _type.isDefined)(validPosition)) {\r\n                    currentPosition = that.getPredefinedPosition(that.getOptions().position)\r\n                } else {\r\n                    currentPosition = orthogonalTranslator.to(validPosition, -1)\r\n                }\r\n            }\r\n            if (isFinite(currentPosition) && isFinite(offset)) {\r\n                currentPosition += offset\r\n            }\r\n            return currentPosition\r\n        },\r\n        getCustomBoundaryPosition: function(position) {\r\n            var that = this;\r\n            var orthogonalAxis = that.getOrthogonalAxis();\r\n            var resolvedPosition = null !== position && void 0 !== position ? position : that.getResolvedPositionOption();\r\n            var orthogonalTranslator = orthogonalAxis.getTranslator();\r\n            var visibleArea = orthogonalTranslator.getCanvasVisibleArea();\r\n            if (!(0, _type.isDefined)(orthogonalAxis._orthogonalPositions) || 0 === orthogonalTranslator.canvasLength) {\r\n                return\r\n            }\r\n            var currentPosition = that.getCustomPosition(resolvedPosition);\r\n            if (!(0, _type.isDefined)(currentPosition)) {\r\n                return that.getResolvedBoundaryPosition()\r\n            } else {\r\n                if (currentPosition <= visibleArea.min) {\r\n                    return that._isHorizontal ? TOP : LEFT\r\n                } else {\r\n                    if (currentPosition >= visibleArea.max) {\r\n                        return that._isHorizontal ? BOTTOM : RIGHT\r\n                    }\r\n                }\r\n            }\r\n            return currentPosition\r\n        },\r\n        getResolvedPositionOption: function() {\r\n            var _options$customPositi;\r\n            var options = this.getOptions();\r\n            return null !== (_options$customPositi = options.customPosition) && void 0 !== _options$customPositi ? _options$customPositi : options.position\r\n        },\r\n        customPositionIsAvailable: function() {\r\n            var options = this.getOptions();\r\n            return (0, _type.isDefined)(this.getOrthogonalAxis()) && ((0, _type.isDefined)(options.customPosition) || isFinite(options.offset))\r\n        },\r\n        hasCustomPosition: function() {\r\n            return this.customPositionIsAvailable() && !this.customPositionIsBoundary()\r\n        },\r\n        getResolvedBoundaryPosition: function() {\r\n            return this.customPositionIsBoundary() ? this._customBoundaryPosition : this.getOptions().position\r\n        },\r\n        customPositionEqualsToPredefined: function() {\r\n            return this.customPositionIsBoundary() && this._customBoundaryPosition === this.getOptions().position\r\n        },\r\n        customPositionIsBoundary: function() {\r\n            return this.positionIsBoundary(this._customBoundaryPosition)\r\n        },\r\n        positionIsBoundary: function(position) {\r\n            return [TOP, LEFT, BOTTOM, RIGHT].indexOf(position) >= 0\r\n        },\r\n        getPredefinedPosition: function(position) {\r\n            var _this$_orthogonalPosi;\r\n            return null === (_this$_orthogonalPosi = this._orthogonalPositions) || void 0 === _this$_orthogonalPosi ? void 0 : _this$_orthogonalPosi[position === TOP || position === LEFT ? \"start\" : \"end\"]\r\n        },\r\n        resolveOverlappingForCustomPositioning: function(oppositeAxes) {\r\n            var that = this;\r\n            if (!that.hasCustomPosition() && !that.customPositionIsBoundary() && !oppositeAxes.some(function(a) {\r\n                    return a.hasCustomPosition()\r\n                })) {\r\n                return\r\n            }\r\n            var overlappingObj = {\r\n                axes: [],\r\n                ticks: []\r\n            };\r\n            oppositeAxes.filter(function(orthogonalAxis) {\r\n                return orthogonalAxis.pane === that.pane\r\n            }).forEach(function(orthogonalAxis) {\r\n                for (var i = 0; i < that._majorTicks.length; i++) {\r\n                    var tick = that._majorTicks[i];\r\n                    var label = tick.label;\r\n                    if (label) {\r\n                        if (overlappingObj.axes.indexOf(orthogonalAxis) < 0 && that._detectElementsOverlapping(label, orthogonalAxis._axisElement)) {\r\n                            overlappingObj.axes.push(orthogonalAxis);\r\n                            that._shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis)\r\n                        }\r\n                        for (var j = 0; j < orthogonalAxis._majorTicks.length; j++) {\r\n                            var oppositeTick = orthogonalAxis._majorTicks[j];\r\n                            var oppositeLabel = oppositeTick.label;\r\n                            if (oppositeLabel && that._detectElementsOverlapping(label, oppositeLabel)) {\r\n                                overlappingObj.ticks.push(tick);\r\n                                that._shiftThroughAxisOverlappedTick(tick);\r\n                                i = that._majorTicks.length;\r\n                                break\r\n                            }\r\n                        }\r\n                    }\r\n                    if (tick.mark && overlappingObj.ticks.indexOf(tick) < 0) {\r\n                        if (that._isHorizontal && tick.mark.attr(\"translateY\")) {\r\n                            tick.mark.attr({\r\n                                translateY: 0\r\n                            })\r\n                        } else {\r\n                            if (!that._isHorizontal && tick.mark.attr(\"translateX\")) {\r\n                                tick.mark.attr({\r\n                                    translateX: 0\r\n                                })\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            })\r\n        },\r\n        _shiftThroughOrthogonalAxisOverlappedTick: function(label, orthogonalAxis) {\r\n            var that = this;\r\n            var labelBBox = label.getBBox();\r\n            var orthogonalAxisPosition = orthogonalAxis.getAxisPosition();\r\n            var orthogonalAxisLabelOptions = orthogonalAxis.getOptions().label;\r\n            var orthogonalAxisLabelPosition = orthogonalAxisLabelOptions.position;\r\n            var orthogonalAxisLabelIndent = orthogonalAxisLabelOptions.indentFromAxis / 2;\r\n            var translateCoordName = that._isHorizontal ? \"translateX\" : \"translateY\";\r\n            var defaultOrthogonalAxisLabelPosition = that._isHorizontal ? LEFT : TOP;\r\n            var translate = label.attr(translateCoordName);\r\n            var labelCoord = (that._isHorizontal ? labelBBox.x : labelBBox.y) + translate;\r\n            var labelSize = that._isHorizontal ? labelBBox.width : labelBBox.height;\r\n            var outsidePart = orthogonalAxisPosition - labelCoord;\r\n            var insidePart = labelCoord + labelSize - orthogonalAxisPosition;\r\n            var attr = {};\r\n            attr[translateCoordName] = translate;\r\n            if (outsidePart > 0 && insidePart > 0) {\r\n                if (insidePart - outsidePart > 1) {\r\n                    attr[translateCoordName] += outsidePart + orthogonalAxisLabelIndent\r\n                } else {\r\n                    if (outsidePart - insidePart > 1) {\r\n                        attr[translateCoordName] -= insidePart + orthogonalAxisLabelIndent\r\n                    } else {\r\n                        attr[translateCoordName] += orthogonalAxisLabelPosition === defaultOrthogonalAxisLabelPosition ? outsidePart + orthogonalAxisLabelIndent : -(insidePart + orthogonalAxisLabelIndent)\r\n                    }\r\n                }\r\n                label.attr(attr)\r\n            }\r\n        },\r\n        _shiftThroughAxisOverlappedTick: function(tick) {\r\n            var _tick$mark;\r\n            var that = this;\r\n            var label = tick.label;\r\n            if (!label) {\r\n                return\r\n            }\r\n            var labelBBox = label.getBBox();\r\n            var tickMarkBBox = null === (_tick$mark = tick.mark) || void 0 === _tick$mark ? void 0 : _tick$mark.getBBox();\r\n            var axisPosition = that.getAxisPosition();\r\n            var labelOptions = that.getOptions().label;\r\n            var labelIndent = labelOptions.indentFromAxis;\r\n            var labelPosition = labelOptions.position;\r\n            var defaultLabelPosition = that._isHorizontal ? TOP : LEFT;\r\n            var translateCoordName = that._isHorizontal ? \"translateY\" : \"translateX\";\r\n            var translate = label.attr(translateCoordName);\r\n            var labelCoord = (that._isHorizontal ? labelBBox.y : labelBBox.x) + translate;\r\n            var labelSize = that._isHorizontal ? labelBBox.height : labelBBox.width;\r\n            var attr = {};\r\n            attr[translateCoordName] = translate + (labelPosition === defaultLabelPosition ? axisPosition - labelCoord + labelIndent : -(labelCoord - axisPosition + labelSize + labelIndent));\r\n            label.attr(attr);\r\n            if (tick.mark) {\r\n                var markerCoord = that._isHorizontal ? tickMarkBBox.y : tickMarkBBox.x;\r\n                var markerSize = that._isHorizontal ? tickMarkBBox.height : tickMarkBBox.width;\r\n                attr[translateCoordName] = 2 * (axisPosition - markerCoord) - markerSize + 1;\r\n                tick.mark.attr(attr)\r\n            }\r\n        },\r\n        _detectElementsOverlapping: function(element1, element2) {\r\n            if (!element1 || !element2) {\r\n                return false\r\n            }\r\n            var bBox1 = element1.getBBox();\r\n            var x1 = bBox1.x + element1.attr(\"translateX\");\r\n            var y1 = bBox1.y + element1.attr(\"translateY\");\r\n            var bBox2 = element2.getBBox();\r\n            var x2 = bBox2.x + element2.attr(\"translateX\");\r\n            var y2 = bBox2.y + element2.attr(\"translateY\");\r\n            return (x2 >= x1 && x2 <= x1 + bBox1.width || x1 >= x2 && x1 <= x2 + bBox2.width) && (y2 >= y1 && y2 <= y1 + bBox1.height || y1 >= y2 && y1 <= y2 + bBox2.height)\r\n        }\r\n    }\r\n};\r\nexports.default = _default;\r\n\r\nfunction getLineDrawer(renderer, root, rotatePoints, positionFrom, breakStart, positionTo, isWaved) {\r\n    var elementType = isWaved ? \"bezier\" : \"line\";\r\n    var group = renderer.g().append(root);\r\n    return function(offset, attr) {\r\n        renderer.path(rotatePoints(getPoints(positionFrom, breakStart, positionTo, offset, isWaved)), elementType).attr(attr).append(group)\r\n    }\r\n}\r\n\r\nfunction getPoints(positionFrom, breakStart, positionTo, offset, isWaved) {\r\n    if (!isWaved) {\r\n        return [positionFrom, breakStart + offset, positionTo, breakStart + offset]\r\n    }\r\n    breakStart += offset;\r\n    var currentPosition;\r\n    var topPoint = breakStart + WAVED_LINE_TOP;\r\n    var centerPoint = breakStart + WAVED_LINE_CENTER;\r\n    var bottomPoint = breakStart + WAVED_LINE_BOTTOM;\r\n    var points = [\r\n        [positionFrom, centerPoint]\r\n    ];\r\n    for (currentPosition = positionFrom; currentPosition < positionTo + WAVED_LINE_LENGTH; currentPosition += WAVED_LINE_LENGTH) {\r\n        points.push([currentPosition + 6, topPoint, currentPosition + 6, topPoint, currentPosition + 12, centerPoint, currentPosition + 18, bottomPoint, currentPosition + 18, bottomPoint, currentPosition + 24, centerPoint])\r\n    }\r\n    return [].concat.apply([], points)\r\n}\r\n\r\nfunction rotateLine(lineCoords) {\r\n    var points = [];\r\n    var i;\r\n    for (i = 0; i < lineCoords.length; i += 2) {\r\n        points.push(lineCoords[i + 1]);\r\n        points.push(lineCoords[i])\r\n    }\r\n    return points\r\n}\r\nmodule.exports = exports.default;\r\n"]},"metadata":{},"sourceType":"script"}