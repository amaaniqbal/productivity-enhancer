{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/helpers/range_data_calculator.js)\r\n * Version: 20.2.3\r\n * Build date: Tue Oct 20 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nexports.default = void 0;\n\nvar _utils = require(\"../../core/utils\");\n\nvar _type = require(\"../../../core/utils/type\");\n\nvar _common = require(\"../../../core/utils/common\");\n\nvar DISCRETE = \"discrete\";\nvar abs = Math.abs,\n    floor = Math.floor,\n    ceil = Math.ceil,\n    min = Math.min;\n\nfunction continuousRangeCalculator(range, minValue, maxValue) {\n  range.min = range.min < minValue ? range.min : minValue;\n  range.max = range.max > maxValue ? range.max : maxValue;\n}\n\nfunction createGetLogFunction(axisType, axis) {\n  if (\"logarithmic\" !== axisType) {\n    return null;\n  }\n\n  var base = axis.getOptions().logarithmBase;\n  return function (value) {\n    var log = (0, _utils.getLog)(abs(value), base);\n    var round = log < 0 ? floor : ceil;\n    return round(log);\n  };\n}\n\nfunction getRangeCalculator(axisType, axis, getLog) {\n  var rangeCalculator = continuousRangeCalculator;\n\n  if (axisType === DISCRETE) {\n    rangeCalculator = function rangeCalculator(range, minValue, maxValue) {\n      if (minValue !== maxValue) {\n        range.categories.push(maxValue);\n      }\n\n      range.categories.push(minValue);\n    };\n  } else {\n    if (axis) {\n      rangeCalculator = function rangeCalculator(range, value) {\n        var interval = axis.calculateInterval(value, range.prevValue);\n        var minInterval = range.interval;\n        range.interval = (minInterval < interval ? minInterval : interval) || minInterval;\n        range.prevValue = value;\n        continuousRangeCalculator(range, value, value);\n      };\n    }\n  }\n\n  if (getLog) {\n    return function (range, minValue, maxValue) {\n      var minArgs = [];\n      rangeCalculator(range, minValue, maxValue);\n      0 !== minValue && minArgs.push(getLog(minValue));\n      0 !== maxValue && minArgs.push(getLog(maxValue));\n      var linearThreshold = min.apply(null, minArgs);\n      range.linearThreshold = range.linearThreshold < linearThreshold ? range.linearThreshold : linearThreshold;\n    };\n  }\n\n  return rangeCalculator;\n}\n\nfunction getInitialRange(axisType, dataType, firstValue) {\n  var range = {\n    axisType: axisType,\n    dataType: dataType\n  };\n\n  if (axisType === DISCRETE) {\n    range.categories = [];\n  } else {\n    range.min = firstValue;\n    range.max = firstValue;\n  }\n\n  return range;\n}\n\nfunction processCategories(range) {\n  if (range.categories) {\n    range.categories = (0, _utils.unique)(range.categories);\n  }\n\n  return range;\n}\n\nfunction getValueForArgument(point, extraPoint, x, range) {\n  if (extraPoint && (0, _type.isDefined)(extraPoint.value)) {\n    var y1 = point.value;\n    var y2 = extraPoint.value;\n    var x1 = point.argument;\n    var x2 = extraPoint.argument;\n    var r = (x - x1) * (y2 - y1) / (x2 - x1) + y1.valueOf();\n    return \"datetime\" === range.dataType ? new Date(r) : r;\n  } else {\n    return point.value;\n  }\n}\n\nfunction calculateRangeBetweenPoints(rangeCalculator, range, point, prevPoint, bound) {\n  var value = getValueForArgument(point, prevPoint, bound, range);\n  rangeCalculator(range, value, value);\n}\n\nfunction isLineSeries(series) {\n  return series.type.toLowerCase().indexOf(\"line\") >= 0 || series.type.toLowerCase().indexOf(\"area\") >= 0;\n}\n\nfunction getViewportReducer(series) {\n  var rangeCalculator = getRangeCalculator(series.valueAxisType);\n  var argumentAxis = series.getArgumentAxis();\n  var viewport = argumentAxis && series.getArgumentAxis().visualRange() || {};\n  var calculatePointBetweenPoints = isLineSeries(series) ? calculateRangeBetweenPoints : _common.noop;\n\n  if (argumentAxis && argumentAxis.getMarginOptions().checkInterval) {\n    var range = series.getArgumentAxis().getTranslator().getBusinessRange();\n    var add = (0, _utils.getAddFunction)(range, false);\n    var interval = range.interval;\n\n    if (isFinite(interval) && (0, _type.isDefined)(viewport.startValue) && (0, _type.isDefined)(viewport.endValue)) {\n      viewport.startValue = add(viewport.startValue, interval, -1);\n      viewport.endValue = add(viewport.endValue, interval);\n    }\n  }\n\n  var viewportFilter = getViewPortFilter(viewport);\n  return function (range, point, index, points) {\n    var argument = point.argument;\n\n    if (!point.hasValue()) {\n      return range;\n    }\n\n    if (viewportFilter(argument)) {\n      if (!range.startCalc) {\n        range.startCalc = true;\n        calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue);\n      }\n\n      rangeCalculator(range, point.getMinValue(), point.getMaxValue());\n    } else {\n      if (!viewport.categories && (0, _type.isDefined)(viewport.startValue) && argument > viewport.startValue) {\n        if (!range.startCalc) {\n          calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue);\n        }\n\n        range.endCalc = true;\n        calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.endValue);\n      }\n    }\n\n    return range;\n  };\n}\n\nfunction getViewPortFilter(viewport) {\n  if (viewport.categories) {\n    var dictionary = viewport.categories.reduce(function (result, category) {\n      result[category.valueOf()] = true;\n      return result;\n    }, {});\n    return function (argument) {\n      return (0, _type.isDefined)(argument) && dictionary[argument.valueOf()];\n    };\n  }\n\n  if (!(0, _type.isDefined)(viewport.startValue) && !(0, _type.isDefined)(viewport.endValue)) {\n    return function () {\n      return true;\n    };\n  }\n\n  if (!(0, _type.isDefined)(viewport.endValue)) {\n    return function (argument) {\n      return argument >= viewport.startValue;\n    };\n  }\n\n  if (!(0, _type.isDefined)(viewport.startValue)) {\n    return function (argument) {\n      return argument <= viewport.endValue;\n    };\n  }\n\n  return function (argument) {\n    return argument >= viewport.startValue && argument <= viewport.endValue;\n  };\n}\n\nvar _default = {\n  getViewPortFilter: getViewPortFilter,\n  getArgumentRange: function getArgumentRange(series) {\n    var data = series._data || [];\n    var range = {};\n\n    if (data.length) {\n      if (series.argumentAxisType === DISCRETE) {\n        range = {\n          categories: data.map(function (item) {\n            return item.argument;\n          })\n        };\n      } else {\n        var interval;\n\n        if (data.length > 1) {\n          var i1 = series.getArgumentAxis().calculateInterval(data[0].argument, data[1].argument);\n          var i2 = series.getArgumentAxis().calculateInterval(data[data.length - 1].argument, data[data.length - 2].argument);\n          interval = min(i1, i2);\n        }\n\n        range = {\n          min: data[0].argument,\n          max: data[data.length - 1].argument,\n          interval: interval\n        };\n      }\n    }\n\n    return processCategories(range);\n  },\n  getRangeData: function getRangeData(series) {\n    var points = series.getPoints();\n    var useAggregation = series.useAggregation();\n    var argumentCalculator = getRangeCalculator(series.argumentAxisType, points.length > 1 && series.getArgumentAxis(), createGetLogFunction(series.argumentAxisType, series.getArgumentAxis()));\n    var valueRangeCalculator = getRangeCalculator(series.valueAxisType, null, createGetLogFunction(series.valueAxisType, series.getValueAxis()));\n    var viewportReducer = getViewportReducer(series);\n    var range = points.reduce(function (range, point, index, points) {\n      var argument = point.argument;\n\n      if (!point.isArgumentCorrect()) {\n        return range;\n      }\n\n      argumentCalculator(range.arg, argument, argument);\n\n      if (point.hasValue()) {\n        valueRangeCalculator(range.val, point.getMinValue(), point.getMaxValue());\n        viewportReducer(range.viewport, point, index, points);\n      }\n\n      return range;\n    }, {\n      arg: getInitialRange(series.argumentAxisType, series.argumentType),\n      val: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0),\n      viewport: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0)\n    });\n\n    if (useAggregation) {\n      var argumentRange = this.getArgumentRange(series);\n\n      if (series.argumentAxisType === DISCRETE) {\n        range.arg = argumentRange;\n      } else {\n        var viewport = series.getArgumentAxis().getViewport();\n\n        if ((0, _type.isDefined)(viewport.startValue) || (0, _type.isDefined)(viewport.length)) {\n          argumentCalculator(range.arg, argumentRange.min, argumentRange.min);\n        }\n\n        if ((0, _type.isDefined)(viewport.endValue) || (0, _type.isDefined)(viewport.length) && (0, _type.isDefined)(viewport.startValue)) {\n          argumentCalculator(range.arg, argumentRange.max, argumentRange.max);\n        }\n      }\n    }\n\n    processCategories(range.arg);\n    processCategories(range.val);\n    return range;\n  },\n  getViewport: function getViewport(series) {\n    var points = series.getPoints();\n    var range = {};\n    var reducer = getViewportReducer(series);\n    range = getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0);\n    points.some(function (point, index) {\n      reducer(range, point, index, points);\n      return range.endCalc;\n    });\n    return range;\n  },\n  getPointsInViewPort: function getPointsInViewPort(series) {\n    var argumentViewPortFilter = getViewPortFilter(series.getArgumentAxis().visualRange() || {});\n    var valueViewPort = series.getValueAxis().visualRange() || {};\n    var valueViewPortFilter = getViewPortFilter(valueViewPort);\n    var points = series.getPoints();\n\n    var addValue = function addValue(values, point, isEdge) {\n      var minValue = point.getMinValue();\n      var maxValue = point.getMaxValue();\n      var isMinValueInViewPort = valueViewPortFilter(minValue);\n      var isMaxValueInViewPort = valueViewPortFilter(maxValue);\n\n      if (isMinValueInViewPort) {\n        values.push(minValue);\n      }\n\n      if (maxValue !== minValue && isMaxValueInViewPort) {\n        values.push(maxValue);\n      }\n\n      if (isEdge && !isMinValueInViewPort && !isMaxValueInViewPort) {\n        if (!values.length) {\n          values.push(valueViewPort.startValue);\n        } else {\n          values.push(valueViewPort.endValue);\n        }\n      }\n    };\n\n    var addEdgePoints = isLineSeries(series) ? function (result, points, index) {\n      var point = points[index];\n      var prevPoint = points[index - 1];\n      var nextPoint = points[index + 1];\n\n      if (nextPoint && argumentViewPortFilter(nextPoint.argument)) {\n        addValue(result[1], point, true);\n      }\n\n      if (prevPoint && argumentViewPortFilter(prevPoint.argument)) {\n        addValue(result[1], point, true);\n      }\n    } : _common.noop;\n\n    var checkPointInViewport = function checkPointInViewport(result, point, index) {\n      if (argumentViewPortFilter(point.argument)) {\n        addValue(result[0], point);\n      } else {\n        addEdgePoints(result, points, index);\n      }\n\n      return result;\n    };\n\n    return points.reduce(checkPointInViewport, [[], []]);\n  }\n};\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"sources":["E:/Monday.com/quickstart-react/node_modules/devextreme/viz/series/helpers/range_data_calculator.js"],"names":["exports","default","_utils","require","_type","_common","DISCRETE","abs","Math","floor","ceil","min","continuousRangeCalculator","range","minValue","maxValue","max","createGetLogFunction","axisType","axis","base","getOptions","logarithmBase","value","log","getLog","round","getRangeCalculator","rangeCalculator","categories","push","interval","calculateInterval","prevValue","minInterval","minArgs","linearThreshold","apply","getInitialRange","dataType","firstValue","processCategories","unique","getValueForArgument","point","extraPoint","x","isDefined","y1","y2","x1","argument","x2","r","valueOf","Date","calculateRangeBetweenPoints","prevPoint","bound","isLineSeries","series","type","toLowerCase","indexOf","getViewportReducer","valueAxisType","argumentAxis","getArgumentAxis","viewport","visualRange","calculatePointBetweenPoints","noop","getMarginOptions","checkInterval","getTranslator","getBusinessRange","add","getAddFunction","isFinite","startValue","endValue","viewportFilter","getViewPortFilter","index","points","hasValue","startCalc","getMinValue","getMaxValue","endCalc","dictionary","reduce","result","category","_default","getArgumentRange","data","_data","length","argumentAxisType","map","item","i1","i2","getRangeData","getPoints","useAggregation","argumentCalculator","valueRangeCalculator","getValueAxis","viewportReducer","isArgumentCorrect","arg","val","argumentType","valueType","getValueRangeInitialValue","argumentRange","getViewport","reducer","some","getPointsInViewPort","argumentViewPortFilter","valueViewPort","valueViewPortFilter","addValue","values","isEdge","isMinValueInViewPort","isMaxValueInViewPort","addEdgePoints","nextPoint","checkPointInViewport","module"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/series/helpers/range_data_calculator.js)\r\n * Version: 20.2.3\r\n * Build date: Tue Oct 20 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nexports.default = void 0;\r\nvar _utils = require(\"../../core/utils\");\r\nvar _type = require(\"../../../core/utils/type\");\r\nvar _common = require(\"../../../core/utils/common\");\r\nvar DISCRETE = \"discrete\";\r\nvar abs = Math.abs,\r\n    floor = Math.floor,\r\n    ceil = Math.ceil,\r\n    min = Math.min;\r\n\r\nfunction continuousRangeCalculator(range, minValue, maxValue) {\r\n    range.min = range.min < minValue ? range.min : minValue;\r\n    range.max = range.max > maxValue ? range.max : maxValue\r\n}\r\n\r\nfunction createGetLogFunction(axisType, axis) {\r\n    if (\"logarithmic\" !== axisType) {\r\n        return null\r\n    }\r\n    var base = axis.getOptions().logarithmBase;\r\n    return function(value) {\r\n        var log = (0, _utils.getLog)(abs(value), base);\r\n        var round = log < 0 ? floor : ceil;\r\n        return round(log)\r\n    }\r\n}\r\n\r\nfunction getRangeCalculator(axisType, axis, getLog) {\r\n    var rangeCalculator = continuousRangeCalculator;\r\n    if (axisType === DISCRETE) {\r\n        rangeCalculator = function(range, minValue, maxValue) {\r\n            if (minValue !== maxValue) {\r\n                range.categories.push(maxValue)\r\n            }\r\n            range.categories.push(minValue)\r\n        }\r\n    } else {\r\n        if (axis) {\r\n            rangeCalculator = function(range, value) {\r\n                var interval = axis.calculateInterval(value, range.prevValue);\r\n                var minInterval = range.interval;\r\n                range.interval = (minInterval < interval ? minInterval : interval) || minInterval;\r\n                range.prevValue = value;\r\n                continuousRangeCalculator(range, value, value)\r\n            }\r\n        }\r\n    }\r\n    if (getLog) {\r\n        return function(range, minValue, maxValue) {\r\n            var minArgs = [];\r\n            rangeCalculator(range, minValue, maxValue);\r\n            0 !== minValue && minArgs.push(getLog(minValue));\r\n            0 !== maxValue && minArgs.push(getLog(maxValue));\r\n            var linearThreshold = min.apply(null, minArgs);\r\n            range.linearThreshold = range.linearThreshold < linearThreshold ? range.linearThreshold : linearThreshold\r\n        }\r\n    }\r\n    return rangeCalculator\r\n}\r\n\r\nfunction getInitialRange(axisType, dataType, firstValue) {\r\n    var range = {\r\n        axisType: axisType,\r\n        dataType: dataType\r\n    };\r\n    if (axisType === DISCRETE) {\r\n        range.categories = []\r\n    } else {\r\n        range.min = firstValue;\r\n        range.max = firstValue\r\n    }\r\n    return range\r\n}\r\n\r\nfunction processCategories(range) {\r\n    if (range.categories) {\r\n        range.categories = (0, _utils.unique)(range.categories)\r\n    }\r\n    return range\r\n}\r\n\r\nfunction getValueForArgument(point, extraPoint, x, range) {\r\n    if (extraPoint && (0, _type.isDefined)(extraPoint.value)) {\r\n        var y1 = point.value;\r\n        var y2 = extraPoint.value;\r\n        var x1 = point.argument;\r\n        var x2 = extraPoint.argument;\r\n        var r = (x - x1) * (y2 - y1) / (x2 - x1) + y1.valueOf();\r\n        return \"datetime\" === range.dataType ? new Date(r) : r\r\n    } else {\r\n        return point.value\r\n    }\r\n}\r\n\r\nfunction calculateRangeBetweenPoints(rangeCalculator, range, point, prevPoint, bound) {\r\n    var value = getValueForArgument(point, prevPoint, bound, range);\r\n    rangeCalculator(range, value, value)\r\n}\r\n\r\nfunction isLineSeries(series) {\r\n    return series.type.toLowerCase().indexOf(\"line\") >= 0 || series.type.toLowerCase().indexOf(\"area\") >= 0\r\n}\r\n\r\nfunction getViewportReducer(series) {\r\n    var rangeCalculator = getRangeCalculator(series.valueAxisType);\r\n    var argumentAxis = series.getArgumentAxis();\r\n    var viewport = argumentAxis && series.getArgumentAxis().visualRange() || {};\r\n    var calculatePointBetweenPoints = isLineSeries(series) ? calculateRangeBetweenPoints : _common.noop;\r\n    if (argumentAxis && argumentAxis.getMarginOptions().checkInterval) {\r\n        var range = series.getArgumentAxis().getTranslator().getBusinessRange();\r\n        var add = (0, _utils.getAddFunction)(range, false);\r\n        var interval = range.interval;\r\n        if (isFinite(interval) && (0, _type.isDefined)(viewport.startValue) && (0, _type.isDefined)(viewport.endValue)) {\r\n            viewport.startValue = add(viewport.startValue, interval, -1);\r\n            viewport.endValue = add(viewport.endValue, interval)\r\n        }\r\n    }\r\n    var viewportFilter = getViewPortFilter(viewport);\r\n    return function(range, point, index, points) {\r\n        var argument = point.argument;\r\n        if (!point.hasValue()) {\r\n            return range\r\n        }\r\n        if (viewportFilter(argument)) {\r\n            if (!range.startCalc) {\r\n                range.startCalc = true;\r\n                calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue)\r\n            }\r\n            rangeCalculator(range, point.getMinValue(), point.getMaxValue())\r\n        } else {\r\n            if (!viewport.categories && (0, _type.isDefined)(viewport.startValue) && argument > viewport.startValue) {\r\n                if (!range.startCalc) {\r\n                    calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue)\r\n                }\r\n                range.endCalc = true;\r\n                calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.endValue)\r\n            }\r\n        }\r\n        return range\r\n    }\r\n}\r\n\r\nfunction getViewPortFilter(viewport) {\r\n    if (viewport.categories) {\r\n        var dictionary = viewport.categories.reduce(function(result, category) {\r\n            result[category.valueOf()] = true;\r\n            return result\r\n        }, {});\r\n        return function(argument) {\r\n            return (0, _type.isDefined)(argument) && dictionary[argument.valueOf()]\r\n        }\r\n    }\r\n    if (!(0, _type.isDefined)(viewport.startValue) && !(0, _type.isDefined)(viewport.endValue)) {\r\n        return function() {\r\n            return true\r\n        }\r\n    }\r\n    if (!(0, _type.isDefined)(viewport.endValue)) {\r\n        return function(argument) {\r\n            return argument >= viewport.startValue\r\n        }\r\n    }\r\n    if (!(0, _type.isDefined)(viewport.startValue)) {\r\n        return function(argument) {\r\n            return argument <= viewport.endValue\r\n        }\r\n    }\r\n    return function(argument) {\r\n        return argument >= viewport.startValue && argument <= viewport.endValue\r\n    }\r\n}\r\nvar _default = {\r\n    getViewPortFilter: getViewPortFilter,\r\n    getArgumentRange: function(series) {\r\n        var data = series._data || [];\r\n        var range = {};\r\n        if (data.length) {\r\n            if (series.argumentAxisType === DISCRETE) {\r\n                range = {\r\n                    categories: data.map(function(item) {\r\n                        return item.argument\r\n                    })\r\n                }\r\n            } else {\r\n                var interval;\r\n                if (data.length > 1) {\r\n                    var i1 = series.getArgumentAxis().calculateInterval(data[0].argument, data[1].argument);\r\n                    var i2 = series.getArgumentAxis().calculateInterval(data[data.length - 1].argument, data[data.length - 2].argument);\r\n                    interval = min(i1, i2)\r\n                }\r\n                range = {\r\n                    min: data[0].argument,\r\n                    max: data[data.length - 1].argument,\r\n                    interval: interval\r\n                }\r\n            }\r\n        }\r\n        return processCategories(range)\r\n    },\r\n    getRangeData: function(series) {\r\n        var points = series.getPoints();\r\n        var useAggregation = series.useAggregation();\r\n        var argumentCalculator = getRangeCalculator(series.argumentAxisType, points.length > 1 && series.getArgumentAxis(), createGetLogFunction(series.argumentAxisType, series.getArgumentAxis()));\r\n        var valueRangeCalculator = getRangeCalculator(series.valueAxisType, null, createGetLogFunction(series.valueAxisType, series.getValueAxis()));\r\n        var viewportReducer = getViewportReducer(series);\r\n        var range = points.reduce(function(range, point, index, points) {\r\n            var argument = point.argument;\r\n            if (!point.isArgumentCorrect()) {\r\n                return range\r\n            }\r\n            argumentCalculator(range.arg, argument, argument);\r\n            if (point.hasValue()) {\r\n                valueRangeCalculator(range.val, point.getMinValue(), point.getMaxValue());\r\n                viewportReducer(range.viewport, point, index, points)\r\n            }\r\n            return range\r\n        }, {\r\n            arg: getInitialRange(series.argumentAxisType, series.argumentType),\r\n            val: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0),\r\n            viewport: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0)\r\n        });\r\n        if (useAggregation) {\r\n            var argumentRange = this.getArgumentRange(series);\r\n            if (series.argumentAxisType === DISCRETE) {\r\n                range.arg = argumentRange\r\n            } else {\r\n                var viewport = series.getArgumentAxis().getViewport();\r\n                if ((0, _type.isDefined)(viewport.startValue) || (0, _type.isDefined)(viewport.length)) {\r\n                    argumentCalculator(range.arg, argumentRange.min, argumentRange.min)\r\n                }\r\n                if ((0, _type.isDefined)(viewport.endValue) || (0, _type.isDefined)(viewport.length) && (0, _type.isDefined)(viewport.startValue)) {\r\n                    argumentCalculator(range.arg, argumentRange.max, argumentRange.max)\r\n                }\r\n            }\r\n        }\r\n        processCategories(range.arg);\r\n        processCategories(range.val);\r\n        return range\r\n    },\r\n    getViewport: function(series) {\r\n        var points = series.getPoints();\r\n        var range = {};\r\n        var reducer = getViewportReducer(series);\r\n        range = getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0);\r\n        points.some(function(point, index) {\r\n            reducer(range, point, index, points);\r\n            return range.endCalc\r\n        });\r\n        return range\r\n    },\r\n    getPointsInViewPort: function(series) {\r\n        var argumentViewPortFilter = getViewPortFilter(series.getArgumentAxis().visualRange() || {});\r\n        var valueViewPort = series.getValueAxis().visualRange() || {};\r\n        var valueViewPortFilter = getViewPortFilter(valueViewPort);\r\n        var points = series.getPoints();\r\n        var addValue = function(values, point, isEdge) {\r\n            var minValue = point.getMinValue();\r\n            var maxValue = point.getMaxValue();\r\n            var isMinValueInViewPort = valueViewPortFilter(minValue);\r\n            var isMaxValueInViewPort = valueViewPortFilter(maxValue);\r\n            if (isMinValueInViewPort) {\r\n                values.push(minValue)\r\n            }\r\n            if (maxValue !== minValue && isMaxValueInViewPort) {\r\n                values.push(maxValue)\r\n            }\r\n            if (isEdge && !isMinValueInViewPort && !isMaxValueInViewPort) {\r\n                if (!values.length) {\r\n                    values.push(valueViewPort.startValue)\r\n                } else {\r\n                    values.push(valueViewPort.endValue)\r\n                }\r\n            }\r\n        };\r\n        var addEdgePoints = isLineSeries(series) ? function(result, points, index) {\r\n            var point = points[index];\r\n            var prevPoint = points[index - 1];\r\n            var nextPoint = points[index + 1];\r\n            if (nextPoint && argumentViewPortFilter(nextPoint.argument)) {\r\n                addValue(result[1], point, true)\r\n            }\r\n            if (prevPoint && argumentViewPortFilter(prevPoint.argument)) {\r\n                addValue(result[1], point, true)\r\n            }\r\n        } : _common.noop;\r\n        var checkPointInViewport = function(result, point, index) {\r\n            if (argumentViewPortFilter(point.argument)) {\r\n                addValue(result[0], point)\r\n            } else {\r\n                addEdgePoints(result, points, index)\r\n            }\r\n            return result\r\n        };\r\n        return points.reduce(checkPointInViewport, [\r\n            [],\r\n            []\r\n        ])\r\n    }\r\n};\r\nexports.default = _default;\r\nmodule.exports = exports.default;\r\n"]},"metadata":{},"sourceType":"script"}