{"ast":null,"code":"/**\r\n * DevExtreme (viz/components/data_validator.js)\r\n * Version: 20.2.3\r\n * Build date: Tue Oct 20 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nexports.validateData = validateData;\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _utils = require(\"../core/utils\");\n\nvar _parse_utils = require(\"./parse_utils\");\n\nvar STRING = \"string\";\nvar NUMERIC = \"numeric\";\nvar DATETIME = \"datetime\";\nvar DISCRETE = \"discrete\";\nvar SEMIDISCRETE = \"semidiscrete\";\nvar CONTINUOUS = \"continuous\";\nvar LOGARITHMIC = \"logarithmic\";\nvar VALUE_TYPE = \"valueType\";\nvar ARGUMENT_TYPE = \"argumentType\";\nvar axisTypeParser = (0, _utils.enumParser)([STRING, NUMERIC, DATETIME]);\nvar _isArray = Array.isArray;\n\nfunction groupingValues(data, others, valueField, index) {\n  if (index >= 0) {\n    data.slice(index).forEach(function (cell) {\n      if ((0, _type.isDefined)(cell[valueField])) {\n        others[valueField] += cell[valueField];\n        cell[valueField] = void 0;\n      }\n    });\n  }\n}\n\nfunction processGroups(groups) {\n  groups.forEach(function (group) {\n    group.valueType = group.valueAxisType = null;\n    group.series.forEach(function (series) {\n      series.updateDataType({});\n    });\n    group.valueAxis && group.valueAxis.resetTypes(VALUE_TYPE);\n  });\n}\n\nfunction sortValues(data, asc, selector) {\n  var func = asc ? function (a, b) {\n    return a - b;\n  } : function (a, b) {\n    return b - a;\n  };\n  data.sort(function (a, b) {\n    var valA = selector(a);\n    var valB = selector(b);\n    var aa = (0, _type.isDefined)(valA) ? 1 : 0;\n    var bb = (0, _type.isDefined)(valB) ? 1 : 0;\n    return aa && bb ? func(valA, valB) : func(aa, bb);\n  });\n  return data;\n}\n\nfunction resetArgumentAxes(axes) {\n  axes && axes.forEach(function (axis) {\n    axis.resetTypes(ARGUMENT_TYPE);\n  });\n}\n\nfunction parseCategories(categories, parser) {\n  var newArray = [];\n  categories.forEach(function (category) {\n    var parsedCategory = parser(category);\n    void 0 !== parsedCategory && newArray.push(parsedCategory);\n  });\n  return newArray;\n}\n\nfunction parseAxisCategories(groupsData, parsers) {\n  var argumentCategories = groupsData.argumentOptions && groupsData.argumentOptions.categories;\n  groupsData.groups.forEach(function (valueGroup, i) {\n    var categories = valueGroup.valueOptions && valueGroup.valueOptions.categories;\n\n    if (categories) {\n      valueGroup.valueOptions.categories = parseCategories(categories, parsers[i + 1]);\n    }\n  });\n\n  if (argumentCategories) {\n    groupsData.argumentOptions.categories = parseCategories(argumentCategories, parsers[0]);\n  }\n}\n\nfunction eigen(x) {\n  return x;\n}\n\nfunction getType(unit, type) {\n  var result = type;\n\n  if (type === STRING || (0, _type.isString)(unit)) {\n    result = STRING;\n  } else {\n    if (type === DATETIME || (0, _type.isDate)(unit)) {\n      result = DATETIME;\n    } else {\n      if ((0, _type.isNumeric)(unit)) {\n        result = NUMERIC;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction correctAxisType(type, axisType, hasCategories, incidentOccurred) {\n  if (type === STRING && (axisType === CONTINUOUS || axisType === LOGARITHMIC || axisType === SEMIDISCRETE)) {\n    incidentOccurred(\"E2002\");\n  }\n\n  return axisType === LOGARITHMIC ? LOGARITHMIC : hasCategories || axisType === DISCRETE || type === STRING ? DISCRETE : axisType === SEMIDISCRETE ? SEMIDISCRETE : CONTINUOUS;\n}\n\nfunction validUnit(unit, field, incidentOccurred) {\n  if (unit) {\n    incidentOccurred(!(0, _type.isNumeric)(unit) && !(0, _type.isDate)(unit) && !(0, _type.isString)(unit) ? \"E2003\" : \"E2004\", [field]);\n  }\n}\n\nfunction createParserUnit(type, axisType, incidentOccurred) {\n  var parser = type ? (0, _parse_utils.getParser)(type) : eigen;\n  var filterInfinity = axisType !== DISCRETE ? function (x) {\n    return isFinite(x) || void 0 === x ? x : null;\n  } : eigen;\n  return function (unit, field) {\n    var parseUnit = filterInfinity(parser(unit));\n\n    if (void 0 === parseUnit) {\n      validUnit(unit, field, incidentOccurred);\n    }\n\n    return parseUnit;\n  };\n}\n\nfunction prepareParsers(groupsData, incidentOccurred) {\n  var argumentParser = createParserUnit(groupsData.argumentType, groupsData.argumentAxisType, incidentOccurred);\n  var sizeParser;\n  var valueParser;\n  var categoryParsers = [argumentParser];\n  var cache = {};\n  var list = [];\n  groupsData.groups.forEach(function (group, groupIndex) {\n    group.series.forEach(function (series) {\n      valueParser = createParserUnit(group.valueType, group.valueAxisType, incidentOccurred);\n      sizeParser = createParserUnit(NUMERIC, CONTINUOUS, incidentOccurred);\n      cache[series.getArgumentField()] = argumentParser;\n      series.getValueFields().forEach(function (field) {\n        categoryParsers[groupIndex + 1] = valueParser;\n        cache[field] = valueParser;\n      });\n\n      if (series.getSizeField()) {\n        cache[series.getSizeField()] = sizeParser;\n      }\n    });\n  });\n\n  for (var field in cache) {\n    list.push([field, cache[field]]);\n  }\n\n  list.length && parseAxisCategories(groupsData, categoryParsers);\n  return list;\n}\n\nfunction getParsedCell(cell, parsers) {\n  var i;\n  var ii = parsers.length;\n  var obj = (0, _extend.extend)({}, cell);\n  var field;\n  var value;\n\n  for (i = 0; i < ii; ++i) {\n    field = parsers[i][0];\n    value = cell[field];\n    obj[field] = parsers[i][1](value, field);\n  }\n\n  return obj;\n}\n\nfunction parse(data, parsers) {\n  var parsedData = [];\n  var i;\n  var ii = data.length;\n  parsedData.length = ii;\n\n  for (i = 0; i < ii; ++i) {\n    parsedData[i] = getParsedCell(data[i], parsers);\n  }\n\n  return parsedData;\n}\n\nfunction findIndexByThreshold(data, valueField, threshold) {\n  var i;\n  var ii = data.length;\n  var value;\n\n  for (i = 0; i < ii; ++i) {\n    value = data[i][valueField];\n\n    if ((0, _type.isDefined)(value) && threshold > value) {\n      break;\n    }\n  }\n\n  return i;\n}\n\nfunction groupMinSlices(originalData, argumentField, valueField, smallValuesGrouping) {\n  smallValuesGrouping = smallValuesGrouping || {};\n  var mode = smallValuesGrouping.mode;\n  var others = {};\n\n  if (!mode || \"none\" === mode) {\n    return;\n  }\n\n  others[argumentField] = String(smallValuesGrouping.groupName || \"others\");\n  others[valueField] = 0;\n  var data = sortValues(originalData.slice(), false, function (a) {\n    return a[valueField];\n  });\n  groupingValues(data, others, valueField, \"smallValueThreshold\" === mode ? findIndexByThreshold(data, valueField, smallValuesGrouping.threshold) : smallValuesGrouping.topCount);\n  others[valueField] && originalData.push(others);\n}\n\nfunction groupPieData(data, groupsData) {\n  var firstSeries = groupsData.groups[0] && groupsData.groups[0].series[0];\n  var isPie = firstSeries && (\"pie\" === firstSeries.type || \"doughnut\" === firstSeries.type || \"donut\" === firstSeries.type);\n\n  if (!isPie) {\n    return;\n  }\n\n  groupsData.groups.forEach(function (group) {\n    group.series.forEach(function (series) {\n      groupMinSlices(data, series.getArgumentField(), series.getValueFields()[0], series.getOptions().smallValuesGrouping);\n    });\n  });\n}\n\nfunction addUniqueItemToCollection(item, collection, itemsHash) {\n  if (!itemsHash[item]) {\n    collection.push(item);\n    itemsHash[item] = true;\n  }\n}\n\nfunction getUniqueArgumentFields(groupsData) {\n  var uniqueArgumentFields = [];\n  var hash = {};\n  groupsData.groups.forEach(function (group) {\n    group.series.forEach(function (series) {\n      addUniqueItemToCollection(series.getArgumentField(), uniqueArgumentFields, hash);\n    });\n  });\n  return uniqueArgumentFields;\n}\n\nfunction sort(a, b) {\n  var result = a - b;\n\n  if (isNaN(result)) {\n    if (!(0, _type.isDefined)(a)) {\n      return 1;\n    }\n\n    if (!(0, _type.isDefined)(b)) {\n      return -1;\n    }\n\n    return 0;\n  }\n\n  return result;\n}\n\nfunction sortByArgument(data, argumentField) {\n  return data.slice().sort(function (a, b) {\n    return sort(a[argumentField], b[argumentField]);\n  });\n}\n\nfunction sortByCallback(data, callback) {\n  return data.slice().sort(callback);\n}\n\nfunction checkValueTypeOfGroup(group, cell) {\n  group.series.forEach(function (series) {\n    series.getValueFields().forEach(function (field) {\n      group.valueType = getType(cell[field], group.valueType);\n    });\n  });\n  return group.valueType;\n}\n\nfunction getSortByCategories(categories) {\n  var hash = {};\n  categories.forEach(function (value, i) {\n    hash[value] = i;\n  });\n  return function (data, argumentField) {\n    return sortValues(data.slice(), true, function (a) {\n      return hash[a[argumentField]];\n    });\n  };\n}\n\nfunction sortData(data, groupsData, options, uniqueArgumentFields) {\n  var dataByArguments = {};\n  var isDiscrete = groupsData.argumentAxisType === DISCRETE;\n  var userCategories = isDiscrete && groupsData.argumentOptions && groupsData.argumentOptions.categories;\n\n  var sortFunction = function sortFunction(data) {\n    return data;\n  };\n\n  var sortingMethodOption = options.sortingMethod;\n  var reSortCategories;\n\n  if (!userCategories && (0, _type.isFunction)(sortingMethodOption)) {\n    data = sortByCallback(data, sortingMethodOption);\n  }\n\n  if (isDiscrete) {\n    groupsData.categories = getCategories(data, uniqueArgumentFields, userCategories);\n  }\n\n  if (userCategories || !(0, _type.isFunction)(sortingMethodOption) && groupsData.argumentType === STRING && !options._skipArgumentSorting) {\n    sortFunction = getSortByCategories(groupsData.categories);\n  } else {\n    if (true === sortingMethodOption && groupsData.argumentType !== STRING) {\n      sortFunction = sortByArgument;\n      reSortCategories = isDiscrete;\n    }\n  }\n\n  uniqueArgumentFields.forEach(function (field) {\n    dataByArguments[field] = sortFunction(data, field);\n  });\n\n  if (reSortCategories) {\n    groupsData.categories = groupsData.categories.sort(sort);\n  }\n\n  return dataByArguments;\n}\n\nfunction checkItemExistence(collection, item) {\n  return collection.map(function (collectionItem) {\n    return collectionItem.valueOf();\n  }).indexOf(item.valueOf()) === -1;\n}\n\nfunction getCategories(data, uniqueArgumentFields, userCategories) {\n  var categories = userCategories ? userCategories.slice() : [];\n  uniqueArgumentFields.forEach(function (field) {\n    data.forEach(function (item) {\n      var dataItem = item[field];\n      (0, _type.isDefined)(dataItem) && checkItemExistence(categories, dataItem) && categories.push(dataItem);\n    });\n  });\n  return categories;\n}\n\nfunction checkArgumentTypeOfGroup(series, cell, groupsData) {\n  series.forEach(function (currentSeries) {\n    groupsData.argumentType = getType(cell[currentSeries.getArgumentField()], groupsData.argumentType);\n  });\n  return groupsData.argumentType;\n}\n\nfunction checkType(data, groupsData, checkTypeForAllData) {\n  var groupsWithUndefinedValueType = [];\n  var groupsWithUndefinedArgumentType = [];\n  var argumentTypeGroup = groupsData.argumentOptions && axisTypeParser(groupsData.argumentOptions.argumentType);\n  var groupsIndexes;\n  groupsData.groups.forEach(function (group) {\n    if (!group.series.length) {\n      return;\n    }\n\n    var valueTypeGroup = group.valueOptions && axisTypeParser(group.valueOptions.valueType);\n    group.valueType = valueTypeGroup;\n    groupsData.argumentType = argumentTypeGroup;\n    !valueTypeGroup && groupsWithUndefinedValueType.push(group);\n    !argumentTypeGroup && groupsWithUndefinedArgumentType.push(group);\n  });\n\n  if (groupsWithUndefinedValueType.length || groupsWithUndefinedArgumentType.length) {\n    groupsIndexes = groupsWithUndefinedValueType.map(function (_, index) {\n      return index;\n    });\n    data.some(function (cell) {\n      var defineArg;\n      groupsWithUndefinedValueType.forEach(function (group, groupIndex) {\n        if (checkValueTypeOfGroup(group, cell) && groupsIndexes.indexOf(groupIndex) >= 0) {\n          groupsIndexes.splice(groupIndex, 1);\n        }\n      });\n\n      if (!defineArg) {\n        groupsWithUndefinedArgumentType.forEach(function (group) {\n          defineArg = checkArgumentTypeOfGroup(group.series, cell, groupsData);\n        });\n      }\n\n      if (!checkTypeForAllData && defineArg && 0 === groupsIndexes.length) {\n        return true;\n      }\n    });\n  }\n}\n\nfunction checkAxisType(groupsData, incidentOccurred) {\n  var argumentOptions = groupsData.argumentOptions || {};\n  var userArgumentCategories = argumentOptions && argumentOptions.categories || [];\n  var argumentAxisType = correctAxisType(groupsData.argumentType, argumentOptions.type, !!userArgumentCategories.length, incidentOccurred);\n  groupsData.groups.forEach(function (group) {\n    var valueOptions = group.valueOptions || {};\n    var valueCategories = valueOptions.categories || [];\n    var valueAxisType = correctAxisType(group.valueType, valueOptions.type, !!valueCategories.length, incidentOccurred);\n    group.series.forEach(function (series) {\n      var optionsSeries = {};\n      optionsSeries.argumentAxisType = argumentAxisType;\n      optionsSeries.valueAxisType = valueAxisType;\n      groupsData.argumentAxisType = groupsData.argumentAxisType || optionsSeries.argumentAxisType;\n      group.valueAxisType = group.valueAxisType || optionsSeries.valueAxisType;\n      optionsSeries.argumentType = groupsData.argumentType;\n      optionsSeries.valueType = group.valueType;\n      optionsSeries.showZero = valueOptions.showZero;\n      series.updateDataType(optionsSeries);\n    });\n    group.valueAxisType = group.valueAxisType || valueAxisType;\n\n    if (group.valueAxis) {\n      group.valueAxis.setTypes(group.valueAxisType, group.valueType, VALUE_TYPE);\n      group.valueAxis.validate();\n    }\n  });\n  groupsData.argumentAxisType = groupsData.argumentAxisType || argumentAxisType;\n\n  if (groupsData.argumentAxes) {\n    groupsData.argumentAxes.forEach(function (axis) {\n      axis.setTypes(groupsData.argumentAxisType, groupsData.argumentType, ARGUMENT_TYPE);\n      axis.validate();\n    });\n  }\n}\n\nfunction verifyData(source, incidentOccurred) {\n  var data = [];\n  var sourceIsDefined = (0, _type.isDefined)(source);\n  var hasError = sourceIsDefined && !_isArray(source);\n  var i;\n  var ii;\n  var k;\n  var item;\n\n  if (sourceIsDefined && !hasError) {\n    for (i = 0, ii = source.length, k = 0; i < ii; ++i) {\n      item = source[i];\n\n      if ((0, _type.isObject)(item)) {\n        data[k++] = item;\n      } else {\n        if (item) {\n          hasError = true;\n        }\n      }\n    }\n  }\n\n  if (hasError) {\n    incidentOccurred(\"E2001\");\n  }\n\n  return data;\n}\n\nfunction validateData(data, groupsData, incidentOccurred, options) {\n  data = verifyData(data, incidentOccurred);\n  groupsData.argumentType = groupsData.argumentAxisType = null;\n  processGroups(groupsData.groups);\n  resetArgumentAxes(groupsData.argumentAxes);\n  checkType(data, groupsData, options.checkTypeForAllData);\n  checkAxisType(groupsData, incidentOccurred);\n\n  if (options.convertToAxisDataType) {\n    data = parse(data, prepareParsers(groupsData, incidentOccurred));\n  }\n\n  groupPieData(data, groupsData);\n  var dataByArgumentFields = sortData(data, groupsData, options, getUniqueArgumentFields(groupsData));\n  return dataByArgumentFields;\n}","map":{"version":3,"sources":["E:/Monday.com/quickstart-react/node_modules/devextreme/viz/components/data_validator.js"],"names":["exports","validateData","_type","require","_extend","_utils","_parse_utils","STRING","NUMERIC","DATETIME","DISCRETE","SEMIDISCRETE","CONTINUOUS","LOGARITHMIC","VALUE_TYPE","ARGUMENT_TYPE","axisTypeParser","enumParser","_isArray","Array","isArray","groupingValues","data","others","valueField","index","slice","forEach","cell","isDefined","processGroups","groups","group","valueType","valueAxisType","series","updateDataType","valueAxis","resetTypes","sortValues","asc","selector","func","a","b","sort","valA","valB","aa","bb","resetArgumentAxes","axes","axis","parseCategories","categories","parser","newArray","category","parsedCategory","push","parseAxisCategories","groupsData","parsers","argumentCategories","argumentOptions","valueGroup","i","valueOptions","eigen","x","getType","unit","type","result","isString","isDate","isNumeric","correctAxisType","axisType","hasCategories","incidentOccurred","validUnit","field","createParserUnit","getParser","filterInfinity","isFinite","parseUnit","prepareParsers","argumentParser","argumentType","argumentAxisType","sizeParser","valueParser","categoryParsers","cache","list","groupIndex","getArgumentField","getValueFields","getSizeField","length","getParsedCell","ii","obj","extend","value","parse","parsedData","findIndexByThreshold","threshold","groupMinSlices","originalData","argumentField","smallValuesGrouping","mode","String","groupName","topCount","groupPieData","firstSeries","isPie","getOptions","addUniqueItemToCollection","item","collection","itemsHash","getUniqueArgumentFields","uniqueArgumentFields","hash","isNaN","sortByArgument","sortByCallback","callback","checkValueTypeOfGroup","getSortByCategories","sortData","options","dataByArguments","isDiscrete","userCategories","sortFunction","sortingMethodOption","sortingMethod","reSortCategories","isFunction","getCategories","_skipArgumentSorting","checkItemExistence","map","collectionItem","valueOf","indexOf","dataItem","checkArgumentTypeOfGroup","currentSeries","checkType","checkTypeForAllData","groupsWithUndefinedValueType","groupsWithUndefinedArgumentType","argumentTypeGroup","groupsIndexes","valueTypeGroup","_","some","defineArg","splice","checkAxisType","userArgumentCategories","valueCategories","optionsSeries","showZero","setTypes","validate","argumentAxes","verifyData","source","sourceIsDefined","hasError","k","isObject","convertToAxisDataType","dataByArgumentFields"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/components/data_validator.js)\r\n * Version: 20.2.3\r\n * Build date: Tue Oct 20 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nexports.validateData = validateData;\r\nvar _type = require(\"../../core/utils/type\");\r\nvar _extend = require(\"../../core/utils/extend\");\r\nvar _utils = require(\"../core/utils\");\r\nvar _parse_utils = require(\"./parse_utils\");\r\nvar STRING = \"string\";\r\nvar NUMERIC = \"numeric\";\r\nvar DATETIME = \"datetime\";\r\nvar DISCRETE = \"discrete\";\r\nvar SEMIDISCRETE = \"semidiscrete\";\r\nvar CONTINUOUS = \"continuous\";\r\nvar LOGARITHMIC = \"logarithmic\";\r\nvar VALUE_TYPE = \"valueType\";\r\nvar ARGUMENT_TYPE = \"argumentType\";\r\nvar axisTypeParser = (0, _utils.enumParser)([STRING, NUMERIC, DATETIME]);\r\nvar _isArray = Array.isArray;\r\n\r\nfunction groupingValues(data, others, valueField, index) {\r\n    if (index >= 0) {\r\n        data.slice(index).forEach(function(cell) {\r\n            if ((0, _type.isDefined)(cell[valueField])) {\r\n                others[valueField] += cell[valueField];\r\n                cell[valueField] = void 0\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nfunction processGroups(groups) {\r\n    groups.forEach(function(group) {\r\n        group.valueType = group.valueAxisType = null;\r\n        group.series.forEach(function(series) {\r\n            series.updateDataType({})\r\n        });\r\n        group.valueAxis && group.valueAxis.resetTypes(VALUE_TYPE)\r\n    })\r\n}\r\n\r\nfunction sortValues(data, asc, selector) {\r\n    var func = asc ? function(a, b) {\r\n        return a - b\r\n    } : function(a, b) {\r\n        return b - a\r\n    };\r\n    data.sort(function(a, b) {\r\n        var valA = selector(a);\r\n        var valB = selector(b);\r\n        var aa = (0, _type.isDefined)(valA) ? 1 : 0;\r\n        var bb = (0, _type.isDefined)(valB) ? 1 : 0;\r\n        return aa && bb ? func(valA, valB) : func(aa, bb)\r\n    });\r\n    return data\r\n}\r\n\r\nfunction resetArgumentAxes(axes) {\r\n    axes && axes.forEach(function(axis) {\r\n        axis.resetTypes(ARGUMENT_TYPE)\r\n    })\r\n}\r\n\r\nfunction parseCategories(categories, parser) {\r\n    var newArray = [];\r\n    categories.forEach(function(category) {\r\n        var parsedCategory = parser(category);\r\n        void 0 !== parsedCategory && newArray.push(parsedCategory)\r\n    });\r\n    return newArray\r\n}\r\n\r\nfunction parseAxisCategories(groupsData, parsers) {\r\n    var argumentCategories = groupsData.argumentOptions && groupsData.argumentOptions.categories;\r\n    groupsData.groups.forEach(function(valueGroup, i) {\r\n        var categories = valueGroup.valueOptions && valueGroup.valueOptions.categories;\r\n        if (categories) {\r\n            valueGroup.valueOptions.categories = parseCategories(categories, parsers[i + 1])\r\n        }\r\n    });\r\n    if (argumentCategories) {\r\n        groupsData.argumentOptions.categories = parseCategories(argumentCategories, parsers[0])\r\n    }\r\n}\r\n\r\nfunction eigen(x) {\r\n    return x\r\n}\r\n\r\nfunction getType(unit, type) {\r\n    var result = type;\r\n    if (type === STRING || (0, _type.isString)(unit)) {\r\n        result = STRING\r\n    } else {\r\n        if (type === DATETIME || (0, _type.isDate)(unit)) {\r\n            result = DATETIME\r\n        } else {\r\n            if ((0, _type.isNumeric)(unit)) {\r\n                result = NUMERIC\r\n            }\r\n        }\r\n    }\r\n    return result\r\n}\r\n\r\nfunction correctAxisType(type, axisType, hasCategories, incidentOccurred) {\r\n    if (type === STRING && (axisType === CONTINUOUS || axisType === LOGARITHMIC || axisType === SEMIDISCRETE)) {\r\n        incidentOccurred(\"E2002\")\r\n    }\r\n    return axisType === LOGARITHMIC ? LOGARITHMIC : hasCategories || axisType === DISCRETE || type === STRING ? DISCRETE : axisType === SEMIDISCRETE ? SEMIDISCRETE : CONTINUOUS\r\n}\r\n\r\nfunction validUnit(unit, field, incidentOccurred) {\r\n    if (unit) {\r\n        incidentOccurred(!(0, _type.isNumeric)(unit) && !(0, _type.isDate)(unit) && !(0, _type.isString)(unit) ? \"E2003\" : \"E2004\", [field])\r\n    }\r\n}\r\n\r\nfunction createParserUnit(type, axisType, incidentOccurred) {\r\n    var parser = type ? (0, _parse_utils.getParser)(type) : eigen;\r\n    var filterInfinity = axisType !== DISCRETE ? function(x) {\r\n        return isFinite(x) || void 0 === x ? x : null\r\n    } : eigen;\r\n    return function(unit, field) {\r\n        var parseUnit = filterInfinity(parser(unit));\r\n        if (void 0 === parseUnit) {\r\n            validUnit(unit, field, incidentOccurred)\r\n        }\r\n        return parseUnit\r\n    }\r\n}\r\n\r\nfunction prepareParsers(groupsData, incidentOccurred) {\r\n    var argumentParser = createParserUnit(groupsData.argumentType, groupsData.argumentAxisType, incidentOccurred);\r\n    var sizeParser;\r\n    var valueParser;\r\n    var categoryParsers = [argumentParser];\r\n    var cache = {};\r\n    var list = [];\r\n    groupsData.groups.forEach(function(group, groupIndex) {\r\n        group.series.forEach(function(series) {\r\n            valueParser = createParserUnit(group.valueType, group.valueAxisType, incidentOccurred);\r\n            sizeParser = createParserUnit(NUMERIC, CONTINUOUS, incidentOccurred);\r\n            cache[series.getArgumentField()] = argumentParser;\r\n            series.getValueFields().forEach(function(field) {\r\n                categoryParsers[groupIndex + 1] = valueParser;\r\n                cache[field] = valueParser\r\n            });\r\n            if (series.getSizeField()) {\r\n                cache[series.getSizeField()] = sizeParser\r\n            }\r\n        })\r\n    });\r\n    for (var field in cache) {\r\n        list.push([field, cache[field]])\r\n    }\r\n    list.length && parseAxisCategories(groupsData, categoryParsers);\r\n    return list\r\n}\r\n\r\nfunction getParsedCell(cell, parsers) {\r\n    var i;\r\n    var ii = parsers.length;\r\n    var obj = (0, _extend.extend)({}, cell);\r\n    var field;\r\n    var value;\r\n    for (i = 0; i < ii; ++i) {\r\n        field = parsers[i][0];\r\n        value = cell[field];\r\n        obj[field] = parsers[i][1](value, field)\r\n    }\r\n    return obj\r\n}\r\n\r\nfunction parse(data, parsers) {\r\n    var parsedData = [];\r\n    var i;\r\n    var ii = data.length;\r\n    parsedData.length = ii;\r\n    for (i = 0; i < ii; ++i) {\r\n        parsedData[i] = getParsedCell(data[i], parsers)\r\n    }\r\n    return parsedData\r\n}\r\n\r\nfunction findIndexByThreshold(data, valueField, threshold) {\r\n    var i;\r\n    var ii = data.length;\r\n    var value;\r\n    for (i = 0; i < ii; ++i) {\r\n        value = data[i][valueField];\r\n        if ((0, _type.isDefined)(value) && threshold > value) {\r\n            break\r\n        }\r\n    }\r\n    return i\r\n}\r\n\r\nfunction groupMinSlices(originalData, argumentField, valueField, smallValuesGrouping) {\r\n    smallValuesGrouping = smallValuesGrouping || {};\r\n    var mode = smallValuesGrouping.mode;\r\n    var others = {};\r\n    if (!mode || \"none\" === mode) {\r\n        return\r\n    }\r\n    others[argumentField] = String(smallValuesGrouping.groupName || \"others\");\r\n    others[valueField] = 0;\r\n    var data = sortValues(originalData.slice(), false, function(a) {\r\n        return a[valueField]\r\n    });\r\n    groupingValues(data, others, valueField, \"smallValueThreshold\" === mode ? findIndexByThreshold(data, valueField, smallValuesGrouping.threshold) : smallValuesGrouping.topCount);\r\n    others[valueField] && originalData.push(others)\r\n}\r\n\r\nfunction groupPieData(data, groupsData) {\r\n    var firstSeries = groupsData.groups[0] && groupsData.groups[0].series[0];\r\n    var isPie = firstSeries && (\"pie\" === firstSeries.type || \"doughnut\" === firstSeries.type || \"donut\" === firstSeries.type);\r\n    if (!isPie) {\r\n        return\r\n    }\r\n    groupsData.groups.forEach(function(group) {\r\n        group.series.forEach(function(series) {\r\n            groupMinSlices(data, series.getArgumentField(), series.getValueFields()[0], series.getOptions().smallValuesGrouping)\r\n        })\r\n    })\r\n}\r\n\r\nfunction addUniqueItemToCollection(item, collection, itemsHash) {\r\n    if (!itemsHash[item]) {\r\n        collection.push(item);\r\n        itemsHash[item] = true\r\n    }\r\n}\r\n\r\nfunction getUniqueArgumentFields(groupsData) {\r\n    var uniqueArgumentFields = [];\r\n    var hash = {};\r\n    groupsData.groups.forEach(function(group) {\r\n        group.series.forEach(function(series) {\r\n            addUniqueItemToCollection(series.getArgumentField(), uniqueArgumentFields, hash)\r\n        })\r\n    });\r\n    return uniqueArgumentFields\r\n}\r\n\r\nfunction sort(a, b) {\r\n    var result = a - b;\r\n    if (isNaN(result)) {\r\n        if (!(0, _type.isDefined)(a)) {\r\n            return 1\r\n        }\r\n        if (!(0, _type.isDefined)(b)) {\r\n            return -1\r\n        }\r\n        return 0\r\n    }\r\n    return result\r\n}\r\n\r\nfunction sortByArgument(data, argumentField) {\r\n    return data.slice().sort(function(a, b) {\r\n        return sort(a[argumentField], b[argumentField])\r\n    })\r\n}\r\n\r\nfunction sortByCallback(data, callback) {\r\n    return data.slice().sort(callback)\r\n}\r\n\r\nfunction checkValueTypeOfGroup(group, cell) {\r\n    group.series.forEach(function(series) {\r\n        series.getValueFields().forEach(function(field) {\r\n            group.valueType = getType(cell[field], group.valueType)\r\n        })\r\n    });\r\n    return group.valueType\r\n}\r\n\r\nfunction getSortByCategories(categories) {\r\n    var hash = {};\r\n    categories.forEach(function(value, i) {\r\n        hash[value] = i\r\n    });\r\n    return function(data, argumentField) {\r\n        return sortValues(data.slice(), true, function(a) {\r\n            return hash[a[argumentField]]\r\n        })\r\n    }\r\n}\r\n\r\nfunction sortData(data, groupsData, options, uniqueArgumentFields) {\r\n    var dataByArguments = {};\r\n    var isDiscrete = groupsData.argumentAxisType === DISCRETE;\r\n    var userCategories = isDiscrete && groupsData.argumentOptions && groupsData.argumentOptions.categories;\r\n    var sortFunction = function(data) {\r\n        return data\r\n    };\r\n    var sortingMethodOption = options.sortingMethod;\r\n    var reSortCategories;\r\n    if (!userCategories && (0, _type.isFunction)(sortingMethodOption)) {\r\n        data = sortByCallback(data, sortingMethodOption)\r\n    }\r\n    if (isDiscrete) {\r\n        groupsData.categories = getCategories(data, uniqueArgumentFields, userCategories)\r\n    }\r\n    if (userCategories || !(0, _type.isFunction)(sortingMethodOption) && groupsData.argumentType === STRING && !options._skipArgumentSorting) {\r\n        sortFunction = getSortByCategories(groupsData.categories)\r\n    } else {\r\n        if (true === sortingMethodOption && groupsData.argumentType !== STRING) {\r\n            sortFunction = sortByArgument;\r\n            reSortCategories = isDiscrete\r\n        }\r\n    }\r\n    uniqueArgumentFields.forEach(function(field) {\r\n        dataByArguments[field] = sortFunction(data, field)\r\n    });\r\n    if (reSortCategories) {\r\n        groupsData.categories = groupsData.categories.sort(sort)\r\n    }\r\n    return dataByArguments\r\n}\r\n\r\nfunction checkItemExistence(collection, item) {\r\n    return collection.map(function(collectionItem) {\r\n        return collectionItem.valueOf()\r\n    }).indexOf(item.valueOf()) === -1\r\n}\r\n\r\nfunction getCategories(data, uniqueArgumentFields, userCategories) {\r\n    var categories = userCategories ? userCategories.slice() : [];\r\n    uniqueArgumentFields.forEach(function(field) {\r\n        data.forEach(function(item) {\r\n            var dataItem = item[field];\r\n            (0, _type.isDefined)(dataItem) && checkItemExistence(categories, dataItem) && categories.push(dataItem)\r\n        })\r\n    });\r\n    return categories\r\n}\r\n\r\nfunction checkArgumentTypeOfGroup(series, cell, groupsData) {\r\n    series.forEach(function(currentSeries) {\r\n        groupsData.argumentType = getType(cell[currentSeries.getArgumentField()], groupsData.argumentType)\r\n    });\r\n    return groupsData.argumentType\r\n}\r\n\r\nfunction checkType(data, groupsData, checkTypeForAllData) {\r\n    var groupsWithUndefinedValueType = [];\r\n    var groupsWithUndefinedArgumentType = [];\r\n    var argumentTypeGroup = groupsData.argumentOptions && axisTypeParser(groupsData.argumentOptions.argumentType);\r\n    var groupsIndexes;\r\n    groupsData.groups.forEach(function(group) {\r\n        if (!group.series.length) {\r\n            return\r\n        }\r\n        var valueTypeGroup = group.valueOptions && axisTypeParser(group.valueOptions.valueType);\r\n        group.valueType = valueTypeGroup;\r\n        groupsData.argumentType = argumentTypeGroup;\r\n        !valueTypeGroup && groupsWithUndefinedValueType.push(group);\r\n        !argumentTypeGroup && groupsWithUndefinedArgumentType.push(group)\r\n    });\r\n    if (groupsWithUndefinedValueType.length || groupsWithUndefinedArgumentType.length) {\r\n        groupsIndexes = groupsWithUndefinedValueType.map(function(_, index) {\r\n            return index\r\n        });\r\n        data.some(function(cell) {\r\n            var defineArg;\r\n            groupsWithUndefinedValueType.forEach(function(group, groupIndex) {\r\n                if (checkValueTypeOfGroup(group, cell) && groupsIndexes.indexOf(groupIndex) >= 0) {\r\n                    groupsIndexes.splice(groupIndex, 1)\r\n                }\r\n            });\r\n            if (!defineArg) {\r\n                groupsWithUndefinedArgumentType.forEach(function(group) {\r\n                    defineArg = checkArgumentTypeOfGroup(group.series, cell, groupsData)\r\n                })\r\n            }\r\n            if (!checkTypeForAllData && defineArg && 0 === groupsIndexes.length) {\r\n                return true\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nfunction checkAxisType(groupsData, incidentOccurred) {\r\n    var argumentOptions = groupsData.argumentOptions || {};\r\n    var userArgumentCategories = argumentOptions && argumentOptions.categories || [];\r\n    var argumentAxisType = correctAxisType(groupsData.argumentType, argumentOptions.type, !!userArgumentCategories.length, incidentOccurred);\r\n    groupsData.groups.forEach(function(group) {\r\n        var valueOptions = group.valueOptions || {};\r\n        var valueCategories = valueOptions.categories || [];\r\n        var valueAxisType = correctAxisType(group.valueType, valueOptions.type, !!valueCategories.length, incidentOccurred);\r\n        group.series.forEach(function(series) {\r\n            var optionsSeries = {};\r\n            optionsSeries.argumentAxisType = argumentAxisType;\r\n            optionsSeries.valueAxisType = valueAxisType;\r\n            groupsData.argumentAxisType = groupsData.argumentAxisType || optionsSeries.argumentAxisType;\r\n            group.valueAxisType = group.valueAxisType || optionsSeries.valueAxisType;\r\n            optionsSeries.argumentType = groupsData.argumentType;\r\n            optionsSeries.valueType = group.valueType;\r\n            optionsSeries.showZero = valueOptions.showZero;\r\n            series.updateDataType(optionsSeries)\r\n        });\r\n        group.valueAxisType = group.valueAxisType || valueAxisType;\r\n        if (group.valueAxis) {\r\n            group.valueAxis.setTypes(group.valueAxisType, group.valueType, VALUE_TYPE);\r\n            group.valueAxis.validate()\r\n        }\r\n    });\r\n    groupsData.argumentAxisType = groupsData.argumentAxisType || argumentAxisType;\r\n    if (groupsData.argumentAxes) {\r\n        groupsData.argumentAxes.forEach(function(axis) {\r\n            axis.setTypes(groupsData.argumentAxisType, groupsData.argumentType, ARGUMENT_TYPE);\r\n            axis.validate()\r\n        })\r\n    }\r\n}\r\n\r\nfunction verifyData(source, incidentOccurred) {\r\n    var data = [];\r\n    var sourceIsDefined = (0, _type.isDefined)(source);\r\n    var hasError = sourceIsDefined && !_isArray(source);\r\n    var i;\r\n    var ii;\r\n    var k;\r\n    var item;\r\n    if (sourceIsDefined && !hasError) {\r\n        for (i = 0, ii = source.length, k = 0; i < ii; ++i) {\r\n            item = source[i];\r\n            if ((0, _type.isObject)(item)) {\r\n                data[k++] = item\r\n            } else {\r\n                if (item) {\r\n                    hasError = true\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (hasError) {\r\n        incidentOccurred(\"E2001\")\r\n    }\r\n    return data\r\n}\r\n\r\nfunction validateData(data, groupsData, incidentOccurred, options) {\r\n    data = verifyData(data, incidentOccurred);\r\n    groupsData.argumentType = groupsData.argumentAxisType = null;\r\n    processGroups(groupsData.groups);\r\n    resetArgumentAxes(groupsData.argumentAxes);\r\n    checkType(data, groupsData, options.checkTypeForAllData);\r\n    checkAxisType(groupsData, incidentOccurred);\r\n    if (options.convertToAxisDataType) {\r\n        data = parse(data, prepareParsers(groupsData, incidentOccurred))\r\n    }\r\n    groupPieData(data, groupsData);\r\n    var dataByArgumentFields = sortData(data, groupsData, options, getUniqueArgumentFields(groupsData));\r\n    return dataByArgumentFields\r\n}\r\n"]},"metadata":{},"sourceType":"script"}