{"ast":null,"code":"/**\r\n * DevExtreme (viz/chart_components/multi_axes_synchronizer.js)\r\n * Version: 20.2.3\r\n * Build date: Tue Oct 20 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nexports.default = void 0;\n\nvar _console = require(\"../../core/utils/console\");\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _utils = require(\"../core/utils\");\n\nvar _math2 = require(\"../../core/utils/math\");\n\nvar _math = Math;\nvar _floor = _math.floor;\nvar _max = _math.max;\nvar _abs = _math.abs;\n\nfunction getValueAxesPerPanes(valueAxes) {\n  var result = {};\n  valueAxes.forEach(function (axis) {\n    var pane = axis.pane;\n\n    if (!result[pane]) {\n      result[pane] = [];\n    }\n\n    result[pane].push(axis);\n  });\n  return result;\n}\n\nvar linearConverter = {\n  transform: function (v, b) {\n    return (0, _math2.adjust)((0, _utils.getLog)(v, b));\n  },\n  addInterval: function (v, i) {\n    return (0, _math2.adjust)(v + i);\n  },\n  getInterval: function (base, tickInterval) {\n    return tickInterval;\n  }\n};\nvar logConverter = {\n  transform: function (v, b) {\n    return (0, _math2.adjust)((0, _utils.raiseTo)(v, b));\n  },\n  addInterval: function (v, i) {\n    return (0, _math2.adjust)(v * i);\n  },\n  getInterval: function (base, tickInterval) {\n    return _math.pow(base, tickInterval);\n  }\n};\n\nfunction convertAxisInfo(axisInfo, converter) {\n  if (!axisInfo.isLogarithmic) {\n    return;\n  }\n\n  var base = axisInfo.logarithmicBase;\n  var tickValues = axisInfo.tickValues;\n  var tick;\n  var ticks = [];\n  axisInfo.minValue = converter.transform(axisInfo.minValue, base);\n  axisInfo.oldMinValue = converter.transform(axisInfo.oldMinValue, base);\n  axisInfo.maxValue = converter.transform(axisInfo.maxValue, base);\n  axisInfo.oldMaxValue = converter.transform(axisInfo.oldMaxValue, base);\n  axisInfo.tickInterval = _math.round(axisInfo.tickInterval);\n\n  if (axisInfo.tickInterval < 1) {\n    axisInfo.tickInterval = 1;\n  }\n\n  var interval = converter.getInterval(base, axisInfo.tickInterval);\n  tick = converter.transform(tickValues[0], base);\n\n  while (ticks.length < tickValues.length) {\n    ticks.push(tick);\n    tick = converter.addInterval(tick, interval);\n  }\n\n  ticks.tickInterval = axisInfo.tickInterval;\n  axisInfo.tickValues = ticks;\n}\n\nfunction populateAxesInfo(axes) {\n  return axes.reduce(function (result, axis) {\n    var ticksValues = axis.getTicksValues();\n    var majorTicks = ticksValues.majorTicksValues;\n    var options = axis.getOptions();\n    var businessRange = axis.getTranslator().getBusinessRange();\n    var visibleArea = axis.getVisibleArea();\n    var axisInfo;\n    var tickInterval = axis._tickInterval;\n    var synchronizedValue = options.synchronizedValue;\n\n    if (majorTicks && majorTicks.length > 0 && (0, _type.isNumeric)(majorTicks[0]) && \"discrete\" !== options.type && !businessRange.isEmpty() && !(businessRange.breaks && businessRange.breaks.length) && \"zoom\" !== axis.getViewport().action) {\n      axis.applyMargins();\n      var startValue = axis.getTranslator().from(visibleArea[0]);\n      var endValue = axis.getTranslator().from(visibleArea[1]);\n      var minValue = startValue < endValue ? startValue : endValue;\n      var maxValue = startValue < endValue ? endValue : startValue;\n\n      if (minValue === maxValue && (0, _type.isDefined)(synchronizedValue)) {\n        tickInterval = _abs(majorTicks[0] - synchronizedValue) || 1;\n        minValue = majorTicks[0] - tickInterval;\n        maxValue = majorTicks[0] + tickInterval;\n      }\n\n      axisInfo = {\n        axis: axis,\n        isLogarithmic: \"logarithmic\" === options.type,\n        logarithmicBase: businessRange.base,\n        tickValues: majorTicks,\n        minorValues: ticksValues.minorTicksValues,\n        minorTickInterval: axis._minorTickInterval,\n        minValue: minValue,\n        oldMinValue: minValue,\n        maxValue: maxValue,\n        oldMaxValue: maxValue,\n        inverted: businessRange.invert,\n        tickInterval: tickInterval,\n        synchronizedValue: synchronizedValue\n      };\n      convertAxisInfo(axisInfo, linearConverter);\n      result.push(axisInfo);\n    }\n\n    return result;\n  }, []);\n}\n\nfunction updateTickValues(axesInfo) {\n  var maxTicksCount = axesInfo.reduce(function (max, axisInfo) {\n    return _max(max, axisInfo.tickValues.length);\n  }, 0);\n  axesInfo.forEach(function (axisInfo) {\n    var ticksMultiplier;\n    var ticksCount;\n    var additionalStartTicksCount = 0;\n    var synchronizedValue = axisInfo.synchronizedValue;\n    var tickValues = axisInfo.tickValues;\n    var tickInterval = axisInfo.tickInterval;\n\n    if ((0, _type.isDefined)(synchronizedValue)) {\n      axisInfo.baseTickValue = axisInfo.invertedBaseTickValue = synchronizedValue;\n      axisInfo.tickValues = [axisInfo.baseTickValue];\n    } else {\n      if (tickValues.length > 1 && tickInterval) {\n        ticksMultiplier = _floor((maxTicksCount + 1) / tickValues.length);\n        ticksCount = ticksMultiplier > 1 ? _floor((maxTicksCount + 1) / ticksMultiplier) : maxTicksCount;\n        additionalStartTicksCount = _floor((ticksCount - tickValues.length) / 2);\n\n        while (additionalStartTicksCount > 0 && 0 !== tickValues[0]) {\n          tickValues.unshift((0, _math2.adjust)(tickValues[0] - tickInterval));\n          additionalStartTicksCount--;\n        }\n\n        while (tickValues.length < ticksCount) {\n          tickValues.push((0, _math2.adjust)(tickValues[tickValues.length - 1] + tickInterval));\n        }\n\n        axisInfo.tickInterval = tickInterval / ticksMultiplier;\n      }\n\n      axisInfo.baseTickValue = tickValues[0];\n      axisInfo.invertedBaseTickValue = tickValues[tickValues.length - 1];\n    }\n  });\n}\n\nfunction getAxisRange(axisInfo) {\n  return axisInfo.maxValue - axisInfo.minValue || 1;\n}\n\nfunction getMainAxisInfo(axesInfo) {\n  for (var i = 0; i < axesInfo.length; i++) {\n    if (!axesInfo[i].stubData) {\n      return axesInfo[i];\n    }\n  }\n\n  return null;\n}\n\nfunction correctMinMaxValues(axesInfo) {\n  var mainAxisInfo = getMainAxisInfo(axesInfo);\n  var mainAxisInfoTickInterval = mainAxisInfo.tickInterval;\n  axesInfo.forEach(function (axisInfo) {\n    var scale;\n    var move;\n    var mainAxisBaseValueOffset;\n    var valueFromAxisInfo;\n\n    if (axisInfo !== mainAxisInfo) {\n      if (mainAxisInfoTickInterval && axisInfo.tickInterval) {\n        if (axisInfo.stubData && (0, _type.isDefined)(axisInfo.synchronizedValue)) {\n          axisInfo.oldMinValue = axisInfo.minValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.minValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;\n          axisInfo.oldMaxValue = axisInfo.maxValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.maxValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;\n        }\n\n        scale = mainAxisInfoTickInterval / getAxisRange(mainAxisInfo) / axisInfo.tickInterval * getAxisRange(axisInfo);\n        axisInfo.maxValue = axisInfo.minValue + getAxisRange(axisInfo) / scale;\n      }\n\n      if (mainAxisInfo.inverted && !axisInfo.inverted || !mainAxisInfo.inverted && axisInfo.inverted) {\n        mainAxisBaseValueOffset = mainAxisInfo.maxValue - mainAxisInfo.invertedBaseTickValue;\n      } else {\n        mainAxisBaseValueOffset = mainAxisInfo.baseTickValue - mainAxisInfo.minValue;\n      }\n\n      valueFromAxisInfo = getAxisRange(axisInfo);\n      move = (mainAxisBaseValueOffset / getAxisRange(mainAxisInfo) - (axisInfo.baseTickValue - axisInfo.minValue) / valueFromAxisInfo) * valueFromAxisInfo;\n      axisInfo.minValue -= move;\n      axisInfo.maxValue -= move;\n    }\n  });\n}\n\nfunction calculatePaddings(axesInfo) {\n  var minPadding;\n  var maxPadding;\n  var startPadding = 0;\n  var endPadding = 0;\n  axesInfo.forEach(function (axisInfo) {\n    var inverted = axisInfo.inverted;\n    minPadding = axisInfo.minValue > axisInfo.oldMinValue ? (axisInfo.minValue - axisInfo.oldMinValue) / getAxisRange(axisInfo) : 0;\n    maxPadding = axisInfo.maxValue < axisInfo.oldMaxValue ? (axisInfo.oldMaxValue - axisInfo.maxValue) / getAxisRange(axisInfo) : 0;\n    startPadding = _max(startPadding, inverted ? maxPadding : minPadding);\n    endPadding = _max(endPadding, inverted ? minPadding : maxPadding);\n  });\n  return {\n    start: startPadding,\n    end: endPadding\n  };\n}\n\nfunction correctMinMaxValuesByPaddings(axesInfo, paddings) {\n  axesInfo.forEach(function (info) {\n    var range = getAxisRange(info);\n    var inverted = info.inverted;\n    info.minValue = (0, _math2.adjust)(info.minValue - paddings[inverted ? \"end\" : \"start\"] * range);\n    info.maxValue = (0, _math2.adjust)(info.maxValue + paddings[inverted ? \"start\" : \"end\"] * range);\n  });\n}\n\nfunction updateTickValuesIfSynchronizedValueUsed(axesInfo) {\n  var hasSynchronizedValue = false;\n  axesInfo.forEach(function (info) {\n    hasSynchronizedValue = hasSynchronizedValue || (0, _type.isDefined)(info.synchronizedValue);\n  });\n  axesInfo.forEach(function (info) {\n    var tickInterval = info.tickInterval;\n    var tickValues = info.tickValues;\n    var maxValue = info.maxValue;\n    var minValue = info.minValue;\n    var tick;\n\n    if (hasSynchronizedValue && tickInterval) {\n      while ((tick = (0, _math2.adjust)(tickValues[0] - tickInterval)) >= minValue) {\n        tickValues.unshift(tick);\n      }\n\n      tick = tickValues[tickValues.length - 1];\n\n      while ((tick = (0, _math2.adjust)(tick + tickInterval)) <= maxValue) {\n        tickValues.push(tick);\n      }\n    }\n\n    while (tickValues[0] + tickInterval / 10 < minValue) {\n      tickValues.shift();\n    }\n\n    while (tickValues[tickValues.length - 1] - tickInterval / 10 > maxValue) {\n      tickValues.pop();\n    }\n  });\n}\n\nfunction applyMinMaxValues(axesInfo) {\n  axesInfo.forEach(function (info) {\n    var axis = info.axis;\n    var range = axis.getTranslator().getBusinessRange();\n\n    if (range.min === range.minVisible) {\n      range.min = info.minValue;\n    }\n\n    if (range.max === range.maxVisible) {\n      range.max = info.maxValue;\n    }\n\n    range.minVisible = info.minValue;\n    range.maxVisible = info.maxValue;\n\n    if (range.min > range.minVisible) {\n      range.min = range.minVisible;\n    }\n\n    if (range.max < range.maxVisible) {\n      range.max = range.maxVisible;\n    }\n\n    axis.getTranslator().updateBusinessRange(range);\n    axis.setTicks({\n      majorTicks: info.tickValues,\n      minorTicks: info.minorValues\n    });\n  });\n}\n\nfunction correctAfterSynchronize(axesInfo) {\n  var invalidAxisInfo = [];\n  var correctValue;\n  axesInfo.forEach(function (info) {\n    if (info.oldMaxValue - info.oldMinValue === 0) {\n      invalidAxisInfo.push(info);\n    } else {\n      if (!(0, _type.isDefined)(correctValue) && !(0, _type.isDefined)(info.synchronizedValue)) {\n        correctValue = _abs((info.maxValue - info.minValue) / (info.tickValues[_floor(info.tickValues.length / 2)] - info.minValue || info.maxValue));\n      }\n    }\n  });\n\n  if (!(0, _type.isDefined)(correctValue)) {\n    return;\n  }\n\n  invalidAxisInfo.forEach(function (info) {\n    var firstTick = info.tickValues[0];\n    var correctedTick = firstTick * correctValue;\n\n    if (firstTick > 0) {\n      info.maxValue = correctedTick;\n      info.minValue = 0;\n    } else {\n      if (firstTick < 0) {\n        info.minValue = correctedTick;\n        info.maxValue = 0;\n      }\n    }\n  });\n}\n\nfunction updateMinorTicks(axesInfo) {\n  axesInfo.forEach(function (axisInfo) {\n    if (!axisInfo.minorTickInterval) {\n      return;\n    }\n\n    var ticks = [];\n    var interval = axisInfo.minorTickInterval;\n    var tickCount = axisInfo.tickInterval / interval - 1;\n\n    for (var i = 1; i < axisInfo.tickValues.length; i++) {\n      var tick = axisInfo.tickValues[i - 1];\n\n      for (var j = 0; j < tickCount; j++) {\n        tick += interval;\n        ticks.push(tick);\n      }\n    }\n\n    axisInfo.minorValues = ticks;\n  });\n}\n\nfunction correctPaddings(axesInfo, paddings) {\n  return axesInfo.reduce(function (prev, info) {\n    var inverted = info.inverted;\n\n    var _info$axis$getCorrect = info.axis.getCorrectedValuesToZero(info.minValue, info.maxValue),\n        start = _info$axis$getCorrect.start,\n        end = _info$axis$getCorrect.end;\n\n    if ((0, _type.isDefined)(start) || (0, _type.isDefined)(end)) {\n      return inverted ? {\n        start: prev.start,\n        end: Math.min(prev.end, end)\n      } : {\n        start: Math.min(prev.start, start),\n        end: prev.end\n      };\n    }\n\n    return prev;\n  }, paddings);\n}\n\nvar multiAxesSynchronizer = {\n  synchronize: function (valueAxes) {\n    (0, _iterator.each)(getValueAxesPerPanes(valueAxes), function (_, axes) {\n      var axesInfo;\n      var paddings;\n\n      if (axes.length > 1) {\n        axesInfo = populateAxesInfo(axes);\n\n        if (axesInfo.length < 2 || !getMainAxisInfo(axesInfo)) {\n          return;\n        }\n\n        updateTickValues(axesInfo);\n        correctMinMaxValues(axesInfo);\n        paddings = calculatePaddings(axesInfo);\n        paddings = correctPaddings(axesInfo, paddings);\n        correctMinMaxValuesByPaddings(axesInfo, paddings);\n        correctAfterSynchronize(axesInfo);\n        updateTickValuesIfSynchronizedValueUsed(axesInfo);\n        updateMinorTicks(axesInfo);\n        axesInfo.forEach(function (info) {\n          convertAxisInfo(info, logConverter);\n        });\n        applyMinMaxValues(axesInfo);\n      }\n    });\n  }\n};\nvar _default = multiAxesSynchronizer;\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"sources":["E:/Monday.com/quickstart-react/node_modules/devextreme/viz/chart_components/multi_axes_synchronizer.js"],"names":["exports","default","_console","require","_type","_iterator","_utils","_math2","_math","Math","_floor","floor","_max","max","_abs","abs","getValueAxesPerPanes","valueAxes","result","forEach","axis","pane","push","linearConverter","transform","v","b","adjust","getLog","addInterval","i","getInterval","base","tickInterval","logConverter","raiseTo","pow","convertAxisInfo","axisInfo","converter","isLogarithmic","logarithmicBase","tickValues","tick","ticks","minValue","oldMinValue","maxValue","oldMaxValue","round","interval","length","populateAxesInfo","axes","reduce","ticksValues","getTicksValues","majorTicks","majorTicksValues","options","getOptions","businessRange","getTranslator","getBusinessRange","visibleArea","getVisibleArea","_tickInterval","synchronizedValue","isNumeric","type","isEmpty","breaks","getViewport","action","applyMargins","startValue","from","endValue","isDefined","minorValues","minorTicksValues","minorTickInterval","_minorTickInterval","inverted","invert","updateTickValues","axesInfo","maxTicksCount","ticksMultiplier","ticksCount","additionalStartTicksCount","baseTickValue","invertedBaseTickValue","unshift","getAxisRange","getMainAxisInfo","stubData","correctMinMaxValues","mainAxisInfo","mainAxisInfoTickInterval","scale","move","mainAxisBaseValueOffset","valueFromAxisInfo","calculatePaddings","minPadding","maxPadding","startPadding","endPadding","start","end","correctMinMaxValuesByPaddings","paddings","info","range","updateTickValuesIfSynchronizedValueUsed","hasSynchronizedValue","shift","pop","applyMinMaxValues","min","minVisible","maxVisible","updateBusinessRange","setTicks","minorTicks","correctAfterSynchronize","invalidAxisInfo","correctValue","firstTick","correctedTick","updateMinorTicks","tickCount","j","correctPaddings","prev","_info$axis$getCorrect","getCorrectedValuesToZero","multiAxesSynchronizer","synchronize","each","_","_default","module"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/chart_components/multi_axes_synchronizer.js)\r\n * Version: 20.2.3\r\n * Build date: Tue Oct 20 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nexports.default = void 0;\r\nvar _console = require(\"../../core/utils/console\");\r\nvar _type = require(\"../../core/utils/type\");\r\nvar _iterator = require(\"../../core/utils/iterator\");\r\nvar _utils = require(\"../core/utils\");\r\nvar _math2 = require(\"../../core/utils/math\");\r\nvar _math = Math;\r\nvar _floor = _math.floor;\r\nvar _max = _math.max;\r\nvar _abs = _math.abs;\r\n\r\nfunction getValueAxesPerPanes(valueAxes) {\r\n    var result = {};\r\n    valueAxes.forEach(function(axis) {\r\n        var pane = axis.pane;\r\n        if (!result[pane]) {\r\n            result[pane] = []\r\n        }\r\n        result[pane].push(axis)\r\n    });\r\n    return result\r\n}\r\nvar linearConverter = {\r\n    transform: function(v, b) {\r\n        return (0, _math2.adjust)((0, _utils.getLog)(v, b))\r\n    },\r\n    addInterval: function(v, i) {\r\n        return (0, _math2.adjust)(v + i)\r\n    },\r\n    getInterval: function(base, tickInterval) {\r\n        return tickInterval\r\n    }\r\n};\r\nvar logConverter = {\r\n    transform: function(v, b) {\r\n        return (0, _math2.adjust)((0, _utils.raiseTo)(v, b))\r\n    },\r\n    addInterval: function(v, i) {\r\n        return (0, _math2.adjust)(v * i)\r\n    },\r\n    getInterval: function(base, tickInterval) {\r\n        return _math.pow(base, tickInterval)\r\n    }\r\n};\r\n\r\nfunction convertAxisInfo(axisInfo, converter) {\r\n    if (!axisInfo.isLogarithmic) {\r\n        return\r\n    }\r\n    var base = axisInfo.logarithmicBase;\r\n    var tickValues = axisInfo.tickValues;\r\n    var tick;\r\n    var ticks = [];\r\n    axisInfo.minValue = converter.transform(axisInfo.minValue, base);\r\n    axisInfo.oldMinValue = converter.transform(axisInfo.oldMinValue, base);\r\n    axisInfo.maxValue = converter.transform(axisInfo.maxValue, base);\r\n    axisInfo.oldMaxValue = converter.transform(axisInfo.oldMaxValue, base);\r\n    axisInfo.tickInterval = _math.round(axisInfo.tickInterval);\r\n    if (axisInfo.tickInterval < 1) {\r\n        axisInfo.tickInterval = 1\r\n    }\r\n    var interval = converter.getInterval(base, axisInfo.tickInterval);\r\n    tick = converter.transform(tickValues[0], base);\r\n    while (ticks.length < tickValues.length) {\r\n        ticks.push(tick);\r\n        tick = converter.addInterval(tick, interval)\r\n    }\r\n    ticks.tickInterval = axisInfo.tickInterval;\r\n    axisInfo.tickValues = ticks\r\n}\r\n\r\nfunction populateAxesInfo(axes) {\r\n    return axes.reduce(function(result, axis) {\r\n        var ticksValues = axis.getTicksValues();\r\n        var majorTicks = ticksValues.majorTicksValues;\r\n        var options = axis.getOptions();\r\n        var businessRange = axis.getTranslator().getBusinessRange();\r\n        var visibleArea = axis.getVisibleArea();\r\n        var axisInfo;\r\n        var tickInterval = axis._tickInterval;\r\n        var synchronizedValue = options.synchronizedValue;\r\n        if (majorTicks && majorTicks.length > 0 && (0, _type.isNumeric)(majorTicks[0]) && \"discrete\" !== options.type && !businessRange.isEmpty() && !(businessRange.breaks && businessRange.breaks.length) && \"zoom\" !== axis.getViewport().action) {\r\n            axis.applyMargins();\r\n            var startValue = axis.getTranslator().from(visibleArea[0]);\r\n            var endValue = axis.getTranslator().from(visibleArea[1]);\r\n            var minValue = startValue < endValue ? startValue : endValue;\r\n            var maxValue = startValue < endValue ? endValue : startValue;\r\n            if (minValue === maxValue && (0, _type.isDefined)(synchronizedValue)) {\r\n                tickInterval = _abs(majorTicks[0] - synchronizedValue) || 1;\r\n                minValue = majorTicks[0] - tickInterval;\r\n                maxValue = majorTicks[0] + tickInterval\r\n            }\r\n            axisInfo = {\r\n                axis: axis,\r\n                isLogarithmic: \"logarithmic\" === options.type,\r\n                logarithmicBase: businessRange.base,\r\n                tickValues: majorTicks,\r\n                minorValues: ticksValues.minorTicksValues,\r\n                minorTickInterval: axis._minorTickInterval,\r\n                minValue: minValue,\r\n                oldMinValue: minValue,\r\n                maxValue: maxValue,\r\n                oldMaxValue: maxValue,\r\n                inverted: businessRange.invert,\r\n                tickInterval: tickInterval,\r\n                synchronizedValue: synchronizedValue\r\n            };\r\n            convertAxisInfo(axisInfo, linearConverter);\r\n            result.push(axisInfo)\r\n        }\r\n        return result\r\n    }, [])\r\n}\r\n\r\nfunction updateTickValues(axesInfo) {\r\n    var maxTicksCount = axesInfo.reduce(function(max, axisInfo) {\r\n        return _max(max, axisInfo.tickValues.length)\r\n    }, 0);\r\n    axesInfo.forEach(function(axisInfo) {\r\n        var ticksMultiplier;\r\n        var ticksCount;\r\n        var additionalStartTicksCount = 0;\r\n        var synchronizedValue = axisInfo.synchronizedValue;\r\n        var tickValues = axisInfo.tickValues;\r\n        var tickInterval = axisInfo.tickInterval;\r\n        if ((0, _type.isDefined)(synchronizedValue)) {\r\n            axisInfo.baseTickValue = axisInfo.invertedBaseTickValue = synchronizedValue;\r\n            axisInfo.tickValues = [axisInfo.baseTickValue]\r\n        } else {\r\n            if (tickValues.length > 1 && tickInterval) {\r\n                ticksMultiplier = _floor((maxTicksCount + 1) / tickValues.length);\r\n                ticksCount = ticksMultiplier > 1 ? _floor((maxTicksCount + 1) / ticksMultiplier) : maxTicksCount;\r\n                additionalStartTicksCount = _floor((ticksCount - tickValues.length) / 2);\r\n                while (additionalStartTicksCount > 0 && 0 !== tickValues[0]) {\r\n                    tickValues.unshift((0, _math2.adjust)(tickValues[0] - tickInterval));\r\n                    additionalStartTicksCount--\r\n                }\r\n                while (tickValues.length < ticksCount) {\r\n                    tickValues.push((0, _math2.adjust)(tickValues[tickValues.length - 1] + tickInterval))\r\n                }\r\n                axisInfo.tickInterval = tickInterval / ticksMultiplier\r\n            }\r\n            axisInfo.baseTickValue = tickValues[0];\r\n            axisInfo.invertedBaseTickValue = tickValues[tickValues.length - 1]\r\n        }\r\n    })\r\n}\r\n\r\nfunction getAxisRange(axisInfo) {\r\n    return axisInfo.maxValue - axisInfo.minValue || 1\r\n}\r\n\r\nfunction getMainAxisInfo(axesInfo) {\r\n    for (var i = 0; i < axesInfo.length; i++) {\r\n        if (!axesInfo[i].stubData) {\r\n            return axesInfo[i]\r\n        }\r\n    }\r\n    return null\r\n}\r\n\r\nfunction correctMinMaxValues(axesInfo) {\r\n    var mainAxisInfo = getMainAxisInfo(axesInfo);\r\n    var mainAxisInfoTickInterval = mainAxisInfo.tickInterval;\r\n    axesInfo.forEach(function(axisInfo) {\r\n        var scale;\r\n        var move;\r\n        var mainAxisBaseValueOffset;\r\n        var valueFromAxisInfo;\r\n        if (axisInfo !== mainAxisInfo) {\r\n            if (mainAxisInfoTickInterval && axisInfo.tickInterval) {\r\n                if (axisInfo.stubData && (0, _type.isDefined)(axisInfo.synchronizedValue)) {\r\n                    axisInfo.oldMinValue = axisInfo.minValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.minValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;\r\n                    axisInfo.oldMaxValue = axisInfo.maxValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.maxValue) / mainAxisInfoTickInterval * axisInfo.tickInterval\r\n                }\r\n                scale = mainAxisInfoTickInterval / getAxisRange(mainAxisInfo) / axisInfo.tickInterval * getAxisRange(axisInfo);\r\n                axisInfo.maxValue = axisInfo.minValue + getAxisRange(axisInfo) / scale\r\n            }\r\n            if (mainAxisInfo.inverted && !axisInfo.inverted || !mainAxisInfo.inverted && axisInfo.inverted) {\r\n                mainAxisBaseValueOffset = mainAxisInfo.maxValue - mainAxisInfo.invertedBaseTickValue\r\n            } else {\r\n                mainAxisBaseValueOffset = mainAxisInfo.baseTickValue - mainAxisInfo.minValue\r\n            }\r\n            valueFromAxisInfo = getAxisRange(axisInfo);\r\n            move = (mainAxisBaseValueOffset / getAxisRange(mainAxisInfo) - (axisInfo.baseTickValue - axisInfo.minValue) / valueFromAxisInfo) * valueFromAxisInfo;\r\n            axisInfo.minValue -= move;\r\n            axisInfo.maxValue -= move\r\n        }\r\n    })\r\n}\r\n\r\nfunction calculatePaddings(axesInfo) {\r\n    var minPadding;\r\n    var maxPadding;\r\n    var startPadding = 0;\r\n    var endPadding = 0;\r\n    axesInfo.forEach(function(axisInfo) {\r\n        var inverted = axisInfo.inverted;\r\n        minPadding = axisInfo.minValue > axisInfo.oldMinValue ? (axisInfo.minValue - axisInfo.oldMinValue) / getAxisRange(axisInfo) : 0;\r\n        maxPadding = axisInfo.maxValue < axisInfo.oldMaxValue ? (axisInfo.oldMaxValue - axisInfo.maxValue) / getAxisRange(axisInfo) : 0;\r\n        startPadding = _max(startPadding, inverted ? maxPadding : minPadding);\r\n        endPadding = _max(endPadding, inverted ? minPadding : maxPadding)\r\n    });\r\n    return {\r\n        start: startPadding,\r\n        end: endPadding\r\n    }\r\n}\r\n\r\nfunction correctMinMaxValuesByPaddings(axesInfo, paddings) {\r\n    axesInfo.forEach(function(info) {\r\n        var range = getAxisRange(info);\r\n        var inverted = info.inverted;\r\n        info.minValue = (0, _math2.adjust)(info.minValue - paddings[inverted ? \"end\" : \"start\"] * range);\r\n        info.maxValue = (0, _math2.adjust)(info.maxValue + paddings[inverted ? \"start\" : \"end\"] * range)\r\n    })\r\n}\r\n\r\nfunction updateTickValuesIfSynchronizedValueUsed(axesInfo) {\r\n    var hasSynchronizedValue = false;\r\n    axesInfo.forEach(function(info) {\r\n        hasSynchronizedValue = hasSynchronizedValue || (0, _type.isDefined)(info.synchronizedValue)\r\n    });\r\n    axesInfo.forEach(function(info) {\r\n        var tickInterval = info.tickInterval;\r\n        var tickValues = info.tickValues;\r\n        var maxValue = info.maxValue;\r\n        var minValue = info.minValue;\r\n        var tick;\r\n        if (hasSynchronizedValue && tickInterval) {\r\n            while ((tick = (0, _math2.adjust)(tickValues[0] - tickInterval)) >= minValue) {\r\n                tickValues.unshift(tick)\r\n            }\r\n            tick = tickValues[tickValues.length - 1];\r\n            while ((tick = (0, _math2.adjust)(tick + tickInterval)) <= maxValue) {\r\n                tickValues.push(tick)\r\n            }\r\n        }\r\n        while (tickValues[0] + tickInterval / 10 < minValue) {\r\n            tickValues.shift()\r\n        }\r\n        while (tickValues[tickValues.length - 1] - tickInterval / 10 > maxValue) {\r\n            tickValues.pop()\r\n        }\r\n    })\r\n}\r\n\r\nfunction applyMinMaxValues(axesInfo) {\r\n    axesInfo.forEach(function(info) {\r\n        var axis = info.axis;\r\n        var range = axis.getTranslator().getBusinessRange();\r\n        if (range.min === range.minVisible) {\r\n            range.min = info.minValue\r\n        }\r\n        if (range.max === range.maxVisible) {\r\n            range.max = info.maxValue\r\n        }\r\n        range.minVisible = info.minValue;\r\n        range.maxVisible = info.maxValue;\r\n        if (range.min > range.minVisible) {\r\n            range.min = range.minVisible\r\n        }\r\n        if (range.max < range.maxVisible) {\r\n            range.max = range.maxVisible\r\n        }\r\n        axis.getTranslator().updateBusinessRange(range);\r\n        axis.setTicks({\r\n            majorTicks: info.tickValues,\r\n            minorTicks: info.minorValues\r\n        })\r\n    })\r\n}\r\n\r\nfunction correctAfterSynchronize(axesInfo) {\r\n    var invalidAxisInfo = [];\r\n    var correctValue;\r\n    axesInfo.forEach(function(info) {\r\n        if (info.oldMaxValue - info.oldMinValue === 0) {\r\n            invalidAxisInfo.push(info)\r\n        } else {\r\n            if (!(0, _type.isDefined)(correctValue) && !(0, _type.isDefined)(info.synchronizedValue)) {\r\n                correctValue = _abs((info.maxValue - info.minValue) / (info.tickValues[_floor(info.tickValues.length / 2)] - info.minValue || info.maxValue))\r\n            }\r\n        }\r\n    });\r\n    if (!(0, _type.isDefined)(correctValue)) {\r\n        return\r\n    }\r\n    invalidAxisInfo.forEach(function(info) {\r\n        var firstTick = info.tickValues[0];\r\n        var correctedTick = firstTick * correctValue;\r\n        if (firstTick > 0) {\r\n            info.maxValue = correctedTick;\r\n            info.minValue = 0\r\n        } else {\r\n            if (firstTick < 0) {\r\n                info.minValue = correctedTick;\r\n                info.maxValue = 0\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nfunction updateMinorTicks(axesInfo) {\r\n    axesInfo.forEach(function(axisInfo) {\r\n        if (!axisInfo.minorTickInterval) {\r\n            return\r\n        }\r\n        var ticks = [];\r\n        var interval = axisInfo.minorTickInterval;\r\n        var tickCount = axisInfo.tickInterval / interval - 1;\r\n        for (var i = 1; i < axisInfo.tickValues.length; i++) {\r\n            var tick = axisInfo.tickValues[i - 1];\r\n            for (var j = 0; j < tickCount; j++) {\r\n                tick += interval;\r\n                ticks.push(tick)\r\n            }\r\n        }\r\n        axisInfo.minorValues = ticks\r\n    })\r\n}\r\n\r\nfunction correctPaddings(axesInfo, paddings) {\r\n    return axesInfo.reduce(function(prev, info) {\r\n        var inverted = info.inverted;\r\n        var _info$axis$getCorrect = info.axis.getCorrectedValuesToZero(info.minValue, info.maxValue),\r\n            start = _info$axis$getCorrect.start,\r\n            end = _info$axis$getCorrect.end;\r\n        if ((0, _type.isDefined)(start) || (0, _type.isDefined)(end)) {\r\n            return inverted ? {\r\n                start: prev.start,\r\n                end: Math.min(prev.end, end)\r\n            } : {\r\n                start: Math.min(prev.start, start),\r\n                end: prev.end\r\n            }\r\n        }\r\n        return prev\r\n    }, paddings)\r\n}\r\nvar multiAxesSynchronizer = {\r\n    synchronize: function(valueAxes) {\r\n        (0, _iterator.each)(getValueAxesPerPanes(valueAxes), function(_, axes) {\r\n            var axesInfo;\r\n            var paddings;\r\n            if (axes.length > 1) {\r\n                axesInfo = populateAxesInfo(axes);\r\n                if (axesInfo.length < 2 || !getMainAxisInfo(axesInfo)) {\r\n                    return\r\n                }\r\n                updateTickValues(axesInfo);\r\n                correctMinMaxValues(axesInfo);\r\n                paddings = calculatePaddings(axesInfo);\r\n                paddings = correctPaddings(axesInfo, paddings);\r\n                correctMinMaxValuesByPaddings(axesInfo, paddings);\r\n                correctAfterSynchronize(axesInfo);\r\n                updateTickValuesIfSynchronizedValueUsed(axesInfo);\r\n                updateMinorTicks(axesInfo);\r\n                axesInfo.forEach(function(info) {\r\n                    convertAxisInfo(info, logConverter)\r\n                });\r\n                applyMinMaxValues(axesInfo)\r\n            }\r\n        })\r\n    }\r\n};\r\nvar _default = multiAxesSynchronizer;\r\nexports.default = _default;\r\nmodule.exports = exports.default;\r\n"]},"metadata":{},"sourceType":"script"}