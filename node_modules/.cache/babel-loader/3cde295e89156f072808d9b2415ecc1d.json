{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/line_series.js)\r\n * Version: 20.2.3\r\n * Build date: Tue Oct 20 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nexports.polar = exports.chart = void 0;\n\nvar _scatter_series = require(\"./scatter_series\");\n\nvar _object = require(\"../../core/utils/object\");\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _utils = require(\"../core/utils\");\n\nvar _math = require(\"../../core/utils/math\");\n\nvar DISCRETE = \"discrete\";\nvar round = Math.round,\n    sqrt = Math.sqrt,\n    pow = Math.pow,\n    min = Math.min,\n    max = Math.max,\n    abs = Math.abs;\nvar chart = {};\nexports.chart = chart;\nvar polar = {};\nexports.polar = polar;\n\nfunction clonePoint(point, newX, newY, newAngle) {\n  var p = (0, _object.clone)(point);\n  p.x = newX;\n  p.y = newY;\n  p.angle = newAngle;\n  return p;\n}\n\nfunction getTangentPoint(point, prevPoint, centerPoint, tan, nextStepAngle) {\n  var correctAngle = point.angle + nextStepAngle;\n  var cosSin = (0, _utils.getCosAndSin)(correctAngle);\n  var x = centerPoint.x + (point.radius + tan * nextStepAngle) * cosSin.cos;\n  var y = centerPoint.y - (point.radius + tan * nextStepAngle) * cosSin.sin;\n  return clonePoint(prevPoint, x, y, correctAngle);\n}\n\nfunction obtainCubicBezierTCoef(p, p0, p1, p2, p3) {\n  var d = p0 - p;\n  var c = 3 * p1 - 3 * p0;\n  var b = 3 * p2 - 6 * p1 + 3 * p0;\n  var a = p3 - 3 * p2 + 3 * p1 - p0;\n  return (0, _math.solveCubicEquation)(a, b, c, d);\n}\n\nvar lineMethods = {\n  autoHidePointMarkersEnabled: function autoHidePointMarkersEnabled() {\n    return true;\n  },\n  _applyGroupSettings: function _applyGroupSettings(style, settings, group) {\n    var that = this;\n    settings = (0, _extend.extend)(settings, style);\n\n    that._applyElementsClipRect(settings);\n\n    group.attr(settings);\n  },\n  _setGroupsSettings: function _setGroupsSettings(animationEnabled) {\n    var that = this;\n    var style = that._styles.normal;\n\n    that._applyGroupSettings(style.elements, {\n      \"class\": \"dxc-elements\"\n    }, that._elementsGroup);\n\n    that._bordersGroup && that._applyGroupSettings(style.border, {\n      \"class\": \"dxc-borders\"\n    }, that._bordersGroup);\n\n    _scatter_series.chart._setGroupsSettings.call(that, animationEnabled);\n\n    animationEnabled && that._markersGroup && that._markersGroup.attr({\n      opacity: .001\n    });\n  },\n  _createGroups: function _createGroups() {\n    var that = this;\n\n    that._createGroup(\"_elementsGroup\", that, that._group);\n\n    that._areBordersVisible() && that._createGroup(\"_bordersGroup\", that, that._group);\n\n    _scatter_series.chart._createGroups.call(that);\n  },\n  _areBordersVisible: function _areBordersVisible() {\n    return false;\n  },\n  _getDefaultSegment: function _getDefaultSegment(segment) {\n    return {\n      line: (0, _utils.map)(segment.line || [], function (pt) {\n        return pt.getDefaultCoords();\n      })\n    };\n  },\n  _prepareSegment: function _prepareSegment(points) {\n    return {\n      line: points\n    };\n  },\n  _parseLineOptions: function _parseLineOptions(options, defaultColor) {\n    return {\n      stroke: options.color || defaultColor,\n      \"stroke-width\": options.width,\n      dashStyle: options.dashStyle || \"solid\"\n    };\n  },\n  _parseStyle: function _parseStyle(options, defaultColor) {\n    return {\n      elements: this._parseLineOptions(options, defaultColor)\n    };\n  },\n  _applyStyle: function _applyStyle(style) {\n    var that = this;\n    that._elementsGroup && that._elementsGroup.attr(style.elements);\n    (0, _iterator.each)(that._graphics || [], function (_, graphic) {\n      graphic.line && graphic.line.attr({\n        \"stroke-width\": style.elements[\"stroke-width\"]\n      }).sharp();\n    });\n  },\n  _drawElement: function _drawElement(segment, group) {\n    return {\n      line: this._createMainElement(segment.line, {\n        \"stroke-width\": this._styles.normal.elements[\"stroke-width\"]\n      }).append(group)\n    };\n  },\n  _removeElement: function _removeElement(element) {\n    element.line.remove();\n  },\n  _updateElement: function _updateElement(element, segment, animate, animationComplete) {\n    var params = {\n      points: segment.line\n    };\n    var lineElement = element.line;\n    animate ? lineElement.animate(params, {}, animationComplete) : lineElement.attr(params);\n  },\n  _animateComplete: function _animateComplete() {\n    var that = this;\n\n    _scatter_series.chart._animateComplete.call(that);\n\n    that._markersGroup && that._markersGroup.animate({\n      opacity: 1\n    }, {\n      duration: that._defaultDuration\n    });\n  },\n  _animate: function _animate() {\n    var that = this;\n    var lastIndex = that._graphics.length - 1;\n    (0, _iterator.each)(that._graphics || [], function (i, elem) {\n      var complete;\n\n      if (i === lastIndex) {\n        complete = function complete() {\n          that._animateComplete();\n        };\n      }\n\n      that._updateElement(elem, that._segments[i], true, complete);\n    });\n  },\n  _drawPoint: function _drawPoint(options) {\n    _scatter_series.chart._drawPoint.call(this, {\n      point: options.point,\n      groups: options.groups\n    });\n  },\n  _createMainElement: function _createMainElement(points, settings) {\n    return this._renderer.path(points, \"line\").attr(settings);\n  },\n  _sortPoints: function _sortPoints(points, rotated) {\n    return rotated ? points.sort(function (p1, p2) {\n      return p2.y - p1.y;\n    }) : points.sort(function (p1, p2) {\n      return p1.x - p2.x;\n    });\n  },\n  _drawSegment: function _drawSegment(points, animationEnabled, segmentCount, lastSegment) {\n    var that = this;\n    var rotated = that._options.rotated;\n\n    var segment = that._prepareSegment(points, rotated, lastSegment);\n\n    that._segments.push(segment);\n\n    if (!that._graphics[segmentCount]) {\n      that._graphics[segmentCount] = that._drawElement(animationEnabled ? that._getDefaultSegment(segment) : segment, that._elementsGroup);\n    } else {\n      if (!animationEnabled) {\n        that._updateElement(that._graphics[segmentCount], segment);\n      }\n    }\n  },\n  _getTrackerSettings: function _getTrackerSettings() {\n    var that = this;\n    var defaultTrackerWidth = that._defaultTrackerWidth;\n    var strokeWidthFromElements = that._styles.normal.elements[\"stroke-width\"];\n    return {\n      \"stroke-width\": strokeWidthFromElements > defaultTrackerWidth ? strokeWidthFromElements : defaultTrackerWidth,\n      fill: \"none\"\n    };\n  },\n  _getMainPointsFromSegment: function _getMainPointsFromSegment(segment) {\n    return segment.line;\n  },\n  _drawTrackerElement: function _drawTrackerElement(segment) {\n    return this._createMainElement(this._getMainPointsFromSegment(segment), this._getTrackerSettings(segment));\n  },\n  _updateTrackerElement: function _updateTrackerElement(segment, element) {\n    var settings = this._getTrackerSettings(segment);\n\n    settings.points = this._getMainPointsFromSegment(segment);\n    element.attr(settings);\n  },\n  checkSeriesViewportCoord: function checkSeriesViewportCoord(axis, coord) {\n    if (0 === this._points.length) {\n      return false;\n    }\n\n    var range = axis.isArgumentAxis ? this.getArgumentRange() : this.getViewport();\n    var min = axis.getTranslator().translate(range.categories ? range.categories[0] : range.min);\n    var max = axis.getTranslator().translate(range.categories ? range.categories[range.categories.length - 1] : range.max);\n    var rotated = this.getOptions().rotated;\n    var inverted = axis.getOptions().inverted;\n    return axis.isArgumentAxis && (!rotated && !inverted || rotated && inverted) || !axis.isArgumentAxis && (rotated && !inverted || !rotated && inverted) ? coord >= min && coord <= max : coord >= max && coord <= min;\n  }\n};\nvar lineSeries = chart.line = (0, _extend.extend)({}, _scatter_series.chart, lineMethods, {\n  getPointCenterByArg: function getPointCenterByArg(arg) {\n    var value = this.getArgumentAxis().getTranslator().translate(arg);\n    return {\n      x: value,\n      y: value\n    };\n  },\n  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {\n    var that = this;\n    var oppositeCoord = null;\n\n    var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\n\n    var needValueCoord = isArgument && !that._options.rotated || !isArgument && that._options.rotated;\n\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var p = nearestPoints[i];\n      var k = (p[1].vy - p[0].vy) / (p[1].vx - p[0].vx);\n      var b = p[0].vy - p[0].vx * k;\n      var tmpCoord = void 0;\n\n      if (p[1].vx - p[0].vx === 0) {\n        tmpCoord = needValueCoord ? p[0].vy : p[0].vx;\n      } else {\n        tmpCoord = needValueCoord ? k * coord + b : (coord - b) / k;\n      }\n\n      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  }\n});\nchart.stepline = (0, _extend.extend)({}, lineSeries, {\n  _calculateStepLinePoints: function _calculateStepLinePoints(points) {\n    var segment = [];\n    var coordName = this._options.rotated ? \"x\" : \"y\";\n    (0, _iterator.each)(points, function (i, pt) {\n      var point;\n\n      if (!i) {\n        segment.push(pt);\n        return;\n      }\n\n      var step = segment[segment.length - 1][coordName];\n\n      if (step !== pt[coordName]) {\n        point = (0, _object.clone)(pt);\n        point[coordName] = step;\n        segment.push(point);\n      }\n\n      segment.push(pt);\n    });\n    return segment;\n  },\n  _prepareSegment: function _prepareSegment(points) {\n    return lineSeries._prepareSegment(this._calculateStepLinePoints(points));\n  },\n  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {\n    var oppositeCoord;\n    var rotated = this._options.rotated;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = !isOpposite ? \"vx\" : \"vy\";\n    var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\n\n    var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\n\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var p = nearestPoints[i];\n      var tmpCoord = void 0;\n\n      if (isArgument) {\n        tmpCoord = coord !== p[1][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName];\n      } else {\n        tmpCoord = coord === p[0][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName];\n      }\n\n      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  }\n});\nchart.spline = (0, _extend.extend)({}, lineSeries, {\n  _calculateBezierPoints: function _calculateBezierPoints(src, rotated) {\n    var bezierPoints = [];\n    var pointsCopy = src;\n\n    var checkExtremum = function checkExtremum(otherPointCoord, pointCoord, controlCoord) {\n      return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord;\n    };\n\n    if (1 !== pointsCopy.length) {\n      pointsCopy.forEach(function (curPoint, i) {\n        var leftControlX;\n        var leftControlY;\n        var rightControlX;\n        var rightControlY;\n        var prevPoint = pointsCopy[i - 1];\n        var nextPoint = pointsCopy[i + 1];\n        var x1;\n        var x2;\n        var y1;\n        var y2;\n        var lambda = .5;\n        var a;\n        var b;\n        var c;\n        var xc;\n        var yc;\n        var shift;\n\n        if (!i || i === pointsCopy.length - 1) {\n          bezierPoints.push(curPoint, curPoint);\n          return;\n        }\n\n        var xCur = curPoint.x;\n        var yCur = curPoint.y;\n        x1 = prevPoint.x;\n        x2 = nextPoint.x;\n        y1 = prevPoint.y;\n        y2 = nextPoint.y;\n        var curIsExtremum = !!(!rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));\n\n        if (curIsExtremum) {\n          if (!rotated) {\n            rightControlY = leftControlY = yCur;\n            rightControlX = (xCur + nextPoint.x) / 2;\n            leftControlX = (xCur + prevPoint.x) / 2;\n          } else {\n            rightControlX = leftControlX = xCur;\n            rightControlY = (yCur + nextPoint.y) / 2;\n            leftControlY = (yCur + prevPoint.y) / 2;\n          }\n        } else {\n          a = y2 - y1;\n          b = x1 - x2;\n          c = y1 * x2 - x1 * y2;\n\n          if (!rotated) {\n            if (!b) {\n              bezierPoints.push(curPoint, curPoint, curPoint);\n              return;\n            }\n\n            xc = xCur;\n            yc = -1 * (a * xc + c) / b;\n            shift = yc - yCur;\n            y1 -= shift;\n            y2 -= shift;\n          } else {\n            if (!a) {\n              bezierPoints.push(curPoint, curPoint, curPoint);\n              return;\n            }\n\n            yc = yCur;\n            xc = -1 * (b * yc + c) / a;\n            shift = xc - xCur;\n            x1 -= shift;\n            x2 -= shift;\n          }\n\n          rightControlX = (xCur + lambda * x2) / (1 + lambda);\n          rightControlY = (yCur + lambda * y2) / (1 + lambda);\n          leftControlX = (xCur + lambda * x1) / (1 + lambda);\n          leftControlY = (yCur + lambda * y1) / (1 + lambda);\n        }\n\n        if (!rotated) {\n          leftControlY = checkExtremum(prevPoint.y, yCur, leftControlY);\n          rightControlY = checkExtremum(nextPoint.y, yCur, rightControlY);\n        } else {\n          leftControlX = checkExtremum(prevPoint.x, xCur, leftControlX);\n          rightControlX = checkExtremum(nextPoint.x, xCur, rightControlX);\n        }\n\n        var leftPoint = clonePoint(curPoint, leftControlX, leftControlY);\n        var rightPoint = clonePoint(curPoint, rightControlX, rightControlY);\n        bezierPoints.push(leftPoint, curPoint, rightPoint);\n      });\n    } else {\n      bezierPoints.push(pointsCopy[0]);\n    }\n\n    return bezierPoints;\n  },\n  _prepareSegment: function _prepareSegment(points, rotated) {\n    return lineSeries._prepareSegment(this._calculateBezierPoints(points, rotated));\n  },\n  _createMainElement: function _createMainElement(points, settings) {\n    return this._renderer.path(points, \"bezier\").attr(settings);\n  },\n  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {\n    var that = this;\n    var oppositeCoord = null;\n    var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;\n    var coordName = !isOpposite ? \"vx\" : \"vy\";\n    var bezierCoordName = !isOpposite ? \"x\" : \"y\";\n    var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\n    var bezierOppositeCoordName = !isOpposite ? \"y\" : \"x\";\n    var axis = !isArgument ? that.getArgumentAxis() : that.getValueAxis();\n    var visibleArea = axis.getVisibleArea();\n\n    var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\n\n    var _loop = function _loop(i) {\n      var p = nearestPoints[i];\n\n      if (1 === p.length) {\n        visibleArea[0] <= p[0][oppositeCoordName] && visibleArea[1] >= p[0][oppositeCoordName] && (oppositeCoord = p[0][oppositeCoordName]);\n      } else {\n        var ts = obtainCubicBezierTCoef(coord, p[0][coordName], p[1][bezierCoordName], p[2][bezierCoordName], p[3][coordName]);\n        ts.forEach(function (t) {\n          if (t >= 0 && t <= 1) {\n            var tmpCoord = Math.pow(1 - t, 3) * p[0][oppositeCoordName] + 3 * Math.pow(1 - t, 2) * t * p[1][bezierOppositeCoordName] + 3 * (1 - t) * t * t * p[2][bezierOppositeCoordName] + t * t * t * p[3][oppositeCoordName];\n\n            if (visibleArea[0] <= tmpCoord && visibleArea[1] >= tmpCoord) {\n              oppositeCoord = tmpCoord;\n            }\n          }\n        });\n      }\n\n      if (null !== oppositeCoord) {\n        return \"break\";\n      }\n    };\n\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var _ret = _loop(i);\n\n      if (\"break\" === _ret) {\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  },\n  _getNearestPoints: function _getNearestPoints(point, nextPoint, bezierPoints) {\n    var index = bezierPoints.indexOf(point);\n    return [point, bezierPoints[index + 1], bezierPoints[index + 2], nextPoint];\n  },\n  _getBezierPoints: function _getBezierPoints() {\n    return this._segments.length > 0 ? this._segments.reduce(function (a, seg) {\n      return a.concat(seg.line);\n    }, []) : [];\n  }\n});\npolar.line = (0, _extend.extend)({}, _scatter_series.polar, lineMethods, {\n  _sortPoints: function _sortPoints(points) {\n    return points;\n  },\n  _prepareSegment: function _prepareSegment(points, rotated, lastSegment) {\n    var preparedPoints = [];\n    var centerPoint = this.getValueAxis().getCenter();\n    var i;\n    lastSegment && this._closeSegment(points);\n\n    if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {\n      for (i = 1; i < points.length; i++) {\n        preparedPoints = preparedPoints.concat(this._getTangentPoints(points[i], points[i - 1], centerPoint));\n      }\n\n      if (!preparedPoints.length) {\n        preparedPoints = points;\n      }\n    } else {\n      return lineSeries._prepareSegment.call(this, points);\n    }\n\n    return {\n      line: preparedPoints\n    };\n  },\n  _getRemainingAngle: function _getRemainingAngle(angle) {\n    var normAngle = (0, _utils.normalizeAngle)(angle);\n    return angle >= 0 ? 360 - normAngle : -normAngle;\n  },\n  _closeSegment: function _closeSegment(points) {\n    var point;\n\n    if (this._segments.length) {\n      point = this._segments[0].line[0];\n    } else {\n      point = clonePoint(points[0], points[0].x, points[0].y, points[0].angle);\n    }\n\n    point = this._modifyReflectedPoint(point, points[points.length - 1]);\n\n    if (point) {\n      points.push(point);\n    }\n  },\n  _modifyReflectedPoint: function _modifyReflectedPoint(point, lastPoint) {\n    if (lastPoint.angle === point.angle) {\n      return;\n    }\n\n    if ((0, _utils.normalizeAngle)(round(lastPoint.angle)) === (0, _utils.normalizeAngle)(round(point.angle))) {\n      point.angle = lastPoint.angle;\n    } else {\n      var differenceAngle = lastPoint.angle - point.angle;\n      point.angle = lastPoint.angle + this._getRemainingAngle(differenceAngle);\n    }\n\n    return point;\n  },\n  _getTangentPoints: function _getTangentPoints(point, prevPoint, centerPoint) {\n    var tangentPoints = [];\n    var betweenAngle = Math.round(prevPoint.angle - point.angle);\n    var tan = (prevPoint.radius - point.radius) / betweenAngle;\n    var i;\n\n    if (0 === betweenAngle) {\n      tangentPoints = [prevPoint, point];\n    } else {\n      if (betweenAngle > 0) {\n        for (i = betweenAngle; i >= 0; i--) {\n          tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, i));\n        }\n      } else {\n        for (i = 0; i >= betweenAngle; i--) {\n          tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, betweenAngle - i));\n        }\n      }\n    }\n\n    return tangentPoints;\n  },\n  getSeriesPairCoord: function getSeriesPairCoord(params, isArgument) {\n    var that = this;\n    var argAxis = that.getArgumentAxis();\n    var paramName = isArgument ? \"angle\" : \"radius\";\n    var coordParam = params[paramName];\n    var centerPoint = argAxis.getCenter();\n\n    var getLengthByCoords = function getLengthByCoords(p1, p2) {\n      return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));\n    };\n\n    var isInsideInterval = function isInsideInterval(prevPoint, point, _ref) {\n      var x = _ref.x,\n          y = _ref.y;\n      return getLengthByCoords({\n        x: x,\n        y: y\n      }, centerPoint) <= argAxis.getRadius() && min(prevPoint.x, point.x) <= x && max(prevPoint.x, point.x) >= x && min(prevPoint.y, point.y) <= y && max(prevPoint.y, point.y) >= y;\n    };\n\n    var coords;\n    var neighborPoints = that.getNeighborPoints(coordParam, paramName);\n\n    if (1 === neighborPoints.length) {\n      coords = neighborPoints[0];\n    } else {\n      if (neighborPoints.length > 1) {\n        var prevPoint = neighborPoints[0];\n        var point = neighborPoints[1];\n\n        if (that.argumentAxisType !== DISCRETE && that.valueAxisType !== DISCRETE) {\n          var tan;\n          var stepAngle;\n\n          if (isArgument) {\n            tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);\n            stepAngle = coordParam - point.angle;\n          } else {\n            tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);\n            stepAngle = (coordParam - point.radius) / tan;\n          }\n\n          coords = getTangentPoint(point, prevPoint, centerPoint, tan, stepAngle);\n        } else {\n          if (isArgument) {\n            var cosSin = (0, _utils.getCosAndSin)(-coordParam);\n            var k1 = (point.y - prevPoint.y) / (point.x - prevPoint.x);\n            var b1 = prevPoint.y - prevPoint.x * k1;\n            var k2 = cosSin.sin / cosSin.cos;\n            var b2 = centerPoint.y - k2 * centerPoint.x;\n            var x = (b2 - b1) / (k1 - k2);\n            var y = k1 * x + b1;\n\n            if (isInsideInterval(prevPoint, point, {\n              x: x,\n              y: y\n            })) {\n              var quarter = abs((0, _math.trunc)((360 + coordParam) / 90) % 4);\n\n              if (0 === quarter && x >= centerPoint.x && y <= centerPoint.y || 1 === quarter && x <= centerPoint.x && y <= centerPoint.y || 2 === quarter && x <= centerPoint.x && y >= centerPoint.y || 3 === quarter && x >= centerPoint.x && y >= centerPoint.y) {\n                coords = {\n                  x: x,\n                  y: y\n                };\n              }\n            }\n          } else {\n            var k = (point.y - prevPoint.y) / (point.x - prevPoint.x);\n            var y0 = prevPoint.y - prevPoint.x * k;\n            var a = 1 + k * k;\n            var b = -2 * centerPoint.x + 2 * k * y0 - 2 * k * centerPoint.y;\n            var c = -pow(coordParam, 2) + pow(y0 - centerPoint.y, 2) + pow(centerPoint.x, 2);\n            var d = b * b - 4 * a * c;\n\n            if (d >= 0) {\n              var x1 = (-b - sqrt(d)) / (2 * a);\n              var x2 = (-b + sqrt(d)) / (2 * a);\n              var y1 = k * x1 + y0;\n              var y2 = k * x2 + y0;\n              coords = isInsideInterval(prevPoint, point, {\n                x: x1,\n                y: y1\n              }) ? {\n                x: x1,\n                y: y1\n              } : isInsideInterval(prevPoint, point, {\n                x: x2,\n                y: y2\n              }) ? {\n                x: x2,\n                y: y2\n              } : void 0;\n            }\n          }\n        }\n      }\n    }\n\n    return coords;\n  },\n  getNeighborPoints: function getNeighborPoints(param, paramName) {\n    var points = this.getPoints();\n    var neighborPoints = [];\n\n    if (this.getOptions().closed) {\n      points = (0, _extend.extend)(true, [], points);\n      var lastPoint = points[points.length - 1];\n      var firstPointCopy = clonePoint(points[0], points[0].x, points[0].y, points[0].angle);\n      var lastPointCopy = clonePoint(lastPoint, lastPoint.x, lastPoint.y, lastPoint.angle);\n\n      var rearwardRefPoint = this._modifyReflectedPoint(firstPointCopy, lastPoint);\n\n      var forwardRefPoint = this._modifyReflectedPoint(lastPointCopy, points[0]);\n\n      if (forwardRefPoint) {\n        points.unshift(forwardRefPoint);\n      }\n\n      if (rearwardRefPoint) {\n        points.push(rearwardRefPoint);\n      }\n    }\n\n    for (var i = 1; i < points.length; i++) {\n      if (points[i - 1][paramName] === param) {\n        neighborPoints.push(points[i - 1]);\n      } else {\n        if (points[i][paramName] === param) {\n          neighborPoints.push(points[i]);\n        } else {\n          if (points[i][paramName] > param && points[i - 1][paramName] < param || points[i - 1][paramName] > param && points[i][paramName] < param) {\n            neighborPoints.push(points[i - 1]);\n            neighborPoints.push(points[i]);\n          }\n        }\n      }\n\n      if (neighborPoints.length > 0) {\n        break;\n      }\n    }\n\n    return neighborPoints;\n  }\n});","map":{"version":3,"sources":["E:/Monday.com/quickstart-react/node_modules/devextreme/viz/series/line_series.js"],"names":["exports","polar","chart","_scatter_series","require","_object","_extend","_iterator","_utils","_math","DISCRETE","round","Math","sqrt","pow","min","max","abs","clonePoint","point","newX","newY","newAngle","p","clone","x","y","angle","getTangentPoint","prevPoint","centerPoint","tan","nextStepAngle","correctAngle","cosSin","getCosAndSin","radius","cos","sin","obtainCubicBezierTCoef","p0","p1","p2","p3","d","c","b","a","solveCubicEquation","lineMethods","autoHidePointMarkersEnabled","_applyGroupSettings","style","settings","group","that","extend","_applyElementsClipRect","attr","_setGroupsSettings","animationEnabled","_styles","normal","elements","_elementsGroup","_bordersGroup","border","call","_markersGroup","opacity","_createGroups","_createGroup","_group","_areBordersVisible","_getDefaultSegment","segment","line","map","pt","getDefaultCoords","_prepareSegment","points","_parseLineOptions","options","defaultColor","stroke","color","width","dashStyle","_parseStyle","_applyStyle","each","_graphics","_","graphic","sharp","_drawElement","_createMainElement","append","_removeElement","element","remove","_updateElement","animate","animationComplete","params","lineElement","_animateComplete","duration","_defaultDuration","_animate","lastIndex","length","i","elem","complete","_segments","_drawPoint","groups","_renderer","path","_sortPoints","rotated","sort","_drawSegment","segmentCount","lastSegment","_options","push","_getTrackerSettings","defaultTrackerWidth","_defaultTrackerWidth","strokeWidthFromElements","fill","_getMainPointsFromSegment","_drawTrackerElement","_updateTrackerElement","checkSeriesViewportCoord","axis","coord","_points","range","isArgumentAxis","getArgumentRange","getViewport","getTranslator","translate","categories","getOptions","inverted","lineSeries","getPointCenterByArg","arg","value","getArgumentAxis","getSeriesPairCoord","isArgument","oppositeCoord","nearestPoints","_getNearestPointsByCoord","needValueCoord","k","vy","vx","tmpCoord","_checkAxisVisibleAreaCoord","stepline","_calculateStepLinePoints","coordName","step","isOpposite","oppositeCoordName","spline","_calculateBezierPoints","src","bezierPoints","pointsCopy","checkExtremum","otherPointCoord","pointCoord","controlCoord","forEach","curPoint","leftControlX","leftControlY","rightControlX","rightControlY","nextPoint","x1","x2","y1","y2","lambda","xc","yc","shift","xCur","yCur","curIsExtremum","leftPoint","rightPoint","bezierCoordName","bezierOppositeCoordName","getValueAxis","visibleArea","getVisibleArea","_loop","ts","t","_ret","_getNearestPoints","index","indexOf","_getBezierPoints","reduce","seg","concat","preparedPoints","getCenter","_closeSegment","argumentAxisType","valueAxisType","_getTangentPoints","_getRemainingAngle","normAngle","normalizeAngle","_modifyReflectedPoint","lastPoint","differenceAngle","tangentPoints","betweenAngle","argAxis","paramName","coordParam","getLengthByCoords","isInsideInterval","_ref","getRadius","coords","neighborPoints","getNeighborPoints","stepAngle","k1","b1","k2","b2","quarter","trunc","y0","param","getPoints","closed","firstPointCopy","lastPointCopy","rearwardRefPoint","forwardRefPoint","unshift"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/series/line_series.js)\r\n * Version: 20.2.3\r\n * Build date: Tue Oct 20 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nexports.polar = exports.chart = void 0;\r\nvar _scatter_series = require(\"./scatter_series\");\r\nvar _object = require(\"../../core/utils/object\");\r\nvar _extend = require(\"../../core/utils/extend\");\r\nvar _iterator = require(\"../../core/utils/iterator\");\r\nvar _utils = require(\"../core/utils\");\r\nvar _math = require(\"../../core/utils/math\");\r\nvar DISCRETE = \"discrete\";\r\nvar round = Math.round,\r\n    sqrt = Math.sqrt,\r\n    pow = Math.pow,\r\n    min = Math.min,\r\n    max = Math.max,\r\n    abs = Math.abs;\r\nvar chart = {};\r\nexports.chart = chart;\r\nvar polar = {};\r\nexports.polar = polar;\r\n\r\nfunction clonePoint(point, newX, newY, newAngle) {\r\n    var p = (0, _object.clone)(point);\r\n    p.x = newX;\r\n    p.y = newY;\r\n    p.angle = newAngle;\r\n    return p\r\n}\r\n\r\nfunction getTangentPoint(point, prevPoint, centerPoint, tan, nextStepAngle) {\r\n    var correctAngle = point.angle + nextStepAngle;\r\n    var cosSin = (0, _utils.getCosAndSin)(correctAngle);\r\n    var x = centerPoint.x + (point.radius + tan * nextStepAngle) * cosSin.cos;\r\n    var y = centerPoint.y - (point.radius + tan * nextStepAngle) * cosSin.sin;\r\n    return clonePoint(prevPoint, x, y, correctAngle)\r\n}\r\n\r\nfunction obtainCubicBezierTCoef(p, p0, p1, p2, p3) {\r\n    var d = p0 - p;\r\n    var c = 3 * p1 - 3 * p0;\r\n    var b = 3 * p2 - 6 * p1 + 3 * p0;\r\n    var a = p3 - 3 * p2 + 3 * p1 - p0;\r\n    return (0, _math.solveCubicEquation)(a, b, c, d)\r\n}\r\nvar lineMethods = {\r\n    autoHidePointMarkersEnabled: function() {\r\n        return true\r\n    },\r\n    _applyGroupSettings: function(style, settings, group) {\r\n        var that = this;\r\n        settings = (0, _extend.extend)(settings, style);\r\n        that._applyElementsClipRect(settings);\r\n        group.attr(settings)\r\n    },\r\n    _setGroupsSettings: function(animationEnabled) {\r\n        var that = this;\r\n        var style = that._styles.normal;\r\n        that._applyGroupSettings(style.elements, {\r\n            \"class\": \"dxc-elements\"\r\n        }, that._elementsGroup);\r\n        that._bordersGroup && that._applyGroupSettings(style.border, {\r\n            \"class\": \"dxc-borders\"\r\n        }, that._bordersGroup);\r\n        _scatter_series.chart._setGroupsSettings.call(that, animationEnabled);\r\n        animationEnabled && that._markersGroup && that._markersGroup.attr({\r\n            opacity: .001\r\n        })\r\n    },\r\n    _createGroups: function() {\r\n        var that = this;\r\n        that._createGroup(\"_elementsGroup\", that, that._group);\r\n        that._areBordersVisible() && that._createGroup(\"_bordersGroup\", that, that._group);\r\n        _scatter_series.chart._createGroups.call(that)\r\n    },\r\n    _areBordersVisible: function() {\r\n        return false\r\n    },\r\n    _getDefaultSegment: function(segment) {\r\n        return {\r\n            line: (0, _utils.map)(segment.line || [], function(pt) {\r\n                return pt.getDefaultCoords()\r\n            })\r\n        }\r\n    },\r\n    _prepareSegment: function(points) {\r\n        return {\r\n            line: points\r\n        }\r\n    },\r\n    _parseLineOptions: function(options, defaultColor) {\r\n        return {\r\n            stroke: options.color || defaultColor,\r\n            \"stroke-width\": options.width,\r\n            dashStyle: options.dashStyle || \"solid\"\r\n        }\r\n    },\r\n    _parseStyle: function(options, defaultColor) {\r\n        return {\r\n            elements: this._parseLineOptions(options, defaultColor)\r\n        }\r\n    },\r\n    _applyStyle: function(style) {\r\n        var that = this;\r\n        that._elementsGroup && that._elementsGroup.attr(style.elements);\r\n        (0, _iterator.each)(that._graphics || [], function(_, graphic) {\r\n            graphic.line && graphic.line.attr({\r\n                \"stroke-width\": style.elements[\"stroke-width\"]\r\n            }).sharp()\r\n        })\r\n    },\r\n    _drawElement: function(segment, group) {\r\n        return {\r\n            line: this._createMainElement(segment.line, {\r\n                \"stroke-width\": this._styles.normal.elements[\"stroke-width\"]\r\n            }).append(group)\r\n        }\r\n    },\r\n    _removeElement: function(element) {\r\n        element.line.remove()\r\n    },\r\n    _updateElement: function(element, segment, animate, animationComplete) {\r\n        var params = {\r\n            points: segment.line\r\n        };\r\n        var lineElement = element.line;\r\n        animate ? lineElement.animate(params, {}, animationComplete) : lineElement.attr(params)\r\n    },\r\n    _animateComplete: function() {\r\n        var that = this;\r\n        _scatter_series.chart._animateComplete.call(that);\r\n        that._markersGroup && that._markersGroup.animate({\r\n            opacity: 1\r\n        }, {\r\n            duration: that._defaultDuration\r\n        })\r\n    },\r\n    _animate: function() {\r\n        var that = this;\r\n        var lastIndex = that._graphics.length - 1;\r\n        (0, _iterator.each)(that._graphics || [], function(i, elem) {\r\n            var complete;\r\n            if (i === lastIndex) {\r\n                complete = function() {\r\n                    that._animateComplete()\r\n                }\r\n            }\r\n            that._updateElement(elem, that._segments[i], true, complete)\r\n        })\r\n    },\r\n    _drawPoint: function(options) {\r\n        _scatter_series.chart._drawPoint.call(this, {\r\n            point: options.point,\r\n            groups: options.groups\r\n        })\r\n    },\r\n    _createMainElement: function(points, settings) {\r\n        return this._renderer.path(points, \"line\").attr(settings)\r\n    },\r\n    _sortPoints: function(points, rotated) {\r\n        return rotated ? points.sort(function(p1, p2) {\r\n            return p2.y - p1.y\r\n        }) : points.sort(function(p1, p2) {\r\n            return p1.x - p2.x\r\n        })\r\n    },\r\n    _drawSegment: function(points, animationEnabled, segmentCount, lastSegment) {\r\n        var that = this;\r\n        var rotated = that._options.rotated;\r\n        var segment = that._prepareSegment(points, rotated, lastSegment);\r\n        that._segments.push(segment);\r\n        if (!that._graphics[segmentCount]) {\r\n            that._graphics[segmentCount] = that._drawElement(animationEnabled ? that._getDefaultSegment(segment) : segment, that._elementsGroup)\r\n        } else {\r\n            if (!animationEnabled) {\r\n                that._updateElement(that._graphics[segmentCount], segment)\r\n            }\r\n        }\r\n    },\r\n    _getTrackerSettings: function() {\r\n        var that = this;\r\n        var defaultTrackerWidth = that._defaultTrackerWidth;\r\n        var strokeWidthFromElements = that._styles.normal.elements[\"stroke-width\"];\r\n        return {\r\n            \"stroke-width\": strokeWidthFromElements > defaultTrackerWidth ? strokeWidthFromElements : defaultTrackerWidth,\r\n            fill: \"none\"\r\n        }\r\n    },\r\n    _getMainPointsFromSegment: function(segment) {\r\n        return segment.line\r\n    },\r\n    _drawTrackerElement: function(segment) {\r\n        return this._createMainElement(this._getMainPointsFromSegment(segment), this._getTrackerSettings(segment))\r\n    },\r\n    _updateTrackerElement: function(segment, element) {\r\n        var settings = this._getTrackerSettings(segment);\r\n        settings.points = this._getMainPointsFromSegment(segment);\r\n        element.attr(settings)\r\n    },\r\n    checkSeriesViewportCoord: function(axis, coord) {\r\n        if (0 === this._points.length) {\r\n            return false\r\n        }\r\n        var range = axis.isArgumentAxis ? this.getArgumentRange() : this.getViewport();\r\n        var min = axis.getTranslator().translate(range.categories ? range.categories[0] : range.min);\r\n        var max = axis.getTranslator().translate(range.categories ? range.categories[range.categories.length - 1] : range.max);\r\n        var rotated = this.getOptions().rotated;\r\n        var inverted = axis.getOptions().inverted;\r\n        return axis.isArgumentAxis && (!rotated && !inverted || rotated && inverted) || !axis.isArgumentAxis && (rotated && !inverted || !rotated && inverted) ? coord >= min && coord <= max : coord >= max && coord <= min\r\n    }\r\n};\r\nvar lineSeries = chart.line = (0, _extend.extend)({}, _scatter_series.chart, lineMethods, {\r\n    getPointCenterByArg: function(arg) {\r\n        var value = this.getArgumentAxis().getTranslator().translate(arg);\r\n        return {\r\n            x: value,\r\n            y: value\r\n        }\r\n    },\r\n    getSeriesPairCoord: function(coord, isArgument) {\r\n        var that = this;\r\n        var oppositeCoord = null;\r\n        var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\r\n        var needValueCoord = isArgument && !that._options.rotated || !isArgument && that._options.rotated;\r\n        for (var i = 0; i < nearestPoints.length; i++) {\r\n            var p = nearestPoints[i];\r\n            var k = (p[1].vy - p[0].vy) / (p[1].vx - p[0].vx);\r\n            var b = p[0].vy - p[0].vx * k;\r\n            var tmpCoord = void 0;\r\n            if (p[1].vx - p[0].vx === 0) {\r\n                tmpCoord = needValueCoord ? p[0].vy : p[0].vx\r\n            } else {\r\n                tmpCoord = needValueCoord ? k * coord + b : (coord - b) / k\r\n            }\r\n            if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\r\n                oppositeCoord = tmpCoord;\r\n                break\r\n            }\r\n        }\r\n        return oppositeCoord\r\n    }\r\n});\r\nchart.stepline = (0, _extend.extend)({}, lineSeries, {\r\n    _calculateStepLinePoints: function(points) {\r\n        var segment = [];\r\n        var coordName = this._options.rotated ? \"x\" : \"y\";\r\n        (0, _iterator.each)(points, function(i, pt) {\r\n            var point;\r\n            if (!i) {\r\n                segment.push(pt);\r\n                return\r\n            }\r\n            var step = segment[segment.length - 1][coordName];\r\n            if (step !== pt[coordName]) {\r\n                point = (0, _object.clone)(pt);\r\n                point[coordName] = step;\r\n                segment.push(point)\r\n            }\r\n            segment.push(pt)\r\n        });\r\n        return segment\r\n    },\r\n    _prepareSegment: function(points) {\r\n        return lineSeries._prepareSegment(this._calculateStepLinePoints(points))\r\n    },\r\n    getSeriesPairCoord: function(coord, isArgument) {\r\n        var oppositeCoord;\r\n        var rotated = this._options.rotated;\r\n        var isOpposite = !isArgument && !rotated || isArgument && rotated;\r\n        var coordName = !isOpposite ? \"vx\" : \"vy\";\r\n        var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\r\n        var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\r\n        for (var i = 0; i < nearestPoints.length; i++) {\r\n            var p = nearestPoints[i];\r\n            var tmpCoord = void 0;\r\n            if (isArgument) {\r\n                tmpCoord = coord !== p[1][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName]\r\n            } else {\r\n                tmpCoord = coord === p[0][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName]\r\n            }\r\n            if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\r\n                oppositeCoord = tmpCoord;\r\n                break\r\n            }\r\n        }\r\n        return oppositeCoord\r\n    }\r\n});\r\nchart.spline = (0, _extend.extend)({}, lineSeries, {\r\n    _calculateBezierPoints: function(src, rotated) {\r\n        var bezierPoints = [];\r\n        var pointsCopy = src;\r\n        var checkExtremum = function(otherPointCoord, pointCoord, controlCoord) {\r\n            return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord\r\n        };\r\n        if (1 !== pointsCopy.length) {\r\n            pointsCopy.forEach(function(curPoint, i) {\r\n                var leftControlX;\r\n                var leftControlY;\r\n                var rightControlX;\r\n                var rightControlY;\r\n                var prevPoint = pointsCopy[i - 1];\r\n                var nextPoint = pointsCopy[i + 1];\r\n                var x1;\r\n                var x2;\r\n                var y1;\r\n                var y2;\r\n                var lambda = .5;\r\n                var a;\r\n                var b;\r\n                var c;\r\n                var xc;\r\n                var yc;\r\n                var shift;\r\n                if (!i || i === pointsCopy.length - 1) {\r\n                    bezierPoints.push(curPoint, curPoint);\r\n                    return\r\n                }\r\n                var xCur = curPoint.x;\r\n                var yCur = curPoint.y;\r\n                x1 = prevPoint.x;\r\n                x2 = nextPoint.x;\r\n                y1 = prevPoint.y;\r\n                y2 = nextPoint.y;\r\n                var curIsExtremum = !!(!rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));\r\n                if (curIsExtremum) {\r\n                    if (!rotated) {\r\n                        rightControlY = leftControlY = yCur;\r\n                        rightControlX = (xCur + nextPoint.x) / 2;\r\n                        leftControlX = (xCur + prevPoint.x) / 2\r\n                    } else {\r\n                        rightControlX = leftControlX = xCur;\r\n                        rightControlY = (yCur + nextPoint.y) / 2;\r\n                        leftControlY = (yCur + prevPoint.y) / 2\r\n                    }\r\n                } else {\r\n                    a = y2 - y1;\r\n                    b = x1 - x2;\r\n                    c = y1 * x2 - x1 * y2;\r\n                    if (!rotated) {\r\n                        if (!b) {\r\n                            bezierPoints.push(curPoint, curPoint, curPoint);\r\n                            return\r\n                        }\r\n                        xc = xCur;\r\n                        yc = -1 * (a * xc + c) / b;\r\n                        shift = yc - yCur;\r\n                        y1 -= shift;\r\n                        y2 -= shift\r\n                    } else {\r\n                        if (!a) {\r\n                            bezierPoints.push(curPoint, curPoint, curPoint);\r\n                            return\r\n                        }\r\n                        yc = yCur;\r\n                        xc = -1 * (b * yc + c) / a;\r\n                        shift = xc - xCur;\r\n                        x1 -= shift;\r\n                        x2 -= shift\r\n                    }\r\n                    rightControlX = (xCur + lambda * x2) / (1 + lambda);\r\n                    rightControlY = (yCur + lambda * y2) / (1 + lambda);\r\n                    leftControlX = (xCur + lambda * x1) / (1 + lambda);\r\n                    leftControlY = (yCur + lambda * y1) / (1 + lambda)\r\n                }\r\n                if (!rotated) {\r\n                    leftControlY = checkExtremum(prevPoint.y, yCur, leftControlY);\r\n                    rightControlY = checkExtremum(nextPoint.y, yCur, rightControlY)\r\n                } else {\r\n                    leftControlX = checkExtremum(prevPoint.x, xCur, leftControlX);\r\n                    rightControlX = checkExtremum(nextPoint.x, xCur, rightControlX)\r\n                }\r\n                var leftPoint = clonePoint(curPoint, leftControlX, leftControlY);\r\n                var rightPoint = clonePoint(curPoint, rightControlX, rightControlY);\r\n                bezierPoints.push(leftPoint, curPoint, rightPoint)\r\n            })\r\n        } else {\r\n            bezierPoints.push(pointsCopy[0])\r\n        }\r\n        return bezierPoints\r\n    },\r\n    _prepareSegment: function(points, rotated) {\r\n        return lineSeries._prepareSegment(this._calculateBezierPoints(points, rotated))\r\n    },\r\n    _createMainElement: function(points, settings) {\r\n        return this._renderer.path(points, \"bezier\").attr(settings)\r\n    },\r\n    getSeriesPairCoord: function(coord, isArgument) {\r\n        var that = this;\r\n        var oppositeCoord = null;\r\n        var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;\r\n        var coordName = !isOpposite ? \"vx\" : \"vy\";\r\n        var bezierCoordName = !isOpposite ? \"x\" : \"y\";\r\n        var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\r\n        var bezierOppositeCoordName = !isOpposite ? \"y\" : \"x\";\r\n        var axis = !isArgument ? that.getArgumentAxis() : that.getValueAxis();\r\n        var visibleArea = axis.getVisibleArea();\r\n        var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\r\n        var _loop = function(i) {\r\n            var p = nearestPoints[i];\r\n            if (1 === p.length) {\r\n                visibleArea[0] <= p[0][oppositeCoordName] && visibleArea[1] >= p[0][oppositeCoordName] && (oppositeCoord = p[0][oppositeCoordName])\r\n            } else {\r\n                var ts = obtainCubicBezierTCoef(coord, p[0][coordName], p[1][bezierCoordName], p[2][bezierCoordName], p[3][coordName]);\r\n                ts.forEach(function(t) {\r\n                    if (t >= 0 && t <= 1) {\r\n                        var tmpCoord = Math.pow(1 - t, 3) * p[0][oppositeCoordName] + 3 * Math.pow(1 - t, 2) * t * p[1][bezierOppositeCoordName] + 3 * (1 - t) * t * t * p[2][bezierOppositeCoordName] + t * t * t * p[3][oppositeCoordName];\r\n                        if (visibleArea[0] <= tmpCoord && visibleArea[1] >= tmpCoord) {\r\n                            oppositeCoord = tmpCoord\r\n                        }\r\n                    }\r\n                })\r\n            }\r\n            if (null !== oppositeCoord) {\r\n                return \"break\"\r\n            }\r\n        };\r\n        for (var i = 0; i < nearestPoints.length; i++) {\r\n            var _ret = _loop(i);\r\n            if (\"break\" === _ret) {\r\n                break\r\n            }\r\n        }\r\n        return oppositeCoord\r\n    },\r\n    _getNearestPoints: function(point, nextPoint, bezierPoints) {\r\n        var index = bezierPoints.indexOf(point);\r\n        return [point, bezierPoints[index + 1], bezierPoints[index + 2], nextPoint]\r\n    },\r\n    _getBezierPoints: function() {\r\n        return this._segments.length > 0 ? this._segments.reduce(function(a, seg) {\r\n            return a.concat(seg.line)\r\n        }, []) : []\r\n    }\r\n});\r\npolar.line = (0, _extend.extend)({}, _scatter_series.polar, lineMethods, {\r\n    _sortPoints: function(points) {\r\n        return points\r\n    },\r\n    _prepareSegment: function(points, rotated, lastSegment) {\r\n        var preparedPoints = [];\r\n        var centerPoint = this.getValueAxis().getCenter();\r\n        var i;\r\n        lastSegment && this._closeSegment(points);\r\n        if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {\r\n            for (i = 1; i < points.length; i++) {\r\n                preparedPoints = preparedPoints.concat(this._getTangentPoints(points[i], points[i - 1], centerPoint))\r\n            }\r\n            if (!preparedPoints.length) {\r\n                preparedPoints = points\r\n            }\r\n        } else {\r\n            return lineSeries._prepareSegment.call(this, points)\r\n        }\r\n        return {\r\n            line: preparedPoints\r\n        }\r\n    },\r\n    _getRemainingAngle: function(angle) {\r\n        var normAngle = (0, _utils.normalizeAngle)(angle);\r\n        return angle >= 0 ? 360 - normAngle : -normAngle\r\n    },\r\n    _closeSegment: function(points) {\r\n        var point;\r\n        if (this._segments.length) {\r\n            point = this._segments[0].line[0]\r\n        } else {\r\n            point = clonePoint(points[0], points[0].x, points[0].y, points[0].angle)\r\n        }\r\n        point = this._modifyReflectedPoint(point, points[points.length - 1]);\r\n        if (point) {\r\n            points.push(point)\r\n        }\r\n    },\r\n    _modifyReflectedPoint: function(point, lastPoint) {\r\n        if (lastPoint.angle === point.angle) {\r\n            return\r\n        }\r\n        if ((0, _utils.normalizeAngle)(round(lastPoint.angle)) === (0, _utils.normalizeAngle)(round(point.angle))) {\r\n            point.angle = lastPoint.angle\r\n        } else {\r\n            var differenceAngle = lastPoint.angle - point.angle;\r\n            point.angle = lastPoint.angle + this._getRemainingAngle(differenceAngle)\r\n        }\r\n        return point\r\n    },\r\n    _getTangentPoints: function(point, prevPoint, centerPoint) {\r\n        var tangentPoints = [];\r\n        var betweenAngle = Math.round(prevPoint.angle - point.angle);\r\n        var tan = (prevPoint.radius - point.radius) / betweenAngle;\r\n        var i;\r\n        if (0 === betweenAngle) {\r\n            tangentPoints = [prevPoint, point]\r\n        } else {\r\n            if (betweenAngle > 0) {\r\n                for (i = betweenAngle; i >= 0; i--) {\r\n                    tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, i))\r\n                }\r\n            } else {\r\n                for (i = 0; i >= betweenAngle; i--) {\r\n                    tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, betweenAngle - i))\r\n                }\r\n            }\r\n        }\r\n        return tangentPoints\r\n    },\r\n    getSeriesPairCoord: function(params, isArgument) {\r\n        var that = this;\r\n        var argAxis = that.getArgumentAxis();\r\n        var paramName = isArgument ? \"angle\" : \"radius\";\r\n        var coordParam = params[paramName];\r\n        var centerPoint = argAxis.getCenter();\r\n        var getLengthByCoords = function(p1, p2) {\r\n            return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2))\r\n        };\r\n        var isInsideInterval = function(prevPoint, point, _ref) {\r\n            var x = _ref.x,\r\n                y = _ref.y;\r\n            return getLengthByCoords({\r\n                x: x,\r\n                y: y\r\n            }, centerPoint) <= argAxis.getRadius() && min(prevPoint.x, point.x) <= x && max(prevPoint.x, point.x) >= x && min(prevPoint.y, point.y) <= y && max(prevPoint.y, point.y) >= y\r\n        };\r\n        var coords;\r\n        var neighborPoints = that.getNeighborPoints(coordParam, paramName);\r\n        if (1 === neighborPoints.length) {\r\n            coords = neighborPoints[0]\r\n        } else {\r\n            if (neighborPoints.length > 1) {\r\n                var prevPoint = neighborPoints[0];\r\n                var point = neighborPoints[1];\r\n                if (that.argumentAxisType !== DISCRETE && that.valueAxisType !== DISCRETE) {\r\n                    var tan;\r\n                    var stepAngle;\r\n                    if (isArgument) {\r\n                        tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);\r\n                        stepAngle = coordParam - point.angle\r\n                    } else {\r\n                        tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);\r\n                        stepAngle = (coordParam - point.radius) / tan\r\n                    }\r\n                    coords = getTangentPoint(point, prevPoint, centerPoint, tan, stepAngle)\r\n                } else {\r\n                    if (isArgument) {\r\n                        var cosSin = (0, _utils.getCosAndSin)(-coordParam);\r\n                        var k1 = (point.y - prevPoint.y) / (point.x - prevPoint.x);\r\n                        var b1 = prevPoint.y - prevPoint.x * k1;\r\n                        var k2 = cosSin.sin / cosSin.cos;\r\n                        var b2 = centerPoint.y - k2 * centerPoint.x;\r\n                        var x = (b2 - b1) / (k1 - k2);\r\n                        var y = k1 * x + b1;\r\n                        if (isInsideInterval(prevPoint, point, {\r\n                                x: x,\r\n                                y: y\r\n                            })) {\r\n                            var quarter = abs((0, _math.trunc)((360 + coordParam) / 90) % 4);\r\n                            if (0 === quarter && x >= centerPoint.x && y <= centerPoint.y || 1 === quarter && x <= centerPoint.x && y <= centerPoint.y || 2 === quarter && x <= centerPoint.x && y >= centerPoint.y || 3 === quarter && x >= centerPoint.x && y >= centerPoint.y) {\r\n                                coords = {\r\n                                    x: x,\r\n                                    y: y\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        var k = (point.y - prevPoint.y) / (point.x - prevPoint.x);\r\n                        var y0 = prevPoint.y - prevPoint.x * k;\r\n                        var a = 1 + k * k;\r\n                        var b = -2 * centerPoint.x + 2 * k * y0 - 2 * k * centerPoint.y;\r\n                        var c = -pow(coordParam, 2) + pow(y0 - centerPoint.y, 2) + pow(centerPoint.x, 2);\r\n                        var d = b * b - 4 * a * c;\r\n                        if (d >= 0) {\r\n                            var x1 = (-b - sqrt(d)) / (2 * a);\r\n                            var x2 = (-b + sqrt(d)) / (2 * a);\r\n                            var y1 = k * x1 + y0;\r\n                            var y2 = k * x2 + y0;\r\n                            coords = isInsideInterval(prevPoint, point, {\r\n                                x: x1,\r\n                                y: y1\r\n                            }) ? {\r\n                                x: x1,\r\n                                y: y1\r\n                            } : isInsideInterval(prevPoint, point, {\r\n                                x: x2,\r\n                                y: y2\r\n                            }) ? {\r\n                                x: x2,\r\n                                y: y2\r\n                            } : void 0\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return coords\r\n    },\r\n    getNeighborPoints: function(param, paramName) {\r\n        var points = this.getPoints();\r\n        var neighborPoints = [];\r\n        if (this.getOptions().closed) {\r\n            points = (0, _extend.extend)(true, [], points);\r\n            var lastPoint = points[points.length - 1];\r\n            var firstPointCopy = clonePoint(points[0], points[0].x, points[0].y, points[0].angle);\r\n            var lastPointCopy = clonePoint(lastPoint, lastPoint.x, lastPoint.y, lastPoint.angle);\r\n            var rearwardRefPoint = this._modifyReflectedPoint(firstPointCopy, lastPoint);\r\n            var forwardRefPoint = this._modifyReflectedPoint(lastPointCopy, points[0]);\r\n            if (forwardRefPoint) {\r\n                points.unshift(forwardRefPoint)\r\n            }\r\n            if (rearwardRefPoint) {\r\n                points.push(rearwardRefPoint)\r\n            }\r\n        }\r\n        for (var i = 1; i < points.length; i++) {\r\n            if (points[i - 1][paramName] === param) {\r\n                neighborPoints.push(points[i - 1])\r\n            } else {\r\n                if (points[i][paramName] === param) {\r\n                    neighborPoints.push(points[i])\r\n                } else {\r\n                    if (points[i][paramName] > param && points[i - 1][paramName] < param || points[i - 1][paramName] > param && points[i][paramName] < param) {\r\n                        neighborPoints.push(points[i - 1]);\r\n                        neighborPoints.push(points[i])\r\n                    }\r\n                }\r\n            }\r\n            if (neighborPoints.length > 0) {\r\n                break\r\n            }\r\n        }\r\n        return neighborPoints\r\n    }\r\n});\r\n"]},"metadata":{},"sourceType":"script"}