/**
 * DevExtreme (ui/scheduler/ui.scheduler.js)
 * Version: 20.2.3
 * Build date: Tue Oct 20 2020
 *
 * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
exports.default = void 0;
var _component_registrator = _interopRequireDefault(require("../../core/component_registrator"));
var _config = _interopRequireDefault(require("../../core/config"));
var _devices = _interopRequireDefault(require("../../core/devices"));
var _renderer = _interopRequireDefault(require("../../core/renderer"));
var _bindable_template = require("../../core/templates/bindable_template");
var _empty_template = require("../../core/templates/empty_template");
var _array = require("../../core/utils/array");
var _browser = _interopRequireDefault(require("../../core/utils/browser"));
var _callbacks = _interopRequireDefault(require("../../core/utils/callbacks"));
var _common = require("../../core/utils/common");
var _data = require("../../core/utils/data");
var _position = require("../../core/utils/position");
var _date = _interopRequireDefault(require("../../core/utils/date"));
var _date_serialization = _interopRequireDefault(require("../../core/utils/date_serialization"));
var _deferred = require("../../core/utils/deferred");
var _extend = require("../../core/utils/extend");
var _iterator = require("../../core/utils/iterator");
var _support = require("../../core/utils/support");
var _type = require("../../core/utils/type");
var _window = require("../../core/utils/window");
var _data_helper = _interopRequireDefault(require("../../data_helper"));
var _visibility_change = require("../../events/visibility_change");
var _date2 = _interopRequireDefault(require("../../localization/date"));
var _message = _interopRequireDefault(require("../../localization/message"));
var _dialog = require("../dialog");
var _themes = require("../themes");
var _ui = _interopRequireDefault(require("../widget/ui.errors"));
var _ui2 = _interopRequireDefault(require("../widget/ui.widget"));
var _appointmentPopup = _interopRequireDefault(require("./appointmentPopup"));
var _compactAppointmentsHelper = require("./compactAppointmentsHelper");
var _desktopTooltipStrategy = require("./tooltip_strategies/desktopTooltipStrategy");
var _mobileTooltipStrategy = require("./tooltip_strategies/mobileTooltipStrategy");
var _ui3 = require("./ui.loading");
var _uiScheduler = _interopRequireDefault(require("./ui.scheduler.appointments"));
var _uiSchedulerAppointments = _interopRequireDefault(require("./ui.scheduler.appointments.layout_manager"));
var _uiScheduler2 = _interopRequireDefault(require("./ui.scheduler.appointment_model"));
var _uiScheduler3 = _interopRequireDefault(require("./ui.scheduler.header"));
var _uiScheduler4 = _interopRequireDefault(require("./ui.scheduler.resource_manager"));
var _uiScheduler5 = _interopRequireDefault(require("./ui.scheduler.subscribes"));
var _recurrence = require("./recurrence");
var _utils = _interopRequireDefault(require("./utils.timeZone"));
var _uiScheduler6 = _interopRequireDefault(require("./workspaces/ui.scheduler.agenda"));
var _uiScheduler7 = _interopRequireDefault(require("./workspaces/ui.scheduler.timeline_day"));
var _uiScheduler8 = _interopRequireDefault(require("./workspaces/ui.scheduler.timeline_month"));
var _uiScheduler9 = _interopRequireDefault(require("./workspaces/ui.scheduler.timeline_week"));
var _uiScheduler10 = _interopRequireDefault(require("./workspaces/ui.scheduler.timeline_work_week"));
var _uiScheduler11 = _interopRequireDefault(require("./workspaces/ui.scheduler.work_space_day"));
var _uiScheduler12 = _interopRequireDefault(require("./workspaces/ui.scheduler.work_space_month"));
var _uiScheduler13 = _interopRequireDefault(require("./workspaces/ui.scheduler.work_space_week"));
var _uiScheduler14 = _interopRequireDefault(require("./workspaces/ui.scheduler.work_space_work_week"));
var _appointmentAdapter = _interopRequireDefault(require("./appointmentAdapter"));
var _timeZoneCalculator = require("./timeZoneCalculator");
var _dataStructures = require("./dataStructures");
var _appointmentSettingsGenerator = require("./appointmentSettingsGenerator");
var _utils2 = _interopRequireDefault(require("./utils"));
var _dateAdapter = _interopRequireDefault(require("./dateAdapter"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _typeof(obj) {
    "@babel/helpers - typeof";
    if ("function" === typeof Symbol && "symbol" === typeof Symbol.iterator) {
        _typeof = function(obj) {
            return typeof obj
        }
    } else {
        _typeof = function(obj) {
            return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
        }
    }
    return _typeof(obj)
}

function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        })
    } else {
        obj[key] = value
    }
    return obj
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function")
    }
}

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) {
            descriptor.writable = true
        }
        Object.defineProperty(target, descriptor.key, descriptor)
    }
}

function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) {
        _defineProperties(Constructor.prototype, protoProps)
    }
    if (staticProps) {
        _defineProperties(Constructor, staticProps)
    }
    return Constructor
}

function _get(target, property, receiver) {
    if ("undefined" !== typeof Reflect && Reflect.get) {
        _get = Reflect.get
    } else {
        _get = function(target, property, receiver) {
            var base = _superPropBase(target, property);
            if (!base) {
                return
            }
            var desc = Object.getOwnPropertyDescriptor(base, property);
            if (desc.get) {
                return desc.get.call(receiver)
            }
            return desc.value
        }
    }
    return _get(target, property, receiver || target)
}

function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (null === object) {
            break
        }
    }
    return object
}

function _inherits(subClass, superClass) {
    if ("function" !== typeof superClass && null !== superClass) {
        throw new TypeError("Super expression must either be null or a function")
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) {
        _setPrototypeOf(subClass, superClass)
    }
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}

function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function() {
        var result, Super = _getPrototypeOf(Derived);
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget)
        } else {
            result = Super.apply(this, arguments)
        }
        return _possibleConstructorReturn(this, result)
    }
}

function _possibleConstructorReturn(self, call) {
    if (call && ("object" === _typeof(call) || "function" === typeof call)) {
        return call
    }
    return _assertThisInitialized(self)
}

function _assertThisInitialized(self) {
    if (void 0 === self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
    }
    return self
}

function _isNativeReflectConstruct() {
    if ("undefined" === typeof Reflect || !Reflect.construct) {
        return false
    }
    if (Reflect.construct.sham) {
        return false
    }
    if ("function" === typeof Proxy) {
        return true
    }
    try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
        return true
    } catch (e) {
        return false
    }
}

function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
        return o.__proto__ || Object.getPrototypeOf(o)
    };
    return _getPrototypeOf(o)
}
var MINUTES_IN_HOUR = 60;
var WIDGET_CLASS = "dx-scheduler";
var WIDGET_SMALL_CLASS = "".concat(WIDGET_CLASS, "-small");
var WIDGET_ADAPTIVE_CLASS = "".concat(WIDGET_CLASS, "-adaptive");
var WIDGET_WIN_NO_TOUCH_CLASS = "".concat(WIDGET_CLASS, "-win-no-touch");
var WIDGET_READONLY_CLASS = "".concat(WIDGET_CLASS, "-readonly");
var WIDGET_SMALL_WIDTH = 400;
var FULL_DATE_FORMAT = "yyyyMMddTHHmmss";
var UTC_FULL_DATE_FORMAT = FULL_DATE_FORMAT + "Z";
var VIEWS_CONFIG = {
    day: {
        workSpace: _uiScheduler11.default,
        renderingStrategy: "vertical"
    },
    week: {
        workSpace: _uiScheduler13.default,
        renderingStrategy: "vertical"
    },
    workWeek: {
        workSpace: _uiScheduler14.default,
        renderingStrategy: "vertical"
    },
    month: {
        workSpace: _uiScheduler12.default,
        renderingStrategy: "horizontalMonth"
    },
    timelineDay: {
        workSpace: _uiScheduler7.default,
        renderingStrategy: "horizontal"
    },
    timelineWeek: {
        workSpace: _uiScheduler9.default,
        renderingStrategy: "horizontal"
    },
    timelineWorkWeek: {
        workSpace: _uiScheduler10.default,
        renderingStrategy: "horizontal"
    },
    timelineMonth: {
        workSpace: _uiScheduler8.default,
        renderingStrategy: "horizontalMonthLine"
    },
    agenda: {
        workSpace: _uiScheduler6.default,
        renderingStrategy: "agenda"
    }
};
var Scheduler = function(_Widget) {
    _inherits(Scheduler, _Widget);
    var _super = _createSuper(Scheduler);

    function Scheduler() {
        _classCallCheck(this, Scheduler);
        return _super.apply(this, arguments)
    }
    _createClass(Scheduler, [{
        key: "_getDefaultOptions",
        value: function() {
            return (0, _extend.extend)(_get(_getPrototypeOf(Scheduler.prototype), "_getDefaultOptions", this).call(this), {
                views: ["day", "week"],
                currentView: "day",
                currentDate: _date.default.trimTime(new Date),
                min: void 0,
                max: void 0,
                dateSerializationFormat: void 0,
                firstDayOfWeek: void 0,
                groups: [],
                resources: [],
                dataSource: null,
                customizeDateNavigatorText: void 0,
                appointmentTemplate: "item",
                dropDownAppointmentTemplate: "dropDownAppointment",
                appointmentCollectorTemplate: "appointmentCollector",
                dataCellTemplate: null,
                timeCellTemplate: null,
                resourceCellTemplate: null,
                dateCellTemplate: null,
                startDayHour: 0,
                endDayHour: 24,
                editing: {
                    allowAdding: true,
                    allowDeleting: true,
                    allowDragging: true,
                    allowResizing: true,
                    allowUpdating: true,
                    allowTimeZoneEditing: false,
                    allowEditingTimeZones: false
                },
                showAllDayPanel: true,
                showCurrentTimeIndicator: true,
                shadeUntilCurrentTime: false,
                indicatorUpdateInterval: 3e5,
                indicatorTime: void 0,
                recurrenceEditMode: "dialog",
                cellDuration: 30,
                maxAppointmentsPerCell: "auto",
                selectedCellData: [],
                groupByDate: false,
                onAppointmentRendered: null,
                onAppointmentClick: null,
                onAppointmentDblClick: null,
                onAppointmentContextMenu: null,
                onCellClick: null,
                onCellContextMenu: null,
                onAppointmentAdding: null,
                onAppointmentAdded: null,
                onAppointmentUpdating: null,
                onAppointmentUpdated: null,
                onAppointmentDeleting: null,
                onAppointmentDeleted: null,
                onAppointmentFormOpening: null,
                appointmentTooltipTemplate: "appointmentTooltip",
                appointmentPopupTemplate: "appointmentPopup",
                crossScrollingEnabled: false,
                useDropDownViewSwitcher: false,
                startDateExpr: "startDate",
                endDateExpr: "endDate",
                textExpr: "text",
                descriptionExpr: "description",
                allDayExpr: "allDay",
                recurrenceRuleExpr: "recurrenceRule",
                recurrenceExceptionExpr: "recurrenceException",
                remoteFiltering: false,
                timeZone: "",
                startDateTimeZoneExpr: "startDateTimeZone",
                endDateTimeZoneExpr: "endDateTimeZone",
                noDataText: _message.default.format("dxCollectionWidget-noDataText"),
                adaptivityEnabled: false,
                allowMultipleCellSelection: true,
                scrolling: {
                    mode: "standard"
                },
                renovateRender: false,
                _appointmentTooltipOffset: {
                    x: 0,
                    y: 0
                },
                _appointmentTooltipButtonsPosition: "bottom",
                _appointmentTooltipOpenButtonText: _message.default.format("dxScheduler-openAppointment"),
                _dropDownButtonIcon: "overflow",
                _appointmentCountPerCell: 2,
                _collectorOffset: 0,
                _appointmentOffset: 26
            })
        }
    }, {
        key: "_defaultOptionsRules",
        value: function() {
            return _get(_getPrototypeOf(Scheduler.prototype), "_defaultOptionsRules", this).call(this).concat([{
                device: function() {
                    return "desktop" === _devices.default.real().deviceType && !_devices.default.isSimulator()
                },
                options: {
                    focusStateEnabled: true
                }
            }, {
                device: function() {
                    return !_devices.default.current().generic
                },
                options: {
                    useDropDownViewSwitcher: true,
                    editing: {
                        allowDragging: false,
                        allowResizing: false
                    }
                }
            }, {
                device: function() {
                    return (0, _themes.isMaterial)()
                },
                options: {
                    useDropDownViewSwitcher: true,
                    dateCellTemplate: function(data, index, element) {
                        var text = data.text;
                        text.split(" ").forEach(function(text, index) {
                            var span = (0, _renderer.default)("<span>").text(text).addClass("dx-scheduler-header-panel-cell-date");
                            (0, _renderer.default)(element).append(span);
                            if (!index) {
                                (0, _renderer.default)(element).append(" ")
                            }
                        })
                    },
                    _appointmentTooltipOffset: {
                        x: 0,
                        y: 11
                    },
                    _appointmentTooltipButtonsPosition: "top",
                    _appointmentTooltipOpenButtonText: null,
                    _dropDownButtonIcon: "chevrondown",
                    _appointmentCountPerCell: 1,
                    _collectorOffset: 20,
                    _appointmentOffset: 30
                }
            }])
        }
    }, {
        key: "_setDeprecatedOptions",
        value: function() {
            _get(_getPrototypeOf(Scheduler.prototype), "_setDeprecatedOptions", this).call(this);
            (0, _extend.extend)(this._deprecatedOptions, {
                dropDownAppointmentTemplate: {
                    since: "19.2",
                    message: "appointmentTooltipTemplate"
                },
                allowEditingTimeZones: {
                    since: "20.1",
                    alias: "allowTimeZoneEditing"
                }
            })
        }
    }, {
        key: "_getAppointmentSettingsGenerator",
        value: function() {
            return new _appointmentSettingsGenerator.AppointmentSettingsGenerator(this)
        }
    }, {
        key: "_postponeDataSourceLoading",
        value: function(promise) {
            this.postponedOperations.add("_reloadDataSource", this._reloadDataSource.bind(this), promise)
        }
    }, {
        key: "_postponeResourceLoading",
        value: function() {
            var _this = this;
            var whenLoaded = this.postponedOperations.add("_loadResources", function() {
                return _this._loadResources()
            });
            var resolveCallbacks = new _deferred.Deferred;
            whenLoaded.done(function(resources) {
                resolveCallbacks.resolve(resources)
            });
            this._postponeDataSourceLoading(whenLoaded);
            return resolveCallbacks.promise()
        }
    }, {
        key: "_optionChanged",
        value: function(args) {
            var _this2 = this;
            var value = args.value;
            var name = args.name;
            switch (args.name) {
                case "customizeDateNavigatorText":
                    this._updateOption("header", name, value);
                    break;
                case "firstDayOfWeek":
                    this._updateOption("workSpace", name, value);
                    this._updateOption("header", name, value);
                    break;
                case "currentDate":
                    value = this._dateOption(name);
                    value = _date.default.trimTime(new Date(value));
                    this.option("selectedCellData", []);
                    this._workSpace.option(name, new Date(value));
                    this._header.option(name, new Date(value));
                    this._header.option("displayedDate", this._workSpace._getViewStartByOptions());
                    this._appointments.option("items", []);
                    this._filterAppointmentsByDate();
                    this._postponeDataSourceLoading();
                    break;
                case "dataSource":
                    this._initDataSource();
                    this._appointmentModel.setDataSource(this._dataSource);
                    this._postponeResourceLoading().done(function(resources) {
                        _this2._filterAppointmentsByDate();
                        _this2._updateOption("workSpace", "showAllDayPanel", _this2.option("showAllDayPanel"))
                    });
                    break;
                case "min":
                case "max":
                    value = this._dateOption(name);
                    this._updateOption("header", name, new Date(value));
                    this._updateOption("workSpace", name, new Date(value));
                    break;
                case "views":
                    this._processCurrentView();
                    if (this._getCurrentViewOptions()) {
                        this.repaint()
                    } else {
                        this._header.option(name, value)
                    }
                    break;
                case "useDropDownViewSwitcher":
                    this._header.option(name, value);
                    break;
                case "currentView":
                    this._processCurrentView();
                    this.fire("validateDayHours");
                    this.getLayoutManager().initRenderingStrategy(this._getAppointmentsRenderingStrategy());
                    this._validateCellDuration();
                    this._appointments.option({
                        items: [],
                        allowDrag: this._allowDragging(),
                        allowResize: this._allowResizing(),
                        itemTemplate: this._getAppointmentTemplate("appointmentTemplate")
                    });
                    this._postponeResourceLoading().done(function(resources) {
                        _this2._refreshWorkSpace(resources);
                        _this2._updateHeader();
                        _this2._filterAppointmentsByDate();
                        _this2._appointments.option("allowAllDayResize", "day" !== value)
                    });
                    break;
                case "appointmentTemplate":
                    this._appointments.option("itemTemplate", value);
                    break;
                case "dateCellTemplate":
                case "resourceCellTemplate":
                case "dataCellTemplate":
                case "timeCellTemplate":
                    this._updateOption("workSpace", name, value);
                    this.repaint();
                    break;
                case "groups":
                    this._postponeResourceLoading().done(function(resources) {
                        _this2._refreshWorkSpace(resources);
                        _this2._filterAppointmentsByDate()
                    });
                    break;
                case "resources":
                    this._resourcesManager.setResources(this.option("resources"));
                    this._appointmentModel.setDataAccessors(this._combineDataAccessors());
                    this._postponeResourceLoading().done(function(resources) {
                        _this2._appointments.option("items", []);
                        _this2._refreshWorkSpace(resources);
                        _this2._filterAppointmentsByDate()
                    });
                    break;
                case "startDayHour":
                case "endDayHour":
                    this.fire("validateDayHours");
                    this._appointments.option("items", []);
                    this._updateOption("workSpace", name, value);
                    this._appointments.repaint();
                    this._filterAppointmentsByDate();
                    this._postponeDataSourceLoading();
                    break;
                case "onAppointmentAdding":
                case "onAppointmentAdded":
                case "onAppointmentUpdating":
                case "onAppointmentUpdated":
                case "onAppointmentDeleting":
                case "onAppointmentDeleted":
                case "onAppointmentFormOpening":
                    this._actions[name] = this._createActionByOption(name);
                    break;
                case "onAppointmentRendered":
                    this._appointments.option("onItemRendered", this._getAppointmentRenderedAction());
                    break;
                case "onAppointmentClick":
                    this._appointments.option("onItemClick", this._createActionByOption(name));
                    break;
                case "onAppointmentDblClick":
                    this._appointments.option(name, this._createActionByOption(name));
                    break;
                case "onAppointmentContextMenu":
                    this._appointments.option("onItemContextMenu", this._createActionByOption(name));
                    break;
                case "noDataText":
                case "allowMultipleCellSelection":
                case "selectedCellData":
                case "accessKey":
                case "onCellClick":
                    this._workSpace.option(name, value);
                    break;
                case "onCellContextMenu":
                    this._workSpace.option(name, value);
                    break;
                case "crossScrollingEnabled":
                    this._postponeResourceLoading().done(function(resources) {
                        _this2._appointments.option("items", []);
                        _this2._refreshWorkSpace(resources);
                        if (_this2._readyToRenderAppointments) {
                            _this2._appointments.option("items", _this2._getAppointmentsToRepaint())
                        }
                    });
                    break;
                case "cellDuration":
                    this._validateCellDuration();
                    this._appointments.option("items", []);
                    if (this._readyToRenderAppointments) {
                        this._updateOption("workSpace", "hoursInterval", value / 60);
                        this._appointments.option("items", this._getAppointmentsToRepaint())
                    }
                    break;
                case "tabIndex":
                case "focusStateEnabled":
                    this._updateOption("header", name, value);
                    this._updateOption("workSpace", name, value);
                    this._appointments.option(name, value);
                    _get(_getPrototypeOf(Scheduler.prototype), "_optionChanged", this).call(this, args);
                    break;
                case "width":
                    this._updateOption("header", name, value);
                    if (this.option("crossScrollingEnabled")) {
                        this._updateOption("workSpace", "width", value)
                    }
                    _get(_getPrototypeOf(Scheduler.prototype), "_optionChanged", this).call(this, args);
                    this._dimensionChanged();
                    break;
                case "height":
                    _get(_getPrototypeOf(Scheduler.prototype), "_optionChanged", this).call(this, args);
                    this._dimensionChanged();
                    break;
                case "editing":
                    this._initEditing();
                    var editing = this._editing;
                    this._bringEditingModeToAppointments(editing);
                    this.hideAppointmentTooltip();
                    this._cleanPopup();
                    break;
                case "showAllDayPanel":
                    this._postponeResourceLoading().done(function(resources) {
                        _this2._filterAppointmentsByDate();
                        _this2._updateOption("workSpace", "allDayExpanded", value);
                        _this2._updateOption("workSpace", name, value)
                    });
                    break;
                case "showCurrentTimeIndicator":
                case "indicatorTime":
                case "indicatorUpdateInterval":
                case "shadeUntilCurrentTime":
                case "groupByDate":
                    this._updateOption("workSpace", name, value);
                    this.repaint();
                    break;
                case "appointmentDragging":
                case "appointmentTooltipTemplate":
                case "appointmentPopupTemplate":
                case "recurrenceEditMode":
                case "remoteFiltering":
                case "timeZone":
                case "dropDownAppointmentTemplate":
                case "appointmentCollectorTemplate":
                case "_appointmentTooltipOffset":
                case "_appointmentTooltipButtonsPosition":
                case "_appointmentTooltipOpenButtonText":
                case "_dropDownButtonIcon":
                case "_appointmentCountPerCell":
                case "_collectorOffset":
                case "_appointmentOffset":
                    this.repaint();
                    break;
                case "dateSerializationFormat":
                    break;
                case "maxAppointmentsPerCell":
                    break;
                case "startDateExpr":
                case "endDateExpr":
                case "startDateTimeZoneExpr":
                case "endDateTimeZoneExpr":
                case "textExpr":
                case "descriptionExpr":
                case "allDayExpr":
                case "recurrenceRuleExpr":
                case "recurrenceExceptionExpr":
                    this._updateExpression(name, value);
                    this._appointmentModel.setDataAccessors(this._combineDataAccessors());
                    this._initAppointmentTemplate();
                    this.repaint();
                    break;
                case "adaptivityEnabled":
                    this._toggleAdaptiveClass();
                    this.repaint();
                    break;
                case "scrolling":
                    this._updateOption("workSpace", args.fullName, value);
                    break;
                case "renovateRender":
                    this._updateOption("workSpace", name, value);
                    break;
                default:
                    _get(_getPrototypeOf(Scheduler.prototype), "_optionChanged", this).call(this, args)
            }
        }
    }, {
        key: "_updateHeader",
        value: function() {
            var viewCountConfig = this._getViewCountConfig();
            this._header.option("intervalCount", viewCountConfig.intervalCount);
            this._header.option("displayedDate", this._workSpace._getViewStartByOptions());
            this._header.option("min", this._dateOption("min"));
            this._header.option("max", this._dateOption("max"));
            this._header.option("currentDate", this._dateOption("currentDate"));
            this._header.option("firstDayOfWeek", this._getCurrentViewOption("firstDayOfWeek"));
            this._header.option("currentView", this._currentView)
        }
    }, {
        key: "_dateOption",
        value: function(optionName) {
            var optionValue = this._getCurrentViewOption(optionName);
            return _date_serialization.default.deserializeDate(optionValue)
        }
    }, {
        key: "_getSerializationFormat",
        value: function(optionName) {
            var value = this._getCurrentViewOption(optionName);
            if ("number" === typeof value) {
                return "number"
            }
            if (!(0, _type.isString)(value)) {
                return
            }
            return _date_serialization.default.getDateSerializationFormat(value)
        }
    }, {
        key: "_bringEditingModeToAppointments",
        value: function(editing) {
            var editingConfig = {
                allowDelete: editing.allowUpdating && editing.allowDeleting
            };
            if (!this._isAgenda()) {
                editingConfig.allowDrag = editing.allowDragging;
                editingConfig.allowResize = editing.allowResizing;
                editingConfig.allowAllDayResize = editing.allowResizing && this._supportAllDayResizing()
            }
            this._appointments.option(editingConfig);
            this.repaint()
        }
    }, {
        key: "_isAgenda",
        value: function() {
            return "agenda" === this._getAppointmentsRenderingStrategy()
        }
    }, {
        key: "_allowDragging",
        value: function() {
            return this._editing.allowDragging && !this._isAgenda()
        }
    }, {
        key: "_allowResizing",
        value: function() {
            return this._editing.allowResizing && !this._isAgenda()
        }
    }, {
        key: "_allowAllDayResizing",
        value: function() {
            return this._editing.allowResizing && this._supportAllDayResizing()
        }
    }, {
        key: "_supportAllDayResizing",
        value: function() {
            return "day" !== this._getCurrentViewType() || this._currentView.intervalCount > 1
        }
    }, {
        key: "_isAllDayExpanded",
        value: function(items) {
            return this.option("showAllDayPanel") && this._appointmentModel.hasAllDayAppointments(items, this._getCurrentViewOption("startDayHour"), this._getCurrentViewOption("endDayHour"))
        }
    }, {
        key: "_getTimezoneOffsetByOption",
        value: function(date) {
            return _utils.default.calculateTimezoneByValue(this.option("timeZone"), date)
        }
    }, {
        key: "_filterAppointmentsByDate",
        value: function() {
            var dateRange = this._workSpace.getDateRange();
            this._appointmentModel.filterByDate(dateRange[0], dateRange[1], this.option("remoteFiltering"), this.option("dateSerializationFormat"))
        }
    }, {
        key: "_loadResources",
        value: function() {
            var groups = this._getCurrentViewOption("groups");
            var result = new _deferred.Deferred;
            this._resourcesManager.loadResources(groups).done(function(resources) {
                this._loadedResources = resources;
                result.resolve(resources)
            }.bind(this));
            return result.promise()
        }
    }, {
        key: "_reloadDataSource",
        value: function() {
            var result = new _deferred.Deferred;
            if (this._dataSource) {
                this._dataSource.load().done(function() {
                    (0, _ui3.hide)();
                    this._fireContentReadyAction(result)
                }.bind(this)).fail(function() {
                    (0, _ui3.hide)();
                    result.reject()
                });
                this._dataSource.isLoading() && (0, _ui3.show)({
                    container: this.$element(),
                    position: {
                        of: this.$element()
                    }
                })
            } else {
                this._fireContentReadyAction(result)
            }
            return result.promise()
        }
    }, {
        key: "_fireContentReadyAction",
        value: function(result) {
            var contentReadyBase = _get(_getPrototypeOf(Scheduler.prototype), "_fireContentReadyAction", this).bind(this);
            var fireContentReady = function() {
                contentReadyBase();
                null === result || void 0 === result ? void 0 : result.resolve()
            };
            if (this._workSpaceRecalculation) {
                var _this$_workSpaceRecal;
                null === (_this$_workSpaceRecal = this._workSpaceRecalculation) || void 0 === _this$_workSpaceRecal ? void 0 : _this$_workSpaceRecal.done(function() {
                    fireContentReady()
                })
            } else {
                fireContentReady()
            }
        }
    }, {
        key: "_dimensionChanged",
        value: function() {
            var filteredItems = this.getFilteredItems();
            this._toggleSmallClass();
            if (!this._isAgenda() && filteredItems && this._isVisible()) {
                this._workSpace._cleanAllowedPositions();
                this._workSpace.option("allDayExpanded", this._isAllDayExpanded(filteredItems));
                this._workSpace._dimensionChanged();
                var appointments = this._layoutManager.createAppointmentsMap(filteredItems);
                this._appointments.option("items", appointments)
            }
            this.hideAppointmentTooltip();
            this._appointmentPopup.triggerResize();
            this._appointmentPopup.updatePopupFullScreenMode()
        }
    }, {
        key: "_clean",
        value: function() {
            this._cleanPopup();
            _get(_getPrototypeOf(Scheduler.prototype), "_clean", this).call(this)
        }
    }, {
        key: "_toggleSmallClass",
        value: function() {
            var width = (0, _position.getBoundingRect)(this.$element().get(0)).width;
            this.$element().toggleClass(WIDGET_SMALL_CLASS, width < WIDGET_SMALL_WIDTH)
        }
    }, {
        key: "_toggleAdaptiveClass",
        value: function() {
            this.$element().toggleClass(WIDGET_ADAPTIVE_CLASS, this.option("adaptivityEnabled"))
        }
    }, {
        key: "_visibilityChanged",
        value: function(visible) {
            visible && this._dimensionChanged()
        }
    }, {
        key: "_dataSourceOptions",
        value: function() {
            return {
                paginate: false
            }
        }
    }, {
        key: "_init",
        value: function() {
            var _this3 = this;
            this._initExpressions({
                startDate: this.option("startDateExpr"),
                endDate: this.option("endDateExpr"),
                startDateTimeZone: this.option("startDateTimeZoneExpr"),
                endDateTimeZone: this.option("endDateTimeZoneExpr"),
                allDay: this.option("allDayExpr"),
                text: this.option("textExpr"),
                description: this.option("descriptionExpr"),
                recurrenceRule: this.option("recurrenceRuleExpr"),
                recurrenceException: this.option("recurrenceExceptionExpr")
            });
            _get(_getPrototypeOf(Scheduler.prototype), "_init", this).call(this);
            this._initDataSource();
            this._loadedResources = [];
            this.$element().addClass(WIDGET_CLASS).toggleClass(WIDGET_WIN_NO_TOUCH_CLASS, !!(_browser.default.msie && _support.touch));
            this._initEditing();
            this._resourcesManager = new _uiScheduler4.default(this.option("resources"));
            var combinedDataAccessors = this._combineDataAccessors();
            this._appointmentModel = new _uiScheduler2.default(this._dataSource, combinedDataAccessors, this.getAppointmentDurationInMinutes());
            this._initActions();
            this._compactAppointmentsHelper = new _compactAppointmentsHelper.CompactAppointmentsHelper(this);
            this._asyncTemplatesTimers = [];
            this._dataSourceLoadedCallback = (0, _callbacks.default)();
            this._subscribes = _uiScheduler5.default;
            this.timeZoneCalculator = new _timeZoneCalculator.TimeZoneCalculator({
                getClientOffset: function(date) {
                    return _this3.fire("getClientTimezoneOffset", date)
                },
                getCommonOffset: function(date) {
                    return _this3._getTimezoneOffsetByOption(date)
                },
                getAppointmentOffset: function(date, appointmentTimezone) {
                    return _utils.default.calculateTimezoneByValue(appointmentTimezone, date)
                }
            })
        }
    }, {
        key: "_initTemplates",
        value: function() {
            this._initAppointmentTemplate();
            this._templateManager.addDefaultTemplates({
                appointmentTooltip: new _empty_template.EmptyTemplate,
                dropDownAppointment: new _empty_template.EmptyTemplate
            });
            _get(_getPrototypeOf(Scheduler.prototype), "_initTemplates", this).call(this)
        }
    }, {
        key: "_initAppointmentTemplate",
        value: function() {
            var _this4 = this;
            var expr = this._dataAccessors.expr;
            var createGetter = function(property) {
                return (0, _data.compileGetter)("appointmentData.".concat(property))
            };
            this._templateManager.addDefaultTemplates(_defineProperty({}, "item", new _bindable_template.BindableTemplate(function($container, data, model) {
                _this4.getAppointmentsInstance()._renderAppointmentTemplate($container, data, model)
            }, ["html", "text", "startDate", "endDate", "allDay", "description", "recurrenceRule", "recurrenceException", "startDateTimeZone", "endDateTimeZone"], this.option("integrationOptions.watchMethod"), {
                text: createGetter(expr.textExpr),
                startDate: createGetter(expr.startDateExpr),
                endDate: createGetter(expr.endDateExpr),
                startDateTimeZone: createGetter(expr.startDateTimeZoneExpr),
                endDateTimeZone: createGetter(expr.endDateTimeZoneExpr),
                allDay: createGetter(expr.allDayExpr),
                recurrenceRule: createGetter(expr.recurrenceRuleExpr)
            })))
        }
    }, {
        key: "_combineDataAccessors",
        value: function() {
            var resourcesDataAccessors = this._resourcesManager._dataAccessors;
            var result = (0, _extend.extend)(true, {}, this._dataAccessors);
            (0, _iterator.each)(resourcesDataAccessors, function(type, accessor) {
                result[type].resources = accessor
            }.bind(this));
            return result
        }
    }, {
        key: "_renderContent",
        value: function() {
            this._renderContentImpl()
        }
    }, {
        key: "_dataSourceChangedHandler",
        value: function(result) {
            if (this._readyToRenderAppointments) {
                this._workSpaceRecalculation.done(function() {
                    this._renderAppointments();
                    if (this._isAgenda()) {
                        this._workSpace._renderView();
                        this._dataSourceLoadedCallback.fireWith(this, [result])
                    }
                }.bind(this))
            }
        }
    }, {
        key: "isVirtualScrolling",
        value: function() {
            var _this$getWorkSpace;
            return null === (_this$getWorkSpace = this.getWorkSpace()) || void 0 === _this$getWorkSpace ? void 0 : _this$getWorkSpace.isVirtualScrolling()
        }
    }, {
        key: "_filterAppointments",
        value: function() {
            var prerenderFilterName = this.isVirtualScrolling() ? "prerenderFilterVirtual" : "prerenderFilter";
            return this.fire(prerenderFilterName)
        }
    }, {
        key: "_renderAppointments",
        value: function() {
            this._filteredItems = this._filterAppointments();
            this._workSpace.option("allDayExpanded", this._isAllDayExpanded(this._filteredItems));
            if (this._isAgenda()) {
                this.getRenderingStrategyInstance().calculateRows(this._filteredItems, 7, this.option("currentDate"), true)
            }
            if (this._filteredItems.length && this._isVisible()) {
                this._appointments.option("items", this._getAppointmentsToRepaint());
                this._appointmentModel.cleanModelState()
            } else {
                this._appointments.option("items", [])
            }
        }
    }, {
        key: "_getAppointmentsToRepaint",
        value: function() {
            var appointments = this._layoutManager.createAppointmentsMap(this._filteredItems);
            return this._layoutManager.getRepaintedAppointments(appointments, this.getAppointmentsInstance().option("items"))
        }
    }, {
        key: "_initExpressions",
        value: function(fields) {
            var isDateField = function(field) {
                return "startDate" === field || "endDate" === field
            };
            if (!this._dataAccessors) {
                this._dataAccessors = {
                    getter: {},
                    setter: {},
                    expr: {}
                }
            }(0, _iterator.each)(fields, function(name, expr) {
                if (expr) {
                    var getter = (0, _data.compileGetter)(expr);
                    var setter = (0, _data.compileSetter)(expr);
                    var dateGetter;
                    var dateSetter;
                    if (isDateField(name)) {
                        var that = this;
                        dateGetter = function() {
                            var value = getter.apply(this, arguments);
                            if ((0, _config.default)().forceIsoDateParsing) {
                                if (!that.option("dateSerializationFormat")) {
                                    var format = _date_serialization.default.getDateSerializationFormat(value);
                                    if (format) {
                                        that.option("dateSerializationFormat", format)
                                    }
                                }
                                value = _date_serialization.default.deserializeDate(value)
                            }
                            return value
                        };
                        dateSetter = function(object, value) {
                            if ((0, _config.default)().forceIsoDateParsing || that.option("dateSerializationFormat")) {
                                value = _date_serialization.default.serializeDate(value, that.option("dateSerializationFormat"))
                            }
                            setter.call(this, object, value)
                        }
                    }
                    this._dataAccessors.getter[name] = dateGetter || getter;
                    this._dataAccessors.setter[name] = dateSetter || setter;
                    this._dataAccessors.expr[name + "Expr"] = expr
                } else {
                    delete this._dataAccessors.getter[name];
                    delete this._dataAccessors.setter[name];
                    delete this._dataAccessors.expr[name + "Expr"]
                }
            }.bind(this))
        }
    }, {
        key: "_updateExpression",
        value: function(name, value) {
            var exprObj = {};
            exprObj[name.replace("Expr", "")] = value;
            this._initExpressions(exprObj)
        }
    }, {
        key: "_initEditing",
        value: function() {
            var editing = this.option("editing");
            this._editing = {
                allowAdding: !!editing,
                allowUpdating: !!editing,
                allowDeleting: !!editing,
                allowResizing: !!editing,
                allowDragging: !!editing
            };
            if ((0, _type.isObject)(editing)) {
                this._editing = (0, _extend.extend)(this._editing, editing)
            }
            this._editing.allowDragging = this._editing.allowDragging && this._editing.allowUpdating;
            this._editing.allowResizing = this._editing.allowResizing && this._editing.allowUpdating;
            this.$element().toggleClass(WIDGET_READONLY_CLASS, this._isReadOnly())
        }
    }, {
        key: "_isReadOnly",
        value: function() {
            var result = true;
            var editing = this._editing;
            for (var prop in editing) {
                if (Object.prototype.hasOwnProperty.call(editing, prop)) {
                    result = result && !editing[prop]
                }
            }
            return result
        }
    }, {
        key: "_dispose",
        value: function() {
            this._appointmentTooltip && this._appointmentTooltip.dispose();
            this.hideAppointmentPopup();
            this.hideAppointmentTooltip();
            this._asyncTemplatesTimers.forEach(clearTimeout);
            this._asyncTemplatesTimers = [];
            _get(_getPrototypeOf(Scheduler.prototype), "_dispose", this).call(this)
        }
    }, {
        key: "_initActions",
        value: function() {
            this._actions = {
                onAppointmentAdding: this._createActionByOption("onAppointmentAdding"),
                onAppointmentAdded: this._createActionByOption("onAppointmentAdded"),
                onAppointmentUpdating: this._createActionByOption("onAppointmentUpdating"),
                onAppointmentUpdated: this._createActionByOption("onAppointmentUpdated"),
                onAppointmentDeleting: this._createActionByOption("onAppointmentDeleting"),
                onAppointmentDeleted: this._createActionByOption("onAppointmentDeleted"),
                onAppointmentFormOpening: this._createActionByOption("onAppointmentFormOpening")
            }
        }
    }, {
        key: "_getAppointmentRenderedAction",
        value: function() {
            return this._createActionByOption("onAppointmentRendered", {
                excludeValidators: ["disabled", "readOnly"]
            })
        }
    }, {
        key: "_renderFocusTarget",
        value: function() {
            return (0, _common.noop)()
        }
    }, {
        key: "_initMarkup",
        value: function() {
            _get(_getPrototypeOf(Scheduler.prototype), "_initMarkup", this).call(this);
            this.fire("validateDayHours");
            this._validateCellDuration();
            this._processCurrentView();
            this._renderHeader();
            this._layoutManager = new _uiSchedulerAppointments.default(this, this._getAppointmentsRenderingStrategy());
            this._appointments = this._createComponent("<div>", _uiScheduler.default, this._appointmentsConfig());
            this._appointments.option("itemTemplate", this._getAppointmentTemplate("appointmentTemplate"));
            this._appointmentTooltip = new(this.option("adaptivityEnabled") ? _mobileTooltipStrategy.MobileTooltipStrategy : _desktopTooltipStrategy.DesktopTooltipStrategy)(this._getAppointmentTooltipOptions());
            this._appointmentPopup = new _appointmentPopup.default(this);
            if (this._isLoaded() || this._isDataSourceLoading()) {
                this._initMarkupCore(this._loadedResources);
                this._dataSourceChangedHandler(this._dataSource.items());
                this._fireContentReadyAction()
            } else {
                this._loadResources().done(function(resources) {
                    this._initMarkupCore(resources);
                    this._reloadDataSource()
                }.bind(this))
            }
        }
    }, {
        key: "_getAppointmentTooltipOptions",
        value: function() {
            var _this5 = this;
            var that = this;
            return {
                createComponent: that._createComponent.bind(that),
                container: that.$element(),
                getScrollableContainer: that.getWorkSpaceScrollableContainer.bind(that),
                addDefaultTemplates: that._templateManager.addDefaultTemplates.bind(that._templateManager),
                getAppointmentTemplate: that._getAppointmentTemplate.bind(that),
                showAppointmentPopup: that.showAppointmentPopup.bind(that),
                checkAndDeleteAppointment: that.checkAndDeleteAppointment.bind(that),
                isAppointmentInAllDayPanel: that.isAppointmentInAllDayPanel.bind(that),
                createFormattedDateText: function(appointment, targetedAppointment, format) {
                    return _this5.fire("getTextAndFormatDate", appointment, targetedAppointment, format)
                }
            }
        }
    }, {
        key: "checkAndDeleteAppointment",
        value: function(appointment, targetedAppointment) {
            var targetedAdapter = this.createAppointmentAdapter(targetedAppointment);
            var that = this;
            this._checkRecurringAppointment(appointment, targetedAppointment, targetedAdapter.startDate, function() {
                that.deleteAppointment(appointment)
            }, true)
        }
    }, {
        key: "_getExtraAppointmentTooltipOptions",
        value: function() {
            return {
                rtlEnabled: this.option("rtlEnabled"),
                focusStateEnabled: this.option("focusStateEnabled"),
                editing: this.option("editing"),
                offset: this.option("_appointmentTooltipOffset")
            }
        }
    }, {
        key: "isAppointmentInAllDayPanel",
        value: function(appointmentData) {
            var workSpace = this._workSpace;
            var itTakesAllDay = this.appointmentTakesAllDay(appointmentData);
            return itTakesAllDay && workSpace.supportAllDayRow() && workSpace.option("showAllDayPanel")
        }
    }, {
        key: "_initMarkupCore",
        value: function(resources) {
            var _this6 = this;
            this._readyToRenderAppointments = (0, _window.hasWindow)();
            this._workSpace && this._cleanWorkspace();
            this._renderWorkSpace(resources);
            this._appointments.option({
                fixedContainer: this._workSpace.getFixedContainer(),
                allDayContainer: this._workSpace.getAllDayContainer()
            });
            this._waitAsyncTemplate(function() {
                var _this6$_workSpaceReca;
                return null === (_this6$_workSpaceReca = _this6._workSpaceRecalculation) || void 0 === _this6$_workSpaceReca ? void 0 : _this6$_workSpaceReca.resolve()
            });
            this._filterAppointmentsByDate()
        }
    }, {
        key: "_isLoaded",
        value: function() {
            return this._isResourcesLoaded() && this._isDataSourceLoaded()
        }
    }, {
        key: "_isResourcesLoaded",
        value: function() {
            return (0, _type.isDefined)(this._loadedResources)
        }
    }, {
        key: "_isDataSourceLoaded",
        value: function() {
            return this._dataSource && this._dataSource.isLoaded()
        }
    }, {
        key: "_render",
        value: function() {
            this._toggleSmallClass();
            this._toggleAdaptiveClass();
            _get(_getPrototypeOf(Scheduler.prototype), "_render", this).call(this)
        }
    }, {
        key: "_renderHeader",
        value: function() {
            var $header = (0, _renderer.default)("<div>").appendTo(this.$element());
            this._header = this._createComponent($header, _uiScheduler3.default, this._headerConfig())
        }
    }, {
        key: "_headerConfig",
        value: function() {
            var currentViewOptions = this._getCurrentViewOptions();
            var countConfig = this._getViewCountConfig();
            var result = (0, _extend.extend)({
                isAdaptive: this.option("adaptivityEnabled"),
                firstDayOfWeek: this.option("firstDayOfWeek"),
                currentView: this._currentView,
                tabIndex: this.option("tabIndex"),
                focusStateEnabled: this.option("focusStateEnabled"),
                width: this.option("width"),
                rtlEnabled: this.option("rtlEnabled"),
                useDropDownViewSwitcher: this.option("useDropDownViewSwitcher"),
                _dropDownButtonIcon: this.option("_dropDownButtonIcon"),
                customizeDateNavigatorText: this.option("customizeDateNavigatorText")
            }, currentViewOptions);
            result.observer = this;
            result.intervalCount = countConfig.intervalCount;
            result.views = this.option("views");
            result.min = new Date(this._dateOption("min"));
            result.max = new Date(this._dateOption("max"));
            result.currentDate = _date.default.trimTime(new Date(this._dateOption("currentDate")));
            return result
        }
    }, {
        key: "_appointmentsConfig",
        value: function() {
            var that = this;
            var config = {
                observer: this,
                onItemRendered: this._getAppointmentRenderedAction(),
                onItemClick: this._createActionByOption("onAppointmentClick"),
                onItemContextMenu: this._createActionByOption("onAppointmentContextMenu"),
                onAppointmentDblClick: this._createActionByOption("onAppointmentDblClick"),
                tabIndex: this.option("tabIndex"),
                focusStateEnabled: this.option("focusStateEnabled"),
                allowDrag: this._allowDragging(),
                allowDelete: this._editing.allowUpdating && this._editing.allowDeleting,
                allowResize: this._allowResizing(),
                allowAllDayResize: this._allowAllDayResizing(),
                rtlEnabled: this.option("rtlEnabled"),
                currentView: this.option("currentView"),
                onContentReady: function() {
                    that._workSpace && that._workSpace.option("allDayExpanded", that._isAllDayExpanded(that.getFilteredItems()))
                }
            };
            return config
        }
    }, {
        key: "getCollectorOffset",
        value: function() {
            if (this._workSpace.needApplyCollectorOffset() && !this.option("adaptivityEnabled")) {
                return this.option("_collectorOffset")
            } else {
                return 0
            }
        }
    }, {
        key: "getAppointmentDurationInMinutes",
        value: function() {
            return this._getCurrentViewOption("cellDuration")
        }
    }, {
        key: "_processCurrentView",
        value: function() {
            var views = this.option("views");
            var currentView = this.option("currentView");
            var that = this;
            this._currentView = currentView;
            (0, _iterator.each)(views, function(_, view) {
                var isViewIsObject = (0, _type.isObject)(view);
                var viewName = isViewIsObject ? view.name : view;
                var viewType = view.type;
                if (currentView === viewName || currentView === viewType) {
                    that._currentView = view;
                    return false
                }
            })
        }
    }, {
        key: "_validateCellDuration",
        value: function() {
            var endDayHour = this._getCurrentViewOption("endDayHour");
            var startDayHour = this._getCurrentViewOption("startDayHour");
            var cellDuration = this._getCurrentViewOption("cellDuration");
            if ((endDayHour - startDayHour) * MINUTES_IN_HOUR % cellDuration !== 0) {
                _ui.default.log("W1015")
            }
        }
    }, {
        key: "_getCurrentViewType",
        value: function() {
            return this._currentView.type || this._currentView
        }
    }, {
        key: "_getAppointmentsRenderingStrategy",
        value: function() {
            return VIEWS_CONFIG[this._getCurrentViewType()].renderingStrategy
        }
    }, {
        key: "_renderWorkSpace",
        value: function(groups) {
            this._readyToRenderAppointments && this._toggleSmallClass();
            var $workSpace = (0, _renderer.default)("<div>").appendTo(this.$element());
            var countConfig = this._getViewCountConfig();
            var workSpaceComponent = VIEWS_CONFIG[this._getCurrentViewType()].workSpace;
            var workSpaceConfig = this._workSpaceConfig(groups, countConfig);
            this._workSpace = this._createComponent($workSpace, workSpaceComponent, workSpaceConfig);
            this._allowDragging() && this._workSpace.initDragBehavior(this, this._all);
            this._workSpace._attachTablesEvents();
            this._workSpace.getWorkArea().append(this._appointments.$element());
            this._recalculateWorkspace();
            countConfig.startDate && this._header && this._header.option("currentDate", this._workSpace._getHeaderDate());
            this._appointments.option("_collectorOffset", this.getCollectorOffset())
        }
    }, {
        key: "_getViewCountConfig",
        value: function() {
            var currentView = this.option("currentView");
            var view = this._getViewByName(currentView);
            var viewCount = view && view.intervalCount || 1;
            var startDate = view && view.startDate || null;
            return {
                intervalCount: viewCount,
                startDate: startDate
            }
        }
    }, {
        key: "_getViewByName",
        value: function(name) {
            var views = this.option("views");
            for (var i = 0; i < views.length; i++) {
                if (views[i].name === name || views[i].type === name || views[i] === name) {
                    return views[i]
                }
            }
        }
    }, {
        key: "_recalculateWorkspace",
        value: function() {
            var _this7 = this;
            this._workSpaceRecalculation = new _deferred.Deferred;
            this._waitAsyncTemplate(function() {
                (0, _visibility_change.triggerResizeEvent)(_this7._workSpace.$element());
                _this7._workSpace._refreshDateTimeIndication()
            })
        }
    }, {
        key: "_workSpaceConfig",
        value: function(groups, countConfig) {
            var _currentViewOptions$s, _this8 = this;
            var currentViewOptions = this._getCurrentViewOptions();
            var scrolling = this.option("scrolling");
            var result = (0, _extend.extend)({
                noDataText: this.option("noDataText"),
                firstDayOfWeek: this.option("firstDayOfWeek"),
                startDayHour: this.option("startDayHour"),
                endDayHour: this.option("endDayHour"),
                tabIndex: this.option("tabIndex"),
                accessKey: this.option("accessKey"),
                focusStateEnabled: this.option("focusStateEnabled"),
                cellDuration: this.option("cellDuration"),
                showAllDayPanel: this.option("showAllDayPanel"),
                showCurrentTimeIndicator: this.option("showCurrentTimeIndicator"),
                indicatorTime: this.option("indicatorTime"),
                indicatorUpdateInterval: this.option("indicatorUpdateInterval"),
                shadeUntilCurrentTime: this.option("shadeUntilCurrentTime"),
                allDayExpanded: this._appointments.option("items"),
                crossScrollingEnabled: this.option("crossScrollingEnabled"),
                dataCellTemplate: this.option("dataCellTemplate"),
                timeCellTemplate: this.option("timeCellTemplate"),
                resourceCellTemplate: this.option("resourceCellTemplate"),
                dateCellTemplate: this.option("dateCellTemplate"),
                allowMultipleCellSelection: this.option("allowMultipleCellSelection"),
                selectedCellData: this.option("selectedCellData"),
                onSelectionChanged: function(args) {
                    _this8.option("selectedCellData", args.selectedCellData)
                },
                groupByDate: this._getCurrentViewOption("groupByDate"),
                scrolling: scrolling,
                renovateRender: this.option("renovateRender") || "virtual" === scrolling.mode || "virtual" === (null === (_currentViewOptions$s = currentViewOptions.scrolling) || void 0 === _currentViewOptions$s ? void 0 : _currentViewOptions$s.mode)
            }, currentViewOptions);
            result.observer = this;
            result.intervalCount = countConfig.intervalCount;
            result.startDate = countConfig.startDate;
            result.groups = groups;
            result.onCellClick = this._createActionByOption("onCellClick");
            result.onCellContextMenu = this._createActionByOption("onCellContextMenu");
            result.min = new Date(this._dateOption("min"));
            result.max = new Date(this._dateOption("max"));
            result.currentDate = _date.default.trimTime(new Date(this._dateOption("currentDate")));
            result.hoursInterval = result.cellDuration / 60;
            result.allDayExpanded = this._isAllDayExpanded(this.getFilteredItems());
            result.dataCellTemplate = result.dataCellTemplate ? this._getTemplate(result.dataCellTemplate) : null;
            result.timeCellTemplate = result.timeCellTemplate ? this._getTemplate(result.timeCellTemplate) : null;
            result.resourceCellTemplate = result.resourceCellTemplate ? this._getTemplate(result.resourceCellTemplate) : null;
            result.dateCellTemplate = result.dateCellTemplate ? this._getTemplate(result.dateCellTemplate) : null;
            return result
        }
    }, {
        key: "_waitAsyncTemplate",
        value: function(callback) {
            if (this._options.silent("templatesRenderAsynchronously")) {
                var timer = setTimeout(function() {
                    callback();
                    clearTimeout(timer)
                });
                this._asyncTemplatesTimers.push(timer)
            } else {
                callback()
            }
        }
    }, {
        key: "_getCurrentViewOptions",
        value: function() {
            return this._currentView
        }
    }, {
        key: "_getCurrentViewOption",
        value: function(optionName) {
            var currentViewOptions = this._getCurrentViewOptions();
            if (currentViewOptions && void 0 !== currentViewOptions[optionName]) {
                return currentViewOptions[optionName]
            }
            return this.option(optionName)
        }
    }, {
        key: "_getAppointmentTemplate",
        value: function(optionName) {
            var currentViewOptions = this._getCurrentViewOptions();
            if (currentViewOptions && currentViewOptions[optionName]) {
                return this._getTemplate(currentViewOptions[optionName])
            }
            return this._getTemplateByOption(optionName)
        }
    }, {
        key: "_updateOption",
        value: function(viewName, optionName, value) {
            var currentViewOptions = this._getCurrentViewOptions();
            if (!currentViewOptions || !(0, _type.isDefined)(currentViewOptions[optionName])) {
                this["_" + viewName].option(optionName, value)
            }
        }
    }, {
        key: "_refreshWorkSpace",
        value: function(groups) {
            var _this9 = this;
            this._cleanWorkspace();
            delete this._workSpace;
            this._renderWorkSpace(groups);
            if (this._readyToRenderAppointments) {
                this._appointments.option({
                    fixedContainer: this._workSpace.getFixedContainer(),
                    allDayContainer: this._workSpace.getAllDayContainer()
                });
                this._waitAsyncTemplate(function() {
                    return _this9._workSpaceRecalculation.resolve()
                })
            }
        }
    }, {
        key: "_cleanWorkspace",
        value: function() {
            this._appointments.$element().detach();
            this._workSpace._dispose();
            this._workSpace.$element().remove();
            this.option("selectedCellData", [])
        }
    }, {
        key: "getWorkSpaceScrollable",
        value: function() {
            return this._workSpace.getScrollable()
        }
    }, {
        key: "getWorkSpaceScrollableScrollTop",
        value: function(allDay) {
            return this._workSpace.getGroupedScrollableScrollTop(allDay)
        }
    }, {
        key: "getWorkSpaceScrollableScrollLeft",
        value: function() {
            return this._workSpace.getScrollableScrollLeft()
        }
    }, {
        key: "getWorkSpaceScrollableContainer",
        value: function() {
            return this._workSpace.getScrollableContainer()
        }
    }, {
        key: "getWorkSpaceAllDayHeight",
        value: function() {
            return this._workSpace.getAllDayHeight()
        }
    }, {
        key: "getWorkSpaceAllDayOffset",
        value: function() {
            return this._workSpace.getAllDayOffset()
        }
    }, {
        key: "getWorkSpaceHeaderPanelHeight",
        value: function() {
            return this._workSpace.getHeaderPanelHeight()
        }
    }, {
        key: "getWorkSpaceDateTableOffset",
        value: function() {
            return !this.option("crossScrollingEnabled") || this.option("rtlEnabled") ? this._workSpace.getWorkSpaceLeftOffset() : 0
        }
    }, {
        key: "getWorkSpace",
        value: function() {
            return this._workSpace
        }
    }, {
        key: "getAppointmentModel",
        value: function() {
            return this._appointmentModel
        }
    }, {
        key: "getHeader",
        value: function() {
            return this._header
        }
    }, {
        key: "getMaxAppointmentsPerCell",
        value: function() {
            return this._getCurrentViewOption("maxAppointmentsPerCell")
        }
    }, {
        key: "_cleanPopup",
        value: function() {
            this._appointmentPopup && this._appointmentPopup.dispose()
        }
    }, {
        key: "_checkRecurringAppointment",
        value: function(targetAppointment, singleAppointment, exceptionDate, callback, isDeleted, isPopupEditing, dragEvent) {
            delete this._updatedRecAppointment;
            var recurrenceRule = this.fire("getField", "recurrenceRule", targetAppointment);
            if (!(0, _recurrence.getRecurrenceProcessor)().evalRecurrenceRule(recurrenceRule).isValid || !this._editing.allowUpdating) {
                callback();
                return
            }
            var editMode = this.option("recurrenceEditMode");
            switch (editMode) {
                case "series":
                    callback();
                    break;
                case "occurrence":
                    this._singleAppointmentChangesHandler(targetAppointment, singleAppointment, exceptionDate, isDeleted, isPopupEditing, dragEvent);
                    break;
                default:
                    if (dragEvent) {
                        dragEvent.cancel = new _deferred.Deferred
                    }
                    this._showRecurrenceChangeConfirm(isDeleted).done(function(result) {
                        result && callback();
                        !result && this._singleAppointmentChangesHandler(targetAppointment, singleAppointment, exceptionDate, isDeleted, isPopupEditing, dragEvent)
                    }.bind(this)).fail(function() {
                        this._appointments.moveAppointmentBack(dragEvent)
                    }.bind(this))
            }
        }
    }, {
        key: "_getCorrectedExceptionDateByDST",
        value: function(exceptionDate, appointment, targetedAppointment) {
            var offset = appointment.startDate.getTimezoneOffset() - targetedAppointment.startDate.getTimezoneOffset();
            if (0 !== offset) {
                return (0, _dateAdapter.default)(exceptionDate).addTime(offset * _date.default.dateToMilliseconds("minute")).result()
            }
            return exceptionDate
        }
    }, {
        key: "_singleAppointmentChangesHandler",
        value: function(rawAppointment, rawTargetedAppointment, exceptionDate, isDeleted, isPopupEditing, dragEvent) {
            var appointment = this.createAppointmentAdapter(rawAppointment);
            var targetedAppointment = this.createAppointmentAdapter(rawTargetedAppointment);
            var updatedAppointment = this.createAppointmentAdapter(rawAppointment);
            targetedAppointment.recurrenceRule = "";
            targetedAppointment.recurrenceException = "";
            if (!isDeleted && !isPopupEditing) {
                this.addAppointment(rawTargetedAppointment)
            }
            var correctedExceptionDate = this._getCorrectedExceptionDateByDST(exceptionDate, appointment, targetedAppointment);
            updatedAppointment.recurrenceException = this._createRecurrenceException(correctedExceptionDate, rawAppointment);
            if (isPopupEditing) {
                this._updatedRecAppointment = updatedAppointment.source();
                this._appointmentPopup.show(rawTargetedAppointment, true);
                this._editAppointmentData = rawAppointment
            } else {
                this._updateAppointment(rawAppointment, updatedAppointment.source(), function() {
                    this._appointments.moveAppointmentBack(dragEvent)
                }, dragEvent)
            }
        }
    }, {
        key: "_createRecurrenceException",
        value: function(exceptionDate, targetAppointment) {
            var result = [];
            var adapter = this.createAppointmentAdapter(targetAppointment);
            if (adapter.recurrenceException) {
                result.push(adapter.recurrenceException)
            }
            result.push(this._serializeRecurrenceException(exceptionDate, adapter.startDate, adapter.allDay));
            return result.join()
        }
    }, {
        key: "_serializeRecurrenceException",
        value: function(exceptionDate, targetStartDate, isAllDay) {
            isAllDay && exceptionDate.setHours(targetStartDate.getHours(), targetStartDate.getMinutes(), targetStartDate.getSeconds(), targetStartDate.getMilliseconds());
            return _date_serialization.default.serializeDate(exceptionDate, UTC_FULL_DATE_FORMAT)
        }
    }, {
        key: "_showRecurrenceChangeConfirm",
        value: function(isDeleted) {
            var message = _message.default.format(isDeleted ? "dxScheduler-confirmRecurrenceDeleteMessage" : "dxScheduler-confirmRecurrenceEditMessage");
            var seriesText = _message.default.format(isDeleted ? "dxScheduler-confirmRecurrenceDeleteSeries" : "dxScheduler-confirmRecurrenceEditSeries");
            var occurrenceText = _message.default.format(isDeleted ? "dxScheduler-confirmRecurrenceDeleteOccurrence" : "dxScheduler-confirmRecurrenceEditOccurrence");
            return (0, _dialog.custom)({
                messageHtml: message,
                showCloseButton: true,
                showTitle: true,
                buttons: [{
                    text: seriesText,
                    onClick: function() {
                        return true
                    }
                }, {
                    text: occurrenceText,
                    onClick: function() {
                        return false
                    }
                }]
            }).show()
        }
    }, {
        key: "_getUpdatedData",
        value: function(options) {
            var target = options.data || options;
            var cellData = this.getTargetCellData();
            var targetAllDay = this.fire("getField", "allDay", target);
            var targetStartDate = new Date(this.fire("getField", "startDate", target));
            var targetEndDate = new Date(this.fire("getField", "endDate", target));
            var date = cellData.startDate || targetStartDate;
            if (!targetStartDate || isNaN(targetStartDate)) {
                targetStartDate = date
            }
            var targetStartTime = targetStartDate.getTime();
            if (!targetEndDate || isNaN(targetEndDate)) {
                targetEndDate = cellData.endDate
            }
            var targetEndTime = targetEndDate.getTime() || cellData.endData;
            var duration = targetEndTime - targetStartTime;
            if (this._workSpace.keepOriginalHours()) {
                var diff = targetStartTime - _date.default.trimTime(targetStartDate).getTime();
                date = new Date(_date.default.trimTime(date).getTime() + diff)
            }
            var updatedData = {};
            var allDay = cellData.allDay;
            this.fire("setField", "allDay", updatedData, allDay);
            this.fire("setField", "startDate", updatedData, date);
            var endDate = new Date(date.getTime() + duration);
            if (this.appointmentTakesAllDay(target) && !updatedData.allDay && this._workSpace.supportAllDayRow()) {
                endDate = this._workSpace.calculateEndDate(date)
            }
            if (targetAllDay && !this._workSpace.supportAllDayRow() && !this._workSpace.keepOriginalHours()) {
                var dateCopy = new Date(date);
                dateCopy.setHours(0);
                endDate = new Date(dateCopy.getTime() + duration);
                if (0 !== endDate.getHours()) {
                    endDate.setHours(this._getCurrentViewOption("endDayHour"))
                }
            }
            endDate = new Date(endDate.getTime() - _utils.default.getTimezoneOffsetChangeInMs(targetStartDate, targetEndDate, date, endDate));
            this.fire("setField", "endDate", updatedData, endDate);
            this._resourcesManager.setResourcesToItem(updatedData, cellData.groups);
            return updatedData
        }
    }, {
        key: "getTargetedAppointment",
        value: function(appointment, element) {
            var settings = _utils2.default.dataAccessors.getAppointmentSettings(element);
            var info = _utils2.default.dataAccessors.getAppointmentInfo(element);
            var appointmentIndex = (0, _renderer.default)(element).data(this._appointments._itemIndexKey());
            var adapter = this.createAppointmentAdapter(appointment);
            var targetedAdapter = adapter.clone();
            var isRecurrenceAppointment = adapter.recurrenceRule && (0, _recurrence.getRecurrenceProcessor)().isValidRecurrenceRule(adapter.recurrenceRule);
            if (this._isAgenda() && isRecurrenceAppointment) {
                var getStartDate = this.getRenderingStrategyInstance().getAppointmentDataCalculator();
                var newStartDate = getStartDate((0, _renderer.default)(element), adapter.startDate).startDate;
                targetedAdapter.startDate = newStartDate;
                targetedAdapter.endDate = new Date(newStartDate.getTime() + adapter.duration)
            } else {
                if (settings) {
                    targetedAdapter.startDate = info ? info.sourceAppointment.startDate : adapter.startDate;
                    targetedAdapter.endDate = info ? info.sourceAppointment.endDate : adapter.endDate
                }
            }
            element && this.setTargetedAppointmentResources(targetedAdapter.source(), element, appointmentIndex);
            return targetedAdapter.source()
        }
    }, {
        key: "subscribe",
        value: function(subject, action) {
            this._subscribes[subject] = _uiScheduler5.default[subject] = action
        }
    }, {
        key: "fire",
        value: function(subject) {
            var callback = this._subscribes[subject];
            var args = Array.prototype.slice.call(arguments);
            if (!(0, _type.isFunction)(callback)) {
                throw _ui.default.Error("E1031", subject)
            }
            return callback.apply(this, args.slice(1))
        }
    }, {
        key: "getTargetCellData",
        value: function() {
            return this._workSpace.getDataByDroppableCell()
        }
    }, {
        key: "_updateAppointment",
        value: function(target, appointment, onUpdatePrevented, dragEvent) {
            var updatingOptions = {
                newData: appointment,
                oldData: (0, _extend.extend)({}, target),
                cancel: false
            };
            var performFailAction = function(err) {
                if ((0, _type.isFunction)(onUpdatePrevented)) {
                    onUpdatePrevented.call(this)
                }
                if (err && "Error" === err.name) {
                    throw err
                }
            }.bind(this);
            this._actions.onAppointmentUpdating(updatingOptions);
            if (dragEvent && !(0, _type.isDeferred)(dragEvent.cancel)) {
                dragEvent.cancel = new _deferred.Deferred
            }
            return this._processActionResult(updatingOptions, function(canceled) {
                var deferred = new _deferred.Deferred;
                if (!canceled) {
                    this._expandAllDayPanel(appointment);
                    try {
                        deferred = this._appointmentModel.update(target, appointment).done(function() {
                            dragEvent && dragEvent.cancel.resolve(false)
                        }).always(function(e) {
                            this._executeActionWhenOperationIsCompleted(this._actions.onAppointmentUpdated, appointment, e)
                        }.bind(this)).fail(function() {
                            performFailAction()
                        })
                    } catch (err) {
                        performFailAction(err);
                        deferred.resolve()
                    }
                } else {
                    performFailAction();
                    deferred.resolve()
                }
                return deferred.promise()
            })
        }
    }, {
        key: "_processActionResult",
        value: function(actionOptions, callback) {
            var _this10 = this;
            var deferred = new _deferred.Deferred;
            var resolveCallback = function(callbackResult) {
                (0, _deferred.when)((0, _deferred.fromPromise)(callbackResult)).always(deferred.resolve)
            };
            if ((0, _type.isPromise)(actionOptions.cancel)) {
                (0, _deferred.when)((0, _deferred.fromPromise)(actionOptions.cancel)).always(function(cancel) {
                    if (!(0, _type.isDefined)(cancel)) {
                        cancel = "rejected" === actionOptions.cancel.state()
                    }
                    resolveCallback(callback.call(_this10, cancel))
                })
            } else {
                resolveCallback(callback.call(this, actionOptions.cancel))
            }
            return deferred.promise()
        }
    }, {
        key: "_expandAllDayPanel",
        value: function(appointment) {
            if (!this._isAllDayExpanded(this.getFilteredItems()) && this.appointmentTakesAllDay(appointment)) {
                this._workSpace.option("allDayExpanded", true)
            }
        }
    }, {
        key: "_executeActionWhenOperationIsCompleted",
        value: function(action, appointment, e) {
            var options = {
                appointmentData: appointment
            };
            var isError = e && "Error" === e.name;
            if (isError) {
                options.error = e
            } else {
                this._appointmentPopup.isVisible() && this._appointmentPopup.hide()
            }
            action(options);
            this._fireContentReadyAction()
        }
    }, {
        key: "getAppointmentPopup",
        value: function() {
            return this._appointmentPopup.getPopup()
        }
    }, {
        key: "getUpdatedAppointment",
        value: function() {
            return this._appointmentModel.getUpdatedAppointment()
        }
    }, {
        key: "getUpdatedAppointmentKeys",
        value: function() {
            return this._appointmentModel.getUpdatedAppointmentKeys()
        }
    }, {
        key: "getAppointmentsInstance",
        value: function() {
            return this._appointments
        }
    }, {
        key: "getResourceManager",
        value: function() {
            return this._resourcesManager
        }
    }, {
        key: "getLayoutManager",
        value: function() {
            return this._layoutManager
        }
    }, {
        key: "getRenderingStrategyInstance",
        value: function() {
            return this._layoutManager.getRenderingStrategyInstance()
        }
    }, {
        key: "getFilteredItems",
        value: function() {
            return this._filteredItems
        }
    }, {
        key: "getActions",
        value: function() {
            return this._actions
        }
    }, {
        key: "appointmentTakesAllDay",
        value: function(appointment) {
            return this._appointmentModel.appointmentTakesAllDay(appointment, this._getCurrentViewOption("startDayHour"), this._getCurrentViewOption("endDayHour"))
        }
    }, {
        key: "_getRecurrenceException",
        value: function(appointmentData) {
            var recurrenceException = this.fire("getField", "recurrenceException", appointmentData);
            if (recurrenceException) {
                var startDate = this.fire("getField", "startDate", appointmentData);
                var exceptions = recurrenceException.split(",");
                var startDateTimeZone = this.fire("getField", "startDateTimeZone", appointmentData);
                for (var i = 0; i < exceptions.length; i++) {
                    exceptions[i] = this._convertRecurrenceException(exceptions[i], startDate, startDateTimeZone)
                }
                recurrenceException = exceptions.join()
            }
            return recurrenceException
        }
    }, {
        key: "_convertRecurrenceException",
        value: function(exceptionString, startDate, startDateTimeZone) {
            exceptionString = exceptionString.replace(/\s/g, "");
            var exceptionDate = _date_serialization.default.deserializeDate(exceptionString);
            var convertedStartDate = this.fire("convertDateByTimezone", startDate, startDateTimeZone);
            var convertedExceptionDate = this.fire("convertDateByTimezone", exceptionDate, startDateTimeZone);
            convertedExceptionDate = _utils.default.correctRecurrenceExceptionByTimezone(convertedExceptionDate, convertedStartDate, this.option("timeZone"), startDateTimeZone);
            exceptionString = _date_serialization.default.serializeDate(convertedExceptionDate, FULL_DATE_FORMAT);
            return exceptionString
        }
    }, {
        key: "dayHasAppointment",
        value: function(day, appointment, trimTime) {
            var startDate = new Date(this.fire("getField", "startDate", appointment));
            var endDate = new Date(this.fire("getField", "endDate", appointment));
            var startDateTimeZone = this.fire("getField", "startDateTimeZone", appointment);
            var endDateTimeZone = this.fire("getField", "endDateTimeZone", appointment);
            startDate = this.fire("convertDateByTimezone", startDate, startDateTimeZone);
            endDate = this.fire("convertDateByTimezone", endDate, endDateTimeZone);
            if (day.getTime() === endDate.getTime()) {
                return startDate.getTime() === endDate.getTime()
            }
            if (trimTime) {
                day = _date.default.trimTime(day);
                startDate = _date.default.trimTime(startDate);
                endDate = _date.default.trimTime(endDate)
            }
            var dayTimeStamp = day.getTime();
            var startDateTimeStamp = startDate.getTime();
            var endDateTimeStamp = endDate.getTime();
            return (0, _array.inArray)(dayTimeStamp, [startDateTimeStamp, endDateTimeStamp]) > -1 || startDateTimeStamp < dayTimeStamp && endDateTimeStamp > dayTimeStamp
        }
    }, {
        key: "setTargetedAppointmentResources",
        value: function(targetedAppointment, appointmentElement, appointmentIndex) {
            var groups = this._getCurrentViewOption("groups");
            if (groups && groups.length) {
                var resourcesSetter = this._resourcesManager._dataAccessors.setter;
                var workSpace = this._workSpace;
                var getGroups;
                var setResourceCallback;
                if (this._isAgenda()) {
                    getGroups = function() {
                        var apptSettings = this.getLayoutManager()._positionMap[appointmentIndex];
                        return workSpace._getCellGroups(apptSettings[0].groupIndex)
                    };
                    setResourceCallback = function(_, group) {
                        resourcesSetter[group.name](targetedAppointment, group.id)
                    }
                } else {
                    getGroups = function() {
                        var setting = (0, _renderer.default)(appointmentElement).data("dxAppointmentSettings") || {};
                        return workSpace.getCellDataByCoordinates({
                            left: setting.left,
                            top: setting.top
                        }).groups
                    };
                    setResourceCallback = function(field, value) {
                        resourcesSetter[field](targetedAppointment, value)
                    }
                }(0, _iterator.each)(getGroups.call(this), setResourceCallback)
            }
        }
    }, {
        key: "getStartViewDate",
        value: function() {
            return this._workSpace.getStartViewDate()
        }
    }, {
        key: "getEndViewDate",
        value: function() {
            return this._workSpace.getEndViewDate()
        }
    }, {
        key: "showAppointmentPopup",
        value: function(rawAppointment, createNewAppointment, rawTargetedAppointment) {
            var _this11 = this;
            var appointment = this.createAppointmentAdapter(rawTargetedAppointment || rawAppointment);
            var newTargetedAppointment = (0, _extend.extend)({}, rawAppointment, rawTargetedAppointment);
            this._checkRecurringAppointment(rawAppointment, newTargetedAppointment, appointment.startDate, function() {
                if (createNewAppointment || (0, _type.isEmptyObject)(rawAppointment)) {
                    delete _this11._editAppointmentData;
                    _this11._editing.allowAdding && _this11._appointmentPopup.show(rawAppointment, true)
                } else {
                    _this11._editAppointmentData = rawAppointment;
                    _this11._appointmentPopup.show(rawAppointment, _this11._editing.allowUpdating)
                }
            }, false, true)
        }
    }, {
        key: "hideAppointmentPopup",
        value: function(saveChanges) {
            if (this._appointmentPopup && this._appointmentPopup.isVisible()) {
                saveChanges && this._appointmentPopup.saveChanges();
                this._appointmentPopup.hide()
            }
        }
    }, {
        key: "showAppointmentTooltip",
        value: function(appointment, target, targetedAppointment) {
            if (appointment) {
                var info = new _dataStructures.AppointmentTooltipInfo(appointment, targetedAppointment, this._appointments._tryGetAppointmentColor(target));
                this.showAppointmentTooltipCore(target, [info])
            }
        }
    }, {
        key: "showAppointmentTooltipCore",
        value: function(target, data, options) {
            if (this._appointmentTooltip.isAlreadyShown(target)) {
                this.hideAppointmentTooltip()
            } else {
                this._appointmentTooltip.show(target, data, (0, _extend.extend)(this._getExtraAppointmentTooltipOptions(), options))
            }
        }
    }, {
        key: "hideAppointmentTooltip",
        value: function() {
            this._appointmentTooltip && this._appointmentTooltip.hide()
        }
    }, {
        key: "scrollToTime",
        value: function(hours, minutes, date) {
            this._workSpace.scrollToTime(hours, minutes, date)
        }
    }, {
        key: "scrollTo",
        value: function(date, groups, allDay) {
            this._workSpace.scrollTo(date, groups, allDay)
        }
    }, {
        key: "addAppointment",
        value: function(appointment) {
            var _this12 = this;
            var adapter = this.createAppointmentAdapter(appointment);
            adapter.text = adapter.text || "";
            var serializedAppointment = adapter.source(true);
            var addingOptions = {
                appointmentData: serializedAppointment,
                cancel: false
            };
            this._actions.onAppointmentAdding(addingOptions);
            return this._processActionResult(addingOptions, function(canceled) {
                if (canceled) {
                    return (new _deferred.Deferred).resolve()
                }
                _this12._expandAllDayPanel(serializedAppointment);
                return _this12._appointmentModel.add(serializedAppointment).always(function(e) {
                    return _this12._executeActionWhenOperationIsCompleted(_this12._actions.onAppointmentAdded, serializedAppointment, e)
                })
            })
        }
    }, {
        key: "updateAppointment",
        value: function(target, appointment) {
            return this._updateAppointment(target, appointment)
        }
    }, {
        key: "deleteAppointment",
        value: function(appointment) {
            var deletingOptions = {
                appointmentData: appointment,
                cancel: false
            };
            this._actions.onAppointmentDeleting(deletingOptions);
            this._processActionResult(deletingOptions, function(canceled) {
                if (!canceled) {
                    this._appointmentModel.remove(appointment).always(function(e) {
                        this._executeActionWhenOperationIsCompleted(this._actions.onAppointmentDeleted, appointment, e)
                    }.bind(this))
                }
            })
        }
    }, {
        key: "focus",
        value: function() {
            if (this._editAppointmentData) {
                this._appointments.focus()
            } else {
                this._workSpace.focus()
            }
        }
    }, {
        key: "getFirstDayOfWeek",
        value: function() {
            return (0, _type.isDefined)(this.option("firstDayOfWeek")) ? this.option("firstDayOfWeek") : _date2.default.firstDayOfWeekIndex()
        }
    }, {
        key: "createAppointmentAdapter",
        value: function(rawAppointment) {
            var _this13 = this;
            var options = {
                getField: function(rawAppointment, property) {
                    return _this13.fire("getField", property, rawAppointment)
                },
                setField: function(rawAppointment, property, value) {
                    return _this13.fire("setField", property, rawAppointment, value)
                },
                getTimeZoneCalculator: function() {
                    return _this13.timeZoneCalculator
                }
            };
            return new _appointmentAdapter.default(rawAppointment, options)
        }
    }]);
    return Scheduler
}(_ui2.default);
Scheduler.include(_data_helper.default);
(0, _component_registrator.default)("dxScheduler", Scheduler);
var _default = Scheduler;
exports.default = _default;
module.exports = exports.default;
